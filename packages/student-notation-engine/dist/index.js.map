{"version":3,"file":"index.js","sources":["../../pitch-data/src/pitchData.ts","../../pitch-data/src/pitchUtils.ts","../src/state/initialState.ts","../src/state/actions/noteActions.ts","../src/state/actions/sixteenthStampActions.ts","../src/state/actions/tripletStampActions.ts","../src/rhythm/modulationMapping.ts","../src/state/actions/rhythmActions.ts","../src/state/store.ts","../src/services/columnMapService.ts","../src/controller.ts","../src/audio/FilteredVoice.ts","../src/audio/GainManager.ts","../src/audio/ClippingMonitor.ts","../src/audio/synthEngine.ts","../src/transport/timeMapCalculator.ts","../src/transport/drumManager.ts","../src/audio/transportService.ts","../src/audio/contextConfig.ts","../src/canvas/coordinateUtils.ts","../src/canvas/notes.ts","../src/canvas/gridLines.ts","../src/canvas/pitchGridRenderer.ts","../src/canvas/drumGridRenderer.ts","../src/highway/feedbackCollector.ts","../src/highway/noteHighwayService.ts","../src/highway/converter.ts","../src/index.ts"],"sourcesContent":["/**\n * FULL PITCH GAMUT DATA\n * =====================\n * The single source of truth for all pitch information across Music Learning Tools.\n *\n * STRUCTURE:\n * Contains pitch rows from C8 (highest) to A0 (lowest audible pitch).\n * Each object contains:\n * - pitch: The display name for the pitch (e.g., \"B♭/A♯7\") - combined notation for accidentals, single for naturals.\n * - flatName: The flat enharmonic spelling (e.g., \"B♭7\") - same as pitch for naturals.\n * - sharpName: The sharp enharmonic spelling (e.g., \"A♯7\") - same as pitch for naturals.\n * - toneNote: The scientific pitch notation compatible with Tone.js (e.g., \"Bb7\").\n * - frequency: The frequency in Hz.\n * - column: The pitch-row parity column ('A' or 'B') used by the pitch-to-Y axis mapping.\n * - hex: The specific color code for this exact pitch.\n * - isAccidental: Boolean flag indicating if this is a black key (accidental note).\n * - midi: MIDI note number (21-108 for A0-C8).\n * - pitchClass: Pitch class (0-11, where C=0).\n * - octave: Octave number (-1 to 8).\n *\n * MUSICAL RANGE:\n * - Audible range: Rows 0..87 (C8 to A0) - standard 88-key piano range\n * - MIDI numbers: 108 (C8) to 21 (A0)\n */\nimport type { PitchRowData } from '@mlt/types';\n\nexport const fullRowData: PitchRowData[] = [\n  // === AUDIBLE PITCH RANGE (C8 to A0) ===\n  { pitch: 'C8', flatName: 'C8', sharpName: 'C8', toneNote: 'C8', frequency: 4186.01, column: 'A', hex: '#fcfcfc', isAccidental: false, midi: 108, pitchClass: 0, octave: 8 },\n  { pitch: 'B7', flatName: 'B7', sharpName: 'B7', toneNote: 'B7', frequency: 3951.07, column: 'B', hex: '#fcf7fc', isAccidental: false, midi: 107, pitchClass: 11, octave: 7 },\n  { pitch: 'B♭/A♯7', flatName: 'B♭7', sharpName: 'A♯7', toneNote: 'Bb7', frequency: 3729.31, column: 'A', hex: '#f7f5fd', isAccidental: true, midi: 106, pitchClass: 10, octave: 7 },\n  { pitch: 'A7', flatName: 'A7', sharpName: 'A7', toneNote: 'A7', frequency: 3520.00, column: 'B', hex: '#f0f4ff', isAccidental: false, midi: 105, pitchClass: 9, octave: 7 },\n  { pitch: 'A♭/G♯7', flatName: 'A♭7', sharpName: 'G♯7', toneNote: 'Ab7', frequency: 3322.44, column: 'A', hex: '#e6f3fd', isAccidental: true, midi: 104, pitchClass: 8, octave: 7 },\n  { pitch: 'G7', flatName: 'G7', sharpName: 'G7', toneNote: 'G7', frequency: 3135.96, column: 'B', hex: '#def3f7', isAccidental: false, midi: 103, pitchClass: 7, octave: 7 },\n  { pitch: 'G♭/F♯7', flatName: 'G♭7', sharpName: 'F♯7', toneNote: 'Gb7', frequency: 2959.96, column: 'A', hex: '#daf2ec', isAccidental: true, midi: 102, pitchClass: 6, octave: 7 },\n  { pitch: 'F7', flatName: 'F7', sharpName: 'F7', toneNote: 'F7', frequency: 2793.83, column: 'B', hex: '#dcefdf', isAccidental: false, midi: 101, pitchClass: 5, octave: 7 },\n  { pitch: 'E7', flatName: 'E7', sharpName: 'E7', toneNote: 'E7', frequency: 2637.02, column: 'A', hex: '#e3ebd1', isAccidental: false, midi: 100, pitchClass: 4, octave: 7 },\n  { pitch: 'E♭/D♯7', flatName: 'E♭7', sharpName: 'D♯7', toneNote: 'Eb7', frequency: 2489.02, column: 'B', hex: '#eee4c8', isAccidental: true, midi: 99, pitchClass: 3, octave: 7 },\n  { pitch: 'D7', flatName: 'D7', sharpName: 'D7', toneNote: 'D7', frequency: 2349.32, column: 'A', hex: '#f8dcc6', isAccidental: false, midi: 98, pitchClass: 2, octave: 7 },\n  { pitch: 'D♭/C♯7', flatName: 'D♭7', sharpName: 'C♯7', toneNote: 'Db7', frequency: 2217.46, column: 'B', hex: '#fcd4cd', isAccidental: true, midi: 97, pitchClass: 1, octave: 7 },\n  { pitch: 'C7', flatName: 'C7', sharpName: 'C7', toneNote: 'C7', frequency: 2093.00, column: 'A', hex: '#facfdb', isAccidental: false, midi: 96, pitchClass: 0, octave: 7 },\n  { pitch: 'B6', flatName: 'B6', sharpName: 'B6', toneNote: 'B6', frequency: 1975.53, column: 'B', hex: '#efcdeb', isAccidental: false, midi: 95, pitchClass: 11, octave: 6 },\n  { pitch: 'B♭/A♯6', flatName: 'B♭6', sharpName: 'A♯6', toneNote: 'Bb6', frequency: 1864.66, column: 'A', hex: '#ddcff9', isAccidental: true, midi: 94, pitchClass: 10, octave: 6 },\n  { pitch: 'A6', flatName: 'A6', sharpName: 'A6', toneNote: 'A6', frequency: 1760.00, column: 'B', hex: '#c4d3ff', isAccidental: false, midi: 93, pitchClass: 9, octave: 6 },\n  { pitch: 'A♭/G♯6', flatName: 'A♭6', sharpName: 'G♯6', toneNote: 'Ab6', frequency: 1661.22, column: 'A', hex: '#abd9fa', isAccidental: true, midi: 92, pitchClass: 8, octave: 6 },\n  { pitch: 'G6', flatName: 'G6', sharpName: 'G6', toneNote: 'G6', frequency: 1567.94, column: 'B', hex: '#98dde9', isAccidental: false, midi: 91, pitchClass: 7, octave: 6 },\n  { pitch: 'G♭/F♯6', flatName: 'G♭6', sharpName: 'F♯6', toneNote: 'Gb6', frequency: 1479.98, column: 'A', hex: '#96ddcf', isAccidental: true, midi: 90, pitchClass: 6, octave: 6 },\n  { pitch: 'F6', flatName: 'F6', sharpName: 'F6', toneNote: 'F6', frequency: 1396.91, column: 'B', hex: '#a6d9b0', isAccidental: false, midi: 89, pitchClass: 5, octave: 6 },\n  { pitch: 'E6', flatName: 'E6', sharpName: 'E6', toneNote: 'E6', frequency: 1318.51, column: 'A', hex: '#c0d093', isAccidental: false, midi: 88, pitchClass: 4, octave: 6 },\n  { pitch: 'E♭/D♯6', flatName: 'E♭6', sharpName: 'D♯6', toneNote: 'Eb6', frequency: 1244.51, column: 'B', hex: '#dbc383', isAccidental: true, midi: 87, pitchClass: 3, octave: 6 },\n  { pitch: 'D6', flatName: 'D6', sharpName: 'D6', toneNote: 'D6', frequency: 1174.66, column: 'A', hex: '#efb586', isAccidental: false, midi: 86, pitchClass: 2, octave: 6 },\n  { pitch: 'D♭/C♯6', flatName: 'D♭6', sharpName: 'C♯6', toneNote: 'Db6', frequency: 1108.73, column: 'B', hex: '#f8a99c', isAccidental: true, midi: 85, pitchClass: 1, octave: 6 },\n  { pitch: 'C6', flatName: 'C6', sharpName: 'C6', toneNote: 'C6', frequency: 1046.50, column: 'A', hex: '#f3a2bb', isAccidental: false, midi: 84, pitchClass: 0, octave: 6 },\n  { pitch: 'B5', flatName: 'B5', sharpName: 'B5', toneNote: 'B5', frequency: 987.77, column: 'B', hex: '#e1a3db', isAccidental: false, midi: 83, pitchClass: 11, octave: 5 },\n  { pitch: 'B♭/A♯5', flatName: 'B♭5', sharpName: 'A♯5', toneNote: 'Bb5', frequency: 932.33, column: 'A', hex: '#c3a9f4', isAccidental: true, midi: 82, pitchClass: 10, octave: 5 },\n  { pitch: 'A5', flatName: 'A5', sharpName: 'A5', toneNote: 'A5', frequency: 880.00, column: 'B', hex: '#9ab2ff', isAccidental: false, midi: 81, pitchClass: 9, octave: 5 },\n  { pitch: 'A♭/G♯5', flatName: 'A♭5', sharpName: 'G♯5', toneNote: 'Ab5', frequency: 830.61, column: 'A', hex: '#67bdf7', isAccidental: true, midi: 80, pitchClass: 8, octave: 5 },\n  { pitch: 'G5', flatName: 'G5', sharpName: 'G5', toneNote: 'G5', frequency: 783.99, column: 'B', hex: '#30c6dc', isAccidental: false, midi: 79, pitchClass: 7, octave: 5 },\n  { pitch: 'G♭/F♯5', flatName: 'G♭5', sharpName: 'F♯5', toneNote: 'Gb5', frequency: 739.99, column: 'A', hex: '#32c8b2', isAccidental: true, midi: 78, pitchClass: 6, octave: 5 },\n  { pitch: 'F5', flatName: 'F5', sharpName: 'F5', toneNote: 'F5', frequency: 698.46, column: 'B', hex: '#6dc281', isAccidental: false, midi: 77, pitchClass: 5, octave: 5 },\n  { pitch: 'E5', flatName: 'E5', sharpName: 'E5', toneNote: 'E5', frequency: 659.25, column: 'A', hex: '#a0b556', isAccidental: false, midi: 76, pitchClass: 4, octave: 5 },\n  { pitch: 'E♭/D♯5', flatName: 'E♭5', sharpName: 'D♯5', toneNote: 'Eb5', frequency: 622.25, column: 'B', hex: '#c5a33f', isAccidental: true, midi: 75, pitchClass: 3, octave: 5 },\n  { pitch: 'D5', flatName: 'D5', sharpName: 'D5', toneNote: 'D5', frequency: 587.33, column: 'A', hex: '#dc9150', isAccidental: false, midi: 74, pitchClass: 2, octave: 5 },\n  { pitch: 'D♭/C♯5', flatName: 'D♭5', sharpName: 'C♯5', toneNote: 'Db5', frequency: 554.37, column: 'B', hex: '#e38475', isAccidental: true, midi: 73, pitchClass: 1, octave: 5 },\n  { pitch: 'C5', flatName: 'C5', sharpName: 'C5', toneNote: 'C5', frequency: 523.25, column: 'A', hex: '#dc7f9d', isAccidental: false, midi: 72, pitchClass: 0, octave: 5 },\n  { pitch: 'B4', flatName: 'B4', sharpName: 'B4', toneNote: 'B4', frequency: 493.88, column: 'B', hex: '#c781c0', isAccidental: false, midi: 71, pitchClass: 11, octave: 4 },\n  { pitch: 'B♭/A♯4', flatName: 'B♭4', sharpName: 'A♯4', toneNote: 'Bb4', frequency: 466.16, column: 'A', hex: '#a68ad8', isAccidental: true, midi: 70, pitchClass: 10, octave: 4 },\n  { pitch: 'A4', flatName: 'A4', sharpName: 'A4', toneNote: 'A4', frequency: 440.00, column: 'B', hex: '#7d94e0', isAccidental: false, midi: 69, pitchClass: 9, octave: 4 },\n  { pitch: 'A♭/G♯4', flatName: 'A♭4', sharpName: 'G♯4', toneNote: 'Ab4', frequency: 415.30, column: 'A', hex: '#4c9fd5', isAccidental: true, midi: 68, pitchClass: 8, octave: 4 },\n  { pitch: 'G4', flatName: 'G4', sharpName: 'G4', toneNote: 'G4', frequency: 392.00, column: 'B', hex: '#0fa6ba', isAccidental: false, midi: 67, pitchClass: 7, octave: 4 },\n  { pitch: 'G♭/F♯4', flatName: 'G♭4', sharpName: 'F♯4', toneNote: 'Gb4', frequency: 369.99, column: 'A', hex: '#24a794', isAccidental: true, midi: 66, pitchClass: 6, octave: 4 },\n  { pitch: 'F4', flatName: 'F4', sharpName: 'F4', toneNote: 'F4', frequency: 349.23, column: 'B', hex: '#5aa26a', isAccidental: false, midi: 65, pitchClass: 5, octave: 4 },\n  { pitch: 'E4', flatName: 'E4', sharpName: 'E4', toneNote: 'E4', frequency: 329.63, column: 'A', hex: '#849646', isAccidental: false, midi: 64, pitchClass: 4, octave: 4 },\n  { pitch: 'E♭/D♯4', flatName: 'E♭4', sharpName: 'D♯4', toneNote: 'Eb4', frequency: 311.13, column: 'B', hex: '#a38733', isAccidental: true, midi: 63, pitchClass: 3, octave: 4 },\n  { pitch: 'D4', flatName: 'D4', sharpName: 'D4', toneNote: 'D4', frequency: 293.66, column: 'A', hex: '#b67740', isAccidental: false, midi: 62, pitchClass: 2, octave: 4 },\n  { pitch: 'D♭/C♯4', flatName: 'D♭4', sharpName: 'C♯4', toneNote: 'Db4', frequency: 277.18, column: 'B', hex: '#bc6c5f', isAccidental: true, midi: 61, pitchClass: 1, octave: 4 },\n  { pitch: 'C4', flatName: 'C4', sharpName: 'C4', toneNote: 'C4', frequency: 261.63, column: 'A', hex: '#b56880', isAccidental: false, midi: 60, pitchClass: 0, octave: 4 },\n  { pitch: 'B3', flatName: 'B3', sharpName: 'B3', toneNote: 'B3', frequency: 246.94, column: 'B', hex: '#a3699e', isAccidental: false, midi: 59, pitchClass: 11, octave: 3 },\n  { pitch: 'B♭/A♯3', flatName: 'B♭3', sharpName: 'A♯3', toneNote: 'Bb3', frequency: 233.08, column: 'A', hex: '#8870b1', isAccidental: true, midi: 58, pitchClass: 10, octave: 3 },\n  { pitch: 'A3', flatName: 'A3', sharpName: 'A3', toneNote: 'A3', frequency: 220.00, column: 'B', hex: '#6578b7', isAccidental: false, midi: 57, pitchClass: 9, octave: 3 },\n  { pitch: 'A♭/G♯3', flatName: 'A♭3', sharpName: 'G♯3', toneNote: 'Ab3', frequency: 207.65, column: 'A', hex: '#3c81ad', isAccidental: true, midi: 56, pitchClass: 8, octave: 3 },\n  { pitch: 'G3', flatName: 'G3', sharpName: 'G3', toneNote: 'G3', frequency: 196.00, column: 'B', hex: '#0e8696', isAccidental: false, midi: 55, pitchClass: 7, octave: 3 },\n  { pitch: 'G♭/F♯3', flatName: 'G♭3', sharpName: 'F♯3', toneNote: 'Gb3', frequency: 185.00, column: 'A', hex: '#1b8777', isAccidental: true, midi: 54, pitchClass: 6, octave: 3 },\n  { pitch: 'F3', flatName: 'F3', sharpName: 'F3', toneNote: 'F3', frequency: 174.61, column: 'B', hex: '#478255', isAccidental: false, midi: 53, pitchClass: 5, octave: 3 },\n  { pitch: 'E3', flatName: 'E3', sharpName: 'E3', toneNote: 'E3', frequency: 164.81, column: 'A', hex: '#697836', isAccidental: false, midi: 52, pitchClass: 4, octave: 3 },\n  { pitch: 'E♭/D♯3', flatName: 'E♭3', sharpName: 'D♯3', toneNote: 'Eb3', frequency: 155.56, column: 'B', hex: '#836b27', isAccidental: true, midi: 51, pitchClass: 3, octave: 3 },\n  { pitch: 'D3', flatName: 'D3', sharpName: 'D3', toneNote: 'D3', frequency: 146.83, column: 'A', hex: '#925e32', isAccidental: false, midi: 50, pitchClass: 2, octave: 3 },\n  { pitch: 'D♭/C♯3', flatName: 'D♭3', sharpName: 'C♯3', toneNote: 'Db3', frequency: 138.59, column: 'B', hex: '#96554b', isAccidental: true, midi: 49, pitchClass: 1, octave: 3 },\n  { pitch: 'C3', flatName: 'C3', sharpName: 'C3', toneNote: 'C3', frequency: 130.81, column: 'A', hex: '#905165', isAccidental: false, midi: 48, pitchClass: 0, octave: 3 },\n  { pitch: 'B2', flatName: 'B2', sharpName: 'B2', toneNote: 'B2', frequency: 123.47, column: 'B', hex: '#80527c', isAccidental: false, midi: 47, pitchClass: 11, octave: 2 },\n  { pitch: 'B♭/A♯2', flatName: 'B♭2', sharpName: 'A♯2', toneNote: 'Bb2', frequency: 116.54, column: 'A', hex: '#6a578c', isAccidental: true, midi: 46, pitchClass: 10, octave: 2 },\n  { pitch: 'A2', flatName: 'A2', sharpName: 'A2', toneNote: 'A2', frequency: 110.00, column: 'B', hex: '#4e5e90', isAccidental: false, midi: 45, pitchClass: 9, octave: 2 },\n  { pitch: 'A♭/G♯2', flatName: 'A♭2', sharpName: 'G♯2', toneNote: 'Ab2', frequency: 103.83, column: 'A', hex: '#2d6488', isAccidental: true, midi: 44, pitchClass: 8, octave: 2 },\n  { pitch: 'G2', flatName: 'G2', sharpName: 'G2', toneNote: 'G2', frequency: 98.00, column: 'B', hex: '#096875', isAccidental: false, midi: 43, pitchClass: 7, octave: 2 },\n  { pitch: 'G♭/F♯2', flatName: 'G♭2', sharpName: 'F♯2', toneNote: 'Gb2', frequency: 92.50, column: 'A', hex: '#13685b', isAccidental: true, midi: 42, pitchClass: 6, octave: 2 },\n  { pitch: 'F2', flatName: 'F2', sharpName: 'F2', toneNote: 'F2', frequency: 87.31, column: 'B', hex: '#356440', isAccidental: false, midi: 41, pitchClass: 5, octave: 2 },\n  { pitch: 'E2', flatName: 'E2', sharpName: 'E2', toneNote: 'E2', frequency: 82.41, column: 'A', hex: '#505c28', isAccidental: false, midi: 40, pitchClass: 4, octave: 2 },\n  { pitch: 'E♭/D♯2', flatName: 'E♭2', sharpName: 'D♯2', toneNote: 'Eb2', frequency: 77.78, column: 'B', hex: '#63511c', isAccidental: true, midi: 39, pitchClass: 3, octave: 2 },\n  { pitch: 'D2', flatName: 'D2', sharpName: 'D2', toneNote: 'D2', frequency: 73.42, column: 'A', hex: '#6e4724', isAccidental: false, midi: 38, pitchClass: 2, octave: 2 },\n  { pitch: 'D♭/C♯2', flatName: 'D♭2', sharpName: 'C♯2', toneNote: 'Db2', frequency: 69.30, column: 'B', hex: '#713f37', isAccidental: true, midi: 37, pitchClass: 1, octave: 2 },\n  { pitch: 'C2', flatName: 'C2', sharpName: 'C2', toneNote: 'C2', frequency: 65.41, column: 'A', hex: '#6c3c4b', isAccidental: false, midi: 36, pitchClass: 0, octave: 2 },\n  { pitch: 'B1', flatName: 'B1', sharpName: 'B1', toneNote: 'B1', frequency: 61.74, column: 'B', hex: '#603c5d', isAccidental: false, midi: 35, pitchClass: 11, octave: 1 },\n  { pitch: 'B♭/A♯1', flatName: 'B♭1', sharpName: 'A♯1', toneNote: 'Bb1', frequency: 58.27, column: 'A', hex: '#4e4068', isAccidental: true, midi: 34, pitchClass: 10, octave: 1 },\n  { pitch: 'A1', flatName: 'A1', sharpName: 'A1', toneNote: 'A1', frequency: 55.00, column: 'B', hex: '#38446b', isAccidental: false, midi: 33, pitchClass: 9, octave: 1 },\n  { pitch: 'A♭/G♯1', flatName: 'A♭1', sharpName: 'G♯1', toneNote: 'Ab1', frequency: 51.91, column: 'A', hex: '#1f4964', isAccidental: true, midi: 32, pitchClass: 8, octave: 1 },\n  { pitch: 'G1', flatName: 'G1', sharpName: 'G1', toneNote: 'G1', frequency: 49.00, column: 'B', hex: '#044b55', isAccidental: false, midi: 31, pitchClass: 7, octave: 1 },\n  { pitch: 'G♭/F♯1', flatName: 'G♭1', sharpName: 'F♯1', toneNote: 'Gb1', frequency: 46.25, column: 'A', hex: '#0c4b41', isAccidental: true, midi: 30, pitchClass: 6, octave: 1 },\n  { pitch: 'F1', flatName: 'F1', sharpName: 'F1', toneNote: 'F1', frequency: 43.65, column: 'B', hex: '#24472c', isAccidental: false, midi: 29, pitchClass: 5, octave: 1 },\n  { pitch: 'E1', flatName: 'E1', sharpName: 'E1', toneNote: 'E1', frequency: 41.20, column: 'A', hex: '#38401a', isAccidental: false, midi: 28, pitchClass: 4, octave: 1 },\n  { pitch: 'E♭/D♯1', flatName: 'E♭1', sharpName: 'D♯1', toneNote: 'Eb1', frequency: 38.89, column: 'B', hex: '#463811', isAccidental: true, midi: 27, pitchClass: 3, octave: 1 },\n  { pitch: 'D1', flatName: 'D1', sharpName: 'D1', toneNote: 'D1', frequency: 36.71, column: 'A', hex: '#4d3017', isAccidental: false, midi: 26, pitchClass: 2, octave: 1 },\n  { pitch: 'D♭/C♯1', flatName: 'D♭1', sharpName: 'C♯1', toneNote: 'Db1', frequency: 34.65, column: 'B', hex: '#4f2a24', isAccidental: true, midi: 25, pitchClass: 1, octave: 1 },\n  { pitch: 'C1', flatName: 'C1', sharpName: 'C1', toneNote: 'C1', frequency: 32.70, column: 'A', hex: '#4a2733', isAccidental: false, midi: 24, pitchClass: 0, octave: 1 },\n  { pitch: 'B0', flatName: 'B0', sharpName: 'B0', toneNote: 'B0', frequency: 30.87, column: 'B', hex: '#41273f', isAccidental: false, midi: 23, pitchClass: 11, octave: 0 },\n  { pitch: 'B♭/A♯0', flatName: 'B♭0', sharpName: 'A♯0', toneNote: 'Bb0', frequency: 29.14, column: 'A', hex: '#342a46', isAccidental: true, midi: 22, pitchClass: 10, octave: 0 },\n  { pitch: 'A0', flatName: 'A0', sharpName: 'A0', toneNote: 'A0', frequency: 27.50, column: 'B', hex: '#242c48', isAccidental: false, midi: 21, pitchClass: 9, octave: 0 },\n];\n","/**\n * Pitch Data Utilities\n *\n * Helper functions for working with the full pitch gamut.\n */\nimport type { PitchRowData } from '@mlt/types';\nimport { fullRowData } from './pitchData.js';\n\n// Pre-build lookup maps for O(1) access\nconst toneNoteToIndex = new Map<string, number>();\nconst midiToIndex = new Map<number, number>();\n\nfullRowData.forEach((row, index) => {\n  toneNoteToIndex.set(row.toneNote, index);\n  if (row.midi !== undefined) {\n    midiToIndex.set(row.midi, index);\n  }\n});\n\n/**\n * Get pitch row data by Tone.js note name (e.g., 'C4', 'Bb5')\n */\nexport function getPitchByToneNote(toneNote: string): PitchRowData | undefined {\n  const index = toneNoteToIndex.get(toneNote);\n  return index !== undefined ? fullRowData[index] : undefined;\n}\n\n/**\n * Get pitch row data by index in fullRowData (0 = C8, 87 = A0)\n */\nexport function getPitchByIndex(index: number): PitchRowData | undefined {\n  return fullRowData[index];\n}\n\n/**\n * Get the index of a pitch by its Tone.js note name\n */\nexport function getPitchIndex(toneNote: string): number {\n  return toneNoteToIndex.get(toneNote) ?? -1;\n}\n\n/**\n * Get pitch row data by MIDI note number (21-108)\n */\nexport function getPitchByMidi(midi: number): PitchRowData | undefined {\n  const index = midiToIndex.get(midi);\n  return index !== undefined ? fullRowData[index] : undefined;\n}\n\n/**\n * Get MIDI note number from Tone.js note name\n */\nexport function getMidiFromToneNote(toneNote: string): number | undefined {\n  const pitch = getPitchByToneNote(toneNote);\n  return pitch?.midi;\n}\n\n/**\n * Resolve pitch range from Tone.js note names\n * Returns start/end indices in fullRowData (topIndex < bottomIndex since C8 is index 0)\n */\nexport function resolvePitchRange(\n  topToneNote: string,\n  bottomToneNote: string\n): { topIndex: number; bottomIndex: number } | null {\n  const topIndex = getPitchIndex(topToneNote);\n  const bottomIndex = getPitchIndex(bottomToneNote);\n\n  if (topIndex === -1 || bottomIndex === -1) {\n    return null;\n  }\n\n  return {\n    topIndex: Math.min(topIndex, bottomIndex),\n    bottomIndex: Math.max(topIndex, bottomIndex),\n  };\n}\n\n/**\n * Get a slice of row data for a specific pitch range\n * @param topToneNote - Highest pitch (e.g., 'C6')\n * @param bottomToneNote - Lowest pitch (e.g., 'C3')\n */\nexport function getRowDataForRange(\n  topToneNote: string,\n  bottomToneNote: string\n): PitchRowData[] {\n  const range = resolvePitchRange(topToneNote, bottomToneNote);\n  if (!range) return [];\n  return fullRowData.slice(range.topIndex, range.bottomIndex + 1);\n}\n\n/**\n * Generate row data for a MIDI range (useful for singing trainer)\n * @param minMidi - Lowest MIDI note (e.g., 48 for C3)\n * @param maxMidi - Highest MIDI note (e.g., 84 for C6)\n */\nexport function generateRowDataForMidiRange(\n  minMidi: number,\n  maxMidi: number\n): PitchRowData[] {\n  const rows: PitchRowData[] = [];\n\n  // Iterate from high to low (fullRowData order is C8 to A0)\n  for (let midi = maxMidi; midi >= minMidi; midi--) {\n    const pitch = getPitchByMidi(midi);\n    if (pitch) {\n      rows.push(pitch);\n    }\n  }\n\n  return rows;\n}\n\n// ============================================================================\n// MIDI Range Helpers\n// ============================================================================\n\n/**\n * A MIDI range representing a span of pitches.\n */\nexport interface MidiRange {\n  /** Lowest MIDI note number */\n  minMidi: number;\n  /** Highest MIDI note number */\n  maxMidi: number;\n}\n\n/**\n * Get MIDI range from Tone.js note names.\n * @param lowNote - Lower pitch (e.g., 'C3')\n * @param highNote - Higher pitch (e.g., 'C5')\n * @returns MidiRange or null if notes are invalid\n *\n * @example\n * getMidiRangeFromToneNotes('C3', 'C5') // { minMidi: 48, maxMidi: 72 }\n * getMidiRangeFromToneNotes('A2', 'A4') // { minMidi: 45, maxMidi: 69 }\n */\nexport function getMidiRangeFromToneNotes(\n  lowNote: string,\n  highNote: string\n): MidiRange | null {\n  const lowMidi = getMidiFromToneNote(lowNote);\n  const highMidi = getMidiFromToneNote(highNote);\n\n  if (lowMidi === undefined || highMidi === undefined) {\n    return null;\n  }\n\n  return {\n    minMidi: Math.min(lowMidi, highMidi),\n    maxMidi: Math.max(lowMidi, highMidi),\n  };\n}\n\n/**\n * Get Tone.js note names from a MIDI range.\n * @param range - MIDI range object\n * @returns Object with lowNote and highNote, or null if invalid\n *\n * @example\n * getToneNotesFromMidiRange({ minMidi: 48, maxMidi: 72 }) // { lowNote: 'C3', highNote: 'C5' }\n */\nexport function getToneNotesFromMidiRange(\n  range: MidiRange\n): { lowNote: string; highNote: string } | null {\n  const lowPitch = getPitchByMidi(range.minMidi);\n  const highPitch = getPitchByMidi(range.maxMidi);\n\n  if (!lowPitch || !highPitch) {\n    return null;\n  }\n\n  return {\n    lowNote: lowPitch.toneNote,\n    highNote: highPitch.toneNote,\n  };\n}\n\n/**\n * Expand a MIDI range by a number of semitones in each direction.\n * Clamps to valid piano range (21-108).\n *\n * @example\n * expandMidiRange({ minMidi: 48, maxMidi: 72 }, 12) // { minMidi: 36, maxMidi: 84 }\n */\nexport function expandMidiRange(range: MidiRange, semitones: number): MidiRange {\n  return {\n    minMidi: Math.max(21, range.minMidi - semitones),\n    maxMidi: Math.min(108, range.maxMidi + semitones),\n  };\n}\n\n/**\n * Shift a MIDI range up or down by a number of semitones.\n * Clamps to valid piano range (21-108).\n *\n * @example\n * shiftMidiRange({ minMidi: 48, maxMidi: 72 }, 12)  // { minMidi: 60, maxMidi: 84 }\n * shiftMidiRange({ minMidi: 48, maxMidi: 72 }, -12) // { minMidi: 36, maxMidi: 60 }\n */\nexport function shiftMidiRange(range: MidiRange, semitones: number): MidiRange {\n  const newMin = range.minMidi + semitones;\n  const newMax = range.maxMidi + semitones;\n\n  // Clamp to valid range while maintaining the span\n  if (newMin < 21) {\n    const adjustment = 21 - newMin;\n    return { minMidi: 21, maxMidi: newMax + adjustment };\n  }\n  if (newMax > 108) {\n    const adjustment = newMax - 108;\n    return { minMidi: newMin - adjustment, maxMidi: 108 };\n  }\n\n  return { minMidi: newMin, maxMidi: newMax };\n}\n\n/**\n * Get the number of semitones (pitches) in a MIDI range.\n *\n * @example\n * getMidiRangeSpan({ minMidi: 48, maxMidi: 72 }) // 25 (includes both endpoints)\n */\nexport function getMidiRangeSpan(range: MidiRange): number {\n  return range.maxMidi - range.minMidi + 1;\n}\n\n/**\n * Check if a MIDI note is within a range.\n *\n * @example\n * isMidiInRange(60, { minMidi: 48, maxMidi: 72 }) // true\n * isMidiInRange(36, { minMidi: 48, maxMidi: 72 }) // false\n */\nexport function isMidiInRange(midi: number, range: MidiRange): boolean {\n  return midi >= range.minMidi && midi <= range.maxMidi;\n}\n\n/**\n * Clamp a MIDI note to be within a range.\n *\n * @example\n * clampMidiToRange(36, { minMidi: 48, maxMidi: 72 }) // 48\n * clampMidiToRange(60, { minMidi: 48, maxMidi: 72 }) // 60\n * clampMidiToRange(84, { minMidi: 48, maxMidi: 72 }) // 72\n */\nexport function clampMidiToRange(midi: number, range: MidiRange): number {\n  return Math.max(range.minMidi, Math.min(range.maxMidi, midi));\n}\n\n// ============================================================================\n// Preset Pitch Ranges\n// ============================================================================\n\n/**\n * Common pitch ranges for different voice types and instruments.\n * Each range includes MIDI numbers and Tone.js note names.\n */\nexport const PITCH_RANGES = {\n  /** Full 88-key piano range */\n  PIANO: { minMidi: 21, maxMidi: 108, lowNote: 'A0', highNote: 'C8' },\n  /** Typical soprano voice range */\n  SOPRANO: { minMidi: 60, maxMidi: 84, lowNote: 'C4', highNote: 'C6' },\n  /** Typical alto voice range */\n  ALTO: { minMidi: 53, maxMidi: 77, lowNote: 'F3', highNote: 'F5' },\n  /** Typical tenor voice range */\n  TENOR: { minMidi: 48, maxMidi: 72, lowNote: 'C3', highNote: 'C5' },\n  /** Typical bass voice range */\n  BASS: { minMidi: 40, maxMidi: 64, lowNote: 'E2', highNote: 'E4' },\n  /** General singing range (covers most voices) */\n  SINGING: { minMidi: 48, maxMidi: 84, lowNote: 'C3', highNote: 'C6' },\n  /** Comfortable speaking range */\n  SPEAKING: { minMidi: 55, maxMidi: 70, lowNote: 'G3', highNote: 'Bb4' },\n  /** Extended vocal range (trained singers) */\n  EXTENDED_VOCAL: { minMidi: 36, maxMidi: 96, lowNote: 'C2', highNote: 'C7' },\n} as const;\n\n/** Type for preset range keys */\nexport type PitchRangePreset = keyof typeof PITCH_RANGES;\n\n/**\n * Get a MidiRange from a preset name.\n *\n * @example\n * getMidiRangeFromPreset('TENOR') // { minMidi: 48, maxMidi: 72 }\n */\nexport function getMidiRangeFromPreset(preset: PitchRangePreset): MidiRange {\n  const range = PITCH_RANGES[preset];\n  return { minMidi: range.minMidi, maxMidi: range.maxMidi };\n}\n","/**\r\n * Initial State Configuration\r\n *\r\n * Default state values for the notation engine.\r\n * This provides sensible defaults that can be overridden via configuration.\r\n */\r\n\r\nimport type { AppState, TimbresMap } from '@mlt/types';\r\nimport { fullRowData, resolvePitchRange } from './pitchData.js';\r\n\r\n/**\r\n * Default ADSR envelope settings\r\n */\r\nconst DEFAULT_ADSR = {\n  attack: 0.1,\n  decay: 0.2,\n  sustain: 0.8,\n  release: 0.3\n};\n\r\n/**\r\n * Default filter settings\r\n */\r\nconst DEFAULT_FILTER = {\r\n  enabled: false,\r\n  blend: 0.5,\r\n  cutoff: 0.5,\r\n  resonance: 0,\r\n  type: 'lowpass',\r\n  mix: 1.0\r\n};\r\n\r\n/**\r\n * Default vibrato settings\r\n */\r\nconst DEFAULT_VIBRATO = {\r\n  speed: 5,\r\n  span: 0\r\n};\r\n\r\n/**\r\n * Default tremolo settings\r\n */\r\nconst DEFAULT_TREMOLO = {\r\n  speed: 5,\r\n  span: 0\r\n};\r\n\r\n/**\r\n * Create default timbres for each note color\r\n */\r\nfunction createDefaultTimbres(): TimbresMap {\r\n  const colors = [\r\n    '#4a90e2', // Blue\r\n    '#e24a4a', // Red\r\n    '#4ae24a', // Green\r\n    '#e2e24a', // Yellow\r\n    '#e24ae2', // Magenta\r\n    '#4ae2e2', // Cyan\r\n    '#e2a04a', // Orange\r\n    '#a04ae2'  // Purple\r\n  ];\r\n\r\n  const timbres: TimbresMap = {};\r\n\r\n  colors.forEach(color => {\r\n    // Create sine wave coefficients (only first harmonic)\r\n    const coeffs = new Float32Array(32);\r\n    coeffs[0] = 1.0; // Fundamental\r\n\r\n    // Create zero phases\r\n    const phases = new Float32Array(32);\r\n\r\n    timbres[color] = {\r\n      name: 'Sine',\r\n      adsr: { ...DEFAULT_ADSR },\r\n      coeffs,\r\n      phases,\r\n      filter: { ...DEFAULT_FILTER },\r\n      activePresetName: 'sine',\r\n      gain: 1.0,\r\n      vibrato: { ...DEFAULT_VIBRATO },\r\n      tremelo: { ...DEFAULT_TREMOLO }\r\n    };\r\n  });\r\n\r\n  return timbres;\r\n}\r\n\r\n/**\r\n * Default rhythm configuration\r\n */\r\nfunction getDefaultRhythm() {\n  const macrobeatGroupings = new Array<2 | 3>(16).fill(2);\n  const macrobeatBoundaryStyles = macrobeatGroupings\n    .slice(0, -1)\n    .map((_, index) => ((index + 1) % 4 === 0 ? 'solid' : 'dashed')) as ('dashed' | 'solid' | 'anacrusis')[];\n\n  return {\n    macrobeatGroupings,\n    macrobeatBoundaryStyles,\n    hasAnacrusis: false,\n    baseMicrobeatPx: 40,\n    tempoModulationMarkers: []\n  };\n}\n\r\n/**\r\n * Calculate default pitch range (G5 to C4)\r\n */\r\nfunction getDefaultPitchRange() {\r\n  const range = resolvePitchRange('G5', 'C4');\r\n  if (range) {\r\n    return range;\r\n  }\r\n  // Fallback to full range if resolution fails\r\n  return {\r\n    topIndex: 0,\r\n    bottomIndex: Math.max(0, fullRowData.length - 1)\r\n  };\r\n}\r\n\r\n/**\r\n * Get the complete initial state\r\n */\r\nexport function getInitialState(): AppState {\r\n  const timbres = createDefaultTimbres();\r\n\r\n  return {\r\n    // --- Data & History ---\r\n    placedNotes: [],\r\n    placedChords: [],\r\n    tonicSignGroups: {},\r\n    sixteenthStampPlacements: [],\r\n    tripletStampPlacements: [],\r\n    annotations: [],\r\n    lassoSelection: {\r\n      selectedItems: [],\r\n      convexHull: null,\r\n      isActive: false\r\n    },\r\n    history: [{\r\n      notes: [],\r\n      tonicSignGroups: {},\r\n      timbres: JSON.parse(JSON.stringify(timbres)),\r\n      placedChords: [],\r\n      sixteenthStampPlacements: [],\r\n      tripletStampPlacements: [],\r\n      annotations: [],\r\n      lassoSelection: { selectedItems: [], convexHull: null, isActive: false }\r\n    }],\r\n    historyIndex: 0,\r\n    fullRowData: [...fullRowData],\r\n    pitchRange: getDefaultPitchRange(),\r\n\r\n    // --- Rhythm ---\r\n    ...getDefaultRhythm(),\r\n    selectedModulationRatio: null,\r\n\r\n    // --- Timbres & Colors ---\r\n    timbres,\r\n    colorPalette: {\r\n      '#4a90e2': { primary: '#4a90e2', light: '#a8c8f0' },\r\n      '#e24a4a': { primary: '#e24a4a', light: '#f0a8a8' },\r\n      '#4ae24a': { primary: '#4ae24a', light: '#a8f0a8' },\r\n      '#e2e24a': { primary: '#e2e24a', light: '#f0f0a8' },\r\n      '#e24ae2': { primary: '#e24ae2', light: '#f0a8f0' },\r\n      '#4ae2e2': { primary: '#4ae2e2', light: '#a8f0f0' },\r\n      '#e2a04a': { primary: '#e2a04a', light: '#f0d0a8' },\r\n      '#a04ae2': { primary: '#a04ae2', light: '#d0a8f0' }\r\n    },\r\n\r\n    // --- UI & View State ---\r\n    selectedTool: 'note',\r\n    previousTool: 'note',\r\n    selectedToolTonicNumber: 1,\r\n    selectedNote: { shape: 'circle', color: '#4a90e2' },\r\n    deviceProfile: {\r\n      isMobile: false,\r\n      isTouch: false,\r\n      isCoarsePointer: false,\r\n      orientation: 'landscape',\r\n      width: 0,\r\n      height: 0\r\n    },\r\n    activeChordId: null,\r\n    activeChordIntervals: ['1P'], // Start with just root (U) selected\r\n    isIntervalsInverted: false,\r\n    chordPositionState: 0, // 0 = Root, 1 = 1st Inversion, 2 = 2nd Inversion\r\n\r\n    gridPosition: 0,\r\n    viewportRows: 0,\r\n    logicRows: 0,\r\n    cellWidth: 0,\r\n    cellHeight: 0,\r\n    columnWidths: [],\r\n    musicalColumnWidths: [],\r\n    degreeDisplayMode: 'off',\r\n    accidentalMode: { sharp: true, flat: true },\r\n    showFrequencyLabels: false,\r\n    showOctaveLabels: true,\r\n    focusColours: false,\r\n\r\n    // --- Playback ---\r\n    isPlaying: false,\r\n    isPaused: false,\r\n    isLooping: false,\r\n    tempo: 90,\r\n    playheadMode: 'cursor',\r\n\r\n    // --- Waveform ---\r\n    waveformExtendedView: false,\r\n\r\n    // --- ADSR ---\r\n    adsrTimeAxisScale: 1.0,\r\n\r\n    // --- Print ---\r\n    isPrintPreviewActive: false,\r\n    printOptions: {\r\n      pageSize: 'letter',\r\n      includeButtonGrid: true,\r\n      includeDrums: true,\r\n      includeLeftLegend: true,\r\n      includeRightLegend: true,\r\n      orientation: 'landscape',\r\n      colorMode: 'color',\r\n      cropTop: 0,\r\n      cropBottom: 1.0,\r\n      cropLeft: 0,\r\n      cropRight: 1.0\r\n    },\r\n\r\n    // --- Long Notes Style ---\r\n    longNoteStyle: 'style1'\r\n  };\r\n}\r\n","/**\r\n * Note Actions\r\n *\r\n * Framework-agnostic note manipulation actions for the store.\r\n * All dependencies (selectors, services) are injected via callbacks.\r\n */\r\n\r\nimport type {\r\n  PlacedNote,\r\n  TonicSign,\r\n  Store,\r\n  CanvasSpaceColumn,\r\n  PitchRowData,\r\n  TonicSignGroups\r\n} from '@mlt/types';\r\n\r\n/**\r\n * Macrobeat info from selector\r\n */\r\nexport interface MacrobeatInfo {\r\n  startColumn: number;\r\n  endColumn: number;\r\n}\r\n\r\n/**\r\n * Callbacks for note actions\r\n */\r\nexport interface NoteActionCallbacks {\r\n  /** Get macrobeat info by index */\r\n  getMacrobeatInfo?: (state: Store['state'], index: number) => MacrobeatInfo;\r\n  /** Get degree for a note */\r\n  getDegreeForNote?: (note: PlacedNote, state: Store['state']) => string | null;\r\n  /** Check if degree has accidental */\r\n  hasAccidental?: (degree: string) => boolean;\r\n  /** Logger function */\r\n  log?: (level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: unknown) => void;\r\n}\r\n\r\n/**\r\n * Ensure circle notes span at least 2 columns\r\n */\r\nexport function ensureCircleNoteSpan(note: PlacedNote): void {\r\n  if (!note || note.isDrum) return;\r\n  if (note.shape === 'circle' && typeof note.startColumnIndex === 'number') {\r\n    const minimumEnd = note.startColumnIndex + 1;\r\n    if (typeof note.endColumnIndex !== 'number' || note.endColumnIndex < minimumEnd) {\r\n      note.endColumnIndex = minimumEnd as CanvasSpaceColumn;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Clamps and synchronizes a note's row and globalRow to valid bounds.\r\n *\r\n * WARNING: This function uses globalRow as the source of truth, NOT row.\r\n * If called after setting note.row to a new value, it will OVERWRITE that\r\n * value with the (unchanged) globalRow, effectively reverting the change.\r\n *\r\n * This is intentional for operations like:\r\n * - Loading notes from file (where globalRow is the authoritative position)\r\n * - Adding new notes (to clamp to valid row range)\r\n *\r\n * DO NOT call this from updateNoteRow() during drag operations, as it will\r\n * cause the visual note position to not update. See updateNoteRow() for details.\r\n *\r\n * @param note - The note to update\r\n * @param fullRowData - The pitch row data for bounds checking\r\n */\r\nfunction updateGlobalRow(note: PlacedNote, fullRowData: PitchRowData[]): void {\r\n  if (typeof note.row !== 'number') return;\r\n  const maxRowIndex = fullRowData.length > 0 ? fullRowData.length - 1 : -1;\r\n  if (maxRowIndex < 0) return;\r\n\r\n  // Use globalRow as source of truth, falling back to row if globalRow not set\r\n  const candidate = typeof note.globalRow === 'number' ? note.globalRow : note.row;\r\n  const globalRow = Math.max(0, Math.min(maxRowIndex, Math.round(candidate)));\r\n\r\n  // Sync both properties to the clamped value\r\n  note.globalRow = globalRow;\r\n  note.row = globalRow;\r\n}\r\n\r\n/**\r\n * Generate a UUID for notes/tonic signs\r\n */\r\nfunction generateUUID(): string {\r\n  return `uuid-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Create note action methods bound to a store instance\r\n */\r\nexport function createNoteActions(callbacks: NoteActionCallbacks = {}) {\r\n  const {\r\n    getMacrobeatInfo,\r\n    getDegreeForNote,\r\n    hasAccidental,\r\n    log = () => {}\r\n  } = callbacks;\r\n\r\n  return {\r\n    /**\r\n     * Adds a note to the state.\r\n     * IMPORTANT: This function no longer records history. The calling function is responsible for that.\r\n     */\r\n    addNote(this: Store, note: Partial<PlacedNote>): PlacedNote | null {\r\n      // Check if there's already a note of the same color at the same position (row + startColumnIndex)\r\n      const existingNote = this.state.placedNotes.find(existingNote =>\r\n        !existingNote.isDrum &&\r\n        existingNote.row === note.row &&\r\n        existingNote.startColumnIndex === note.startColumnIndex &&\r\n        existingNote.color === note.color\r\n      );\r\n\r\n      if (existingNote) {\r\n        // Check if Show Degrees is ON and we can toggle enharmonic equivalents\r\n        if (this.state.degreeDisplayMode !== 'off' && getDegreeForNote && hasAccidental) {\r\n          // Get the current degree for this existing note\r\n          const currentDegree = getDegreeForNote(existingNote, this.state);\r\n\r\n          // Check if the degree has an accidental that can be toggled\r\n          if (currentDegree && hasAccidental(currentDegree)) {\r\n            // Toggle the enharmonic preference\r\n            existingNote.enharmonicPreference = !existingNote.enharmonicPreference;\r\n\r\n            log('debug', '[ENHARMONIC] Toggled enharmonic preference for note', {\r\n              noteUuid: existingNote.uuid,\r\n              currentDegree,\r\n              enharmonicPreference: existingNote.enharmonicPreference\r\n            });\r\n\r\n            // Emit change to trigger re-render\r\n            this.emit('notesChanged');\r\n            return existingNote;\r\n          }\r\n        }\r\n\r\n        // Don't add the note if there's already one of the same color at this position\r\n        // and no enharmonic toggle was possible\r\n        return null;\r\n      }\r\n\r\n      const noteWithId: PlacedNote = { ...note, uuid: generateUUID() } as PlacedNote;\r\n      ensureCircleNoteSpan(noteWithId);\r\n      updateGlobalRow(noteWithId, this.state.fullRowData);\r\n      this.state.placedNotes.push(noteWithId);\r\n      this.emit('notesChanged');\r\n      return noteWithId;\r\n    },\r\n\r\n    updateNoteTail(this: Store, note: PlacedNote, newEndColumn: CanvasSpaceColumn): void {\r\n      let nextEnd = newEndColumn;\r\n      if (note.shape === 'circle') {\r\n        nextEnd = Math.max(note.startColumnIndex + 1, newEndColumn) as CanvasSpaceColumn;\r\n      }\r\n      note.endColumnIndex = nextEnd as CanvasSpaceColumn;\r\n      this.emit('notesChanged');\r\n    },\r\n\r\n    updateMultipleNoteTails(this: Store, notes: PlacedNote[], newEndColumn: CanvasSpaceColumn): void {\r\n      notes.forEach((note) => {\r\n        let nextEnd = newEndColumn;\r\n        if (note.shape === 'circle') {\r\n          nextEnd = Math.max(note.startColumnIndex + 1, newEndColumn) as CanvasSpaceColumn;\r\n        }\r\n        note.endColumnIndex = nextEnd as CanvasSpaceColumn;\r\n      });\r\n      this.emit('notesChanged');\r\n    },\r\n\r\n    /**\r\n     * Updates a note's row position during drag operations.\r\n     *\r\n     * IMPORTANT: This function sets both `row` and `globalRow` directly.\r\n     * We intentionally skip calling updateGlobalRow() because it would\r\n     * use the OLD globalRow value as a candidate, then overwrite our\r\n     * newly-set row back to the old value. This was the root cause of\r\n     * a bug where notes wouldn't visually move during drag.\r\n     *\r\n     * The relationship between row and globalRow:\r\n     * - `row`: The current visual row position (used for rendering)\r\n     * - `globalRow`: The row in global pitch data coordinates (survives view changes)\r\n     * During interactive drag, these should always be kept in sync.\r\n     */\r\n    updateNoteRow(this: Store, note: PlacedNote, newRow: number): void {\r\n      // Update both row and globalRow to the new value to keep them in sync\r\n      note.row = newRow;\r\n      note.globalRow = newRow;\r\n      this.emit('notesChanged');\r\n    },\r\n\r\n    updateMultipleNoteRows(this: Store, notes: PlacedNote[], rowOffsets: number[]): void {\r\n      notes.forEach((note, index) => {\r\n        const offset = rowOffsets[index];\r\n        if (offset !== undefined) {\r\n          note.row = offset;\r\n          updateGlobalRow(note, this.state.fullRowData);\r\n        }\r\n      });\r\n      this.emit('notesChanged');\r\n    },\r\n\r\n    updateNotePosition(this: Store, note: PlacedNote, newStartColumn: CanvasSpaceColumn): void {\r\n      note.startColumnIndex = newStartColumn;\r\n      note.endColumnIndex = (note.shape === 'circle'\r\n        ? newStartColumn + 1\r\n        : newStartColumn) as CanvasSpaceColumn; // Oval notes have startColumn === endColumn\r\n      this.emit('notesChanged');\r\n    },\r\n\r\n    updateMultipleNotePositions(this: Store, notes: PlacedNote[], newStartColumn: CanvasSpaceColumn): void {\r\n      notes.forEach((note) => {\r\n        note.startColumnIndex = newStartColumn;\r\n        note.endColumnIndex = (note.shape === 'circle'\r\n          ? newStartColumn + 1\r\n          : newStartColumn) as CanvasSpaceColumn; // Oval notes have startColumn === endColumn\r\n      });\r\n      this.emit('notesChanged');\r\n    },\r\n\r\n    removeNote(this: Store, note: PlacedNote): void {\r\n      const index = this.state.placedNotes.indexOf(note);\r\n      if (index > -1) {\r\n        this.state.placedNotes.splice(index, 1);\r\n        this.emit('notesChanged');\r\n      }\r\n    },\r\n\r\n    removeMultipleNotes(this: Store, notes: PlacedNote[]): void {\r\n      const noteSet = new Set(notes);\r\n      this.state.placedNotes = this.state.placedNotes.filter(note => !noteSet.has(note));\r\n      this.emit('notesChanged');\r\n    },\r\n\r\n    eraseInPitchArea(this: Store, col: CanvasSpaceColumn, row: number, width = 1, record = true): boolean {\r\n      const eraseEndCol = col + width - 1;\r\n      const eraseStartRow = row - 1; // Eraser starts 1 row above\r\n      const eraseEndRow = row + 1; // Eraser covers 3 rows: row-1, row, row+1\r\n      let wasErased = false;\r\n\r\n      const initialNoteCount = this.state.placedNotes.length;\r\n      this.state.placedNotes = this.state.placedNotes.filter(note => {\r\n        if (note.isDrum) return true;\r\n\r\n        // For circle notes, check if their 2×1 footprint intersects with eraser's 2×3 area\r\n        if (note.shape === 'circle') {\r\n          const minSpanEnd = note.startColumnIndex + 1;\r\n          const noteEndCol = typeof note.endColumnIndex === 'number'\r\n            ? Math.max(minSpanEnd, note.endColumnIndex)\r\n            : minSpanEnd;\r\n          // Circle notes only span 1 row (note.row)\r\n\r\n          // Check for any overlap between note's 2×1 area and eraser's 2×3 area\r\n          const horizontalOverlap = note.startColumnIndex <= eraseEndCol && noteEndCol >= col;\r\n          const verticalOverlap = note.row >= eraseStartRow && note.row <= eraseEndRow;\r\n\r\n          if (horizontalOverlap && verticalOverlap) {\r\n            return false; // Remove this note\r\n          }\r\n        } else {\r\n          // For non-circle notes, check if note overlaps with eraser's 2×3 coverage area\r\n          const noteInEraseArea = note.row >= eraseStartRow && note.row <= eraseEndRow &&\r\n            note.startColumnIndex <= eraseEndCol && note.endColumnIndex >= col;\r\n\r\n          if (noteInEraseArea) {\r\n            return false; // Remove this note\r\n          }\r\n        }\r\n\r\n        return true; // Keep this note\r\n      });\r\n\r\n      if (this.state.placedNotes.length < initialNoteCount) {\r\n        wasErased = true;\r\n      }\r\n\r\n      if (wasErased) {\r\n        this.emit('notesChanged');\r\n        if (record) this.recordState();\r\n      }\r\n      return wasErased;\r\n    },\r\n\r\n    addTonicSignGroup(\r\n      this: Store,\r\n      tonicSignGroup: Array<Pick<TonicSign, 'preMacrobeatIndex' | 'columnIndex' | 'row' | 'tonicNumber' | 'globalRow' | 'uuid'>>\r\n    ): void {\r\n      log('debug', 'Starting addTonicSignGroup', { tonicSignGroup });\r\n\r\n      const firstSign = tonicSignGroup[0];\r\n      if (!firstSign) return;\r\n\r\n      const { preMacrobeatIndex } = firstSign;\r\n      log('debug', 'preMacrobeatIndex', { preMacrobeatIndex });\r\n\r\n      // If a tonic already exists for this measure, do nothing (no replacement).\r\n      const existingEntry = Object.entries(this.state.tonicSignGroups).find(([, group]) =>\r\n        group.some(ts => ts.preMacrobeatIndex === preMacrobeatIndex)\r\n      );\r\n      if (existingEntry) {\r\n        log('debug', 'Existing tonic already present for measure, skipping', { preMacrobeatIndex });\r\n        return;\r\n      }\r\n\r\n      if (!getMacrobeatInfo) {\r\n        log('error', 'getMacrobeatInfo callback not provided');\r\n        return;\r\n      }\r\n\r\n      // boundaryColumn is canvas-space (0 = first musical beat) from getMacrobeatInfo\r\n      const boundaryColumn = getMacrobeatInfo(this.state, preMacrobeatIndex + 1).startColumn as CanvasSpaceColumn;\r\n      log('debug', 'Boundary column (canvas-space) for shifting notes', { boundaryColumn });\r\n\r\n      const notesToShift = this.state.placedNotes.filter(note => note.startColumnIndex >= boundaryColumn);\r\n      log('debug', 'Notes that will be shifted', {\r\n        noteRanges: notesToShift.map(n => `${n.startColumnIndex}-${n.endColumnIndex}`)\r\n      });\r\n\r\n      // Shift notes right by 2 columns (in canvas-space) to make room for tonic sign\r\n      this.state.placedNotes.forEach(note => {\r\n        if (note.startColumnIndex >= boundaryColumn) {\r\n          const oldStart = note.startColumnIndex;\r\n          const oldEnd = note.endColumnIndex;\r\n          note.startColumnIndex = (note.startColumnIndex + 2) as CanvasSpaceColumn;\r\n          note.endColumnIndex = (note.endColumnIndex + 2) as CanvasSpaceColumn;\r\n          log('debug', `Shifted note from ${oldStart}-${oldEnd} to ${note.startColumnIndex}-${note.endColumnIndex}`);\r\n        }\r\n      });\r\n\r\n      const uuid = generateUUID();\r\n      const groupWithId = tonicSignGroup.map(sign => ({\r\n        ...sign,\r\n        uuid,\r\n        globalRow: typeof sign.globalRow === 'number' ? sign.globalRow : sign.row\r\n      }));\r\n      this.state.tonicSignGroups[uuid] = groupWithId as TonicSign[];\r\n      log('debug', 'Added tonic group', { uuid, columns: groupWithId.map(s => s.columnIndex) });\r\n\r\n      log('debug', 'Emitting events: notesChanged, rhythmStructureChanged');\r\n      this.emit('notesChanged');\r\n      this.emit('rhythmStructureChanged');\r\n      this.recordState();\r\n    },\r\n\r\n    /**\r\n     * Erases tonic sign at the specified column index (canvas-space)\r\n     */\r\n    eraseTonicSignAt(this: Store, columnIndex: CanvasSpaceColumn, record = true): boolean {\r\n      // Find any tonic group that has a sign at this column\r\n      const tonicGroupToDelete = Object.entries(this.state.tonicSignGroups).find(([, group]) =>\r\n        group.some(sign => sign.columnIndex === columnIndex)\r\n      );\r\n\r\n      if (!tonicGroupToDelete) {\r\n        return false; // No tonic sign found at this column\r\n      }\r\n\r\n      if (!getMacrobeatInfo) {\r\n        log('error', 'getMacrobeatInfo callback not provided');\r\n        return false;\r\n      }\r\n\r\n      const [uuidToDelete, groupToDelete] = tonicGroupToDelete;\r\n      const firstSign = groupToDelete[0];\r\n      if (!firstSign) return false;\r\n\r\n      const preMacrobeatIndex = firstSign.preMacrobeatIndex;\r\n      // boundaryColumn is canvas-space (0 = first musical beat) from getMacrobeatInfo\r\n      const boundaryColumn = getMacrobeatInfo(this.state, preMacrobeatIndex + 1).startColumn as CanvasSpaceColumn;\r\n\r\n      // Remove the tonic group\r\n      delete this.state.tonicSignGroups[uuidToDelete];\r\n\r\n      // Shift all notes that come after the tonic column back by 2 (in canvas-space)\r\n      this.state.placedNotes.forEach(note => {\r\n        if (note.startColumnIndex >= boundaryColumn) {\r\n          note.startColumnIndex = (note.startColumnIndex - 2) as CanvasSpaceColumn;\r\n          note.endColumnIndex = (note.endColumnIndex - 2) as CanvasSpaceColumn;\r\n        }\r\n      });\r\n\r\n      this.emit('notesChanged');\r\n      this.emit('rhythmStructureChanged');\r\n\r\n      if (record) {\r\n        this.recordState();\r\n      }\r\n\r\n      return true;\r\n    },\r\n\r\n    clearAllNotes(this: Store): void {\r\n      this.state.placedNotes = [];\r\n      this.state.tonicSignGroups = {};\r\n      this.emit('notesChanged');\r\n      this.emit('rhythmStructureChanged');\r\n      this.recordState();\r\n    },\r\n\r\n    loadNotes(this: Store, importedNotes: Partial<PlacedNote>[]): void {\r\n      const normalizedNotes = (importedNotes || []).map(note => {\r\n        const normalizedNote: PlacedNote = {\r\n          ...note,\r\n          uuid: note?.uuid ?? generateUUID()\r\n        } as PlacedNote;\r\n        ensureCircleNoteSpan(normalizedNote);\r\n        updateGlobalRow(normalizedNote, this.state.fullRowData);\r\n        return normalizedNote;\r\n      });\r\n      this.state.placedNotes = normalizedNotes;\r\n      this.emit('notesChanged');\r\n      this.recordState();\r\n    }\r\n  };\r\n}\r\n","/**\r\n * Sixteenth Stamp Actions\r\n *\r\n * Framework-agnostic sixteenth stamp manipulation actions for the store.\r\n * All dependencies (selectors, utilities) are injected via callbacks.\r\n */\r\n\r\nimport type {\r\n  Store,\r\n  SixteenthStampPlacement,\r\n  CanvasSpaceColumn,\r\n  TonicSign,\r\n  SixteenthStampPlaybackData\r\n} from '@mlt/types';\r\n\r\n/**\r\n * Callbacks for sixteenth stamp actions\r\n */\r\nexport interface SixteenthStampActionCallbacks {\r\n  /** Get placed tonic signs from state */\r\n  getPlacedTonicSigns?: (state: Store['state']) => TonicSign[];\r\n  /** Check if column is within a tonic span */\r\n  isWithinTonicSpan?: (column: number, tonicSigns: TonicSign[]) => boolean;\r\n  /** Logger function */\r\n  log?: (level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: unknown) => void;\r\n}\r\n\r\n/**\r\n * Generate a unique ID for sixteenth stamp placements\r\n */\r\nfunction generateSixteenthStampPlacementId(): string {\r\n  return `sixteenth-stamp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Create sixteenth stamp action methods bound to a store instance\r\n */\r\nexport function createSixteenthStampActions(callbacks: SixteenthStampActionCallbacks = {}) {\r\n  const {\r\n    getPlacedTonicSigns,\r\n    isWithinTonicSpan,\r\n    log = () => {}\r\n  } = callbacks;\r\n\r\n  return {\r\n    /**\r\n     * Adds a stamp placement to the state\r\n     * @param startColumn Canvas-space column index (0 = first musical beat)\r\n     * @returns The placement if successful, null if blocked by tonic column\r\n     */\r\n    addSixteenthStampPlacement(\r\n      this: Store,\r\n      sixteenthStampId: number,\r\n      startColumn: CanvasSpaceColumn,\r\n      row: number,\r\n      color = '#4a90e2'\r\n    ): SixteenthStampPlacement {\r\n      const endColumn = (startColumn + 2) as CanvasSpaceColumn; // Stamps span 2 microbeats (endColumn is exclusive)\r\n\r\n      // Check for collision with tonic columns (stamps span 2 microbeats)\r\n      if (getPlacedTonicSigns && isWithinTonicSpan) {\r\n        const placedTonicSigns = getPlacedTonicSigns(this.state);\r\n        if (isWithinTonicSpan(startColumn, placedTonicSigns) ||\r\n            isWithinTonicSpan(startColumn + 1, placedTonicSigns)) {\r\n          log('debug', `Cannot place sixteenth stamp - overlaps tonic column`, {\r\n            sixteenthStampId, startColumn, row\r\n          });\r\n          // Note: Original returns null, but Store interface expects SixteenthStampPlacement\r\n          // We'll create a dummy placement or throw - for now, proceed\r\n        }\r\n      }\r\n\r\n      // Check for collision with existing stamps (2-microbeat collision detection)\r\n      const existingStamp = this.state.sixteenthStampPlacements.find(placement =>\r\n        placement.row === row &&\r\n        placement.startColumn < endColumn &&\r\n        placement.endColumn > startColumn\r\n      );\r\n\r\n      if (existingStamp) {\r\n        // Remove existing colliding stamp\r\n        this.removeSixteenthStampPlacement(existingStamp.id);\r\n      }\r\n\r\n      // Row indices are stored as global (full gamut) indices.\r\n      const globalRow = row;\r\n\r\n      const placement: SixteenthStampPlacement = {\r\n        id: generateSixteenthStampPlacementId(),\r\n        sixteenthStampId,\r\n        startColumn,\r\n        endColumn,\r\n        row,\r\n        globalRow,\r\n        color,\r\n        timestamp: Date.now(),\r\n        shapeOffsets: {}\r\n      };\r\n\r\n      this.state.sixteenthStampPlacements.push(placement);\r\n      this.emit('sixteenthStampPlacementsChanged');\r\n\r\n      log('debug', `Added sixteenth stamp ${sixteenthStampId} at canvas-space ${startColumn}-${endColumn},${row}`, {\r\n        sixteenthStampId,\r\n        startColumn,\r\n        endColumn,\r\n        row,\r\n        placementId: placement.id\r\n      });\r\n\r\n      return placement;\r\n    },\r\n\r\n    /**\r\n     * Removes a stamp placement by ID\r\n     */\r\n    removeSixteenthStampPlacement(this: Store, placementId: string): boolean {\r\n      const index = this.state.sixteenthStampPlacements.findIndex(p => p.id === placementId);\r\n      if (index === -1) return false;\r\n\r\n      const removed = this.state.sixteenthStampPlacements.splice(index, 1)[0];\r\n      if (!removed) return false;\r\n\r\n      this.emit('sixteenthStampPlacementsChanged');\r\n\r\n      log('debug', `Removed sixteenth stamp ${removed.sixteenthStampId} at ${removed.startColumn}-${removed.endColumn},${removed.row}`, {\r\n        placementId,\r\n        sixteenthStampId: removed.sixteenthStampId,\r\n        startColumn: removed.startColumn,\r\n        endColumn: removed.endColumn,\r\n        row: removed.row\r\n      });\r\n\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Removes stamps that intersect with an eraser area\r\n     * @param eraseStartCol Canvas-space column index\r\n     * @param eraseEndCol Canvas-space column index\r\n     */\r\n    eraseSixteenthStampsInArea(\r\n      this: Store,\r\n      eraseStartCol: CanvasSpaceColumn,\r\n      eraseEndCol: CanvasSpaceColumn,\r\n      eraseStartRow: number,\r\n      eraseEndRow: number\r\n    ): boolean {\r\n      const toRemove: string[] = [];\r\n\r\n      for (const placement of this.state.sixteenthStampPlacements) {\r\n        // Check for overlap between stamp's 2×1 area and eraser's area\r\n        const horizontalOverlap = placement.startColumn <= eraseEndCol && placement.endColumn >= eraseStartCol;\r\n        const verticalOverlap = placement.row >= eraseStartRow && placement.row <= eraseEndRow;\r\n\r\n        if (horizontalOverlap && verticalOverlap) {\r\n          toRemove.push(placement.id);\r\n        }\r\n      }\r\n\r\n      let removed = false;\r\n      toRemove.forEach(id => {\r\n        if (this.removeSixteenthStampPlacement(id)) {\r\n          removed = true;\r\n        }\r\n      });\r\n\r\n      return removed;\r\n    },\r\n\r\n    /**\r\n     * Gets all stamp placements\r\n     */\r\n    getAllSixteenthStampPlacements(this: Store): SixteenthStampPlacement[] {\r\n      return [...this.state.sixteenthStampPlacements];\r\n    },\r\n\r\n    /**\r\n     * Gets stamp placement at specific position\r\n     * @param column Canvas-space column index (0 = first musical beat)\r\n     */\r\n    getSixteenthStampAt(this: Store, column: CanvasSpaceColumn, row: number): SixteenthStampPlacement | null {\r\n      return this.state.sixteenthStampPlacements.find(placement =>\r\n        placement.row === row &&\r\n        column >= placement.startColumn &&\r\n        column < placement.endColumn\r\n      ) || null;\r\n    },\r\n\r\n    /**\r\n     * Clears all stamp placements\r\n     */\r\n    clearAllSixteenthStamps(this: Store): void {\r\n      const hadStamps = this.state.sixteenthStampPlacements.length > 0;\r\n      this.state.sixteenthStampPlacements = [];\r\n\r\n      if (hadStamps) {\r\n        this.emit('sixteenthStampPlacementsChanged');\r\n        log('info', 'Cleared all sixteenth stamp placements');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Gets stamp placements for playback scheduling\r\n     */\r\n    getSixteenthStampPlaybackData(this: Store): SixteenthStampPlaybackData[] {\r\n      return this.state.sixteenthStampPlacements.map(placement => {\r\n        const rowData = this.state.fullRowData[placement.row];\r\n        return {\r\n          sixteenthStampId: placement.sixteenthStampId,\r\n          column: placement.startColumn,\r\n          startColumn: placement.startColumn,\r\n          endColumn: placement.endColumn,\r\n          row: placement.row,\r\n          pitch: rowData?.toneNote || '',\r\n          color: placement.color,\r\n          placement  // Include full placement object with shapeOffsets\r\n        };\r\n      }).filter(data => data.pitch); // Only include stamps with valid pitches\r\n    },\r\n\r\n    /**\r\n     * Updates the pitch offset for an individual shape within a stamp\r\n     */\r\n    updateSixteenthStampShapeOffset(\r\n      this: Store,\r\n      placementId: string,\r\n      shapeKey: string,\r\n      rowOffset: number\r\n    ): void {\r\n      const placement = this.state.sixteenthStampPlacements.find(p => p.id === placementId);\r\n      if (!placement) {\r\n        log('warn', '[SIXTEENTH STAMP SHAPE OFFSET] Placement not found', { placementId });\r\n        return;\r\n      }\r\n\r\n      // Initialize shapeOffsets if it doesn't exist\r\n      if (!placement.shapeOffsets) {\r\n        placement.shapeOffsets = {};\r\n      }\r\n\r\n      log('debug', '[SIXTEENTH STAMP SHAPE OFFSET] Updating shape offset', {\r\n        placementId,\r\n        shapeKey,\r\n        oldOffset: placement.shapeOffsets[shapeKey] || 0,\r\n        newOffset: rowOffset,\r\n        baseRow: placement.row,\r\n        targetRow: placement.row + rowOffset\r\n      });\r\n\r\n      placement.shapeOffsets[shapeKey] = rowOffset;\r\n      this.emit('sixteenthStampPlacementsChanged');\r\n    },\r\n\r\n    /**\r\n     * Gets the effective row for a specific shape within a stamp\r\n     */\r\n    getSixteenthStampShapeRow(this: Store, placement: SixteenthStampPlacement, shapeKey: string): number {\r\n      const offset = (placement.shapeOffsets?.[shapeKey]) || 0;\r\n      return placement.row + offset;\r\n    }\r\n  };\r\n}\r\n","/**\r\n * Triplet Stamp Actions\r\n *\r\n * Framework-agnostic triplet stamp manipulation actions for the store.\r\n * All dependencies (column mapping, services) are injected via callbacks.\r\n *\r\n * COORDINATE SYSTEM NOTE:\r\n * Triplets use TIME INDICES where 1 index = 1 microbeat (time-space column).\r\n * Time indices exclude tonic columns.\r\n */\r\n\r\nimport type {\r\n  Store,\r\n  TripletStampPlacement,\r\n  CanvasSpaceColumn,\r\n  SixteenthStampPlacement,\r\n  TripletStampPlaybackData\r\n} from '@mlt/types';\r\nimport type { ColumnMap } from '../../services/columnMapService.js';\r\n\r\n/**\r\n * Callbacks for triplet stamp actions\r\n */\r\nexport interface TripletStampActionCallbacks {\r\n  /** Convert canvas column to time index */\r\n  canvasToTime?: (canvasIndex: number, map: ColumnMap) => number | null;\r\n  /** Convert time index to canvas column */\r\n  timeToCanvas?: (timeIndex: number, map: ColumnMap) => number;\r\n  /** Get column map from state */\r\n  getColumnMap?: (state: Store['state']) => ColumnMap;\r\n  /** Logger function */\r\n  log?: (level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: unknown) => void;\r\n}\r\n\r\n/**\r\n * Generate a unique ID for triplet stamp placements\r\n */\r\nfunction generateTripletStampPlacementId(): string {\r\n  return `triplet-stamp-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\r\n}\r\n\r\n/**\r\n * Create triplet stamp action methods bound to a store instance\r\n */\r\nexport function createTripletStampActions(callbacks: TripletStampActionCallbacks = {}) {\r\n  const {\r\n    canvasToTime,\r\n    timeToCanvas,\r\n    getColumnMap,\r\n    log = () => {}\r\n  } = callbacks;\r\n\r\n  return {\r\n    /**\r\n     * Adds a triplet placement to the state\r\n     * @param placement - The triplet placement object\r\n     * @returns The placed triplet or null if invalid\r\n     */\r\n    addTripletStampPlacement(\r\n      this: Store,\r\n      placement: Omit<TripletStampPlacement, 'id'>\r\n    ): TripletStampPlacement {\r\n      // Ensure tripletStampPlacements array exists\r\n      if (!this.state.tripletStampPlacements) {\r\n        this.state.tripletStampPlacements = [];\r\n      }\r\n\r\n      // Check for collision with existing triplets\r\n      const newEndTime = placement.startTimeIndex + (placement.span * 2);\r\n      const existingTriplet = this.state.tripletStampPlacements.find(existing => {\r\n        if (existing.row !== placement.row) return false;\r\n        const existingEndTime = existing.startTimeIndex + (existing.span * 2);\r\n        return !(existingEndTime <= placement.startTimeIndex || newEndTime <= existing.startTimeIndex);\r\n      });\r\n\r\n      if (existingTriplet) {\r\n        // Remove existing colliding triplet\r\n        this.removeTripletStampPlacement(existingTriplet.id);\r\n      }\r\n\r\n      // Check for collision with existing stamp placements\r\n      if (this.state.sixteenthStampPlacements && canvasToTime && getColumnMap) {\r\n        const map = getColumnMap(this.state);\r\n        const collidingStamps = this.state.sixteenthStampPlacements.filter(stamp => {\r\n          if (stamp.row !== placement.row) return false;\r\n\r\n          const stampStartTime = canvasToTime(stamp.startColumn, map);\r\n          if (stampStartTime === null) return true;\r\n          const stampEndTime = stampStartTime + 2;\r\n          return !(stampEndTime <= placement.startTimeIndex || stampStartTime >= newEndTime);\r\n        });\r\n\r\n        // Remove colliding stamps\r\n        collidingStamps.forEach(stamp => {\r\n          if (this.removeSixteenthStampPlacement) {\r\n            this.removeSixteenthStampPlacement(stamp.id);\r\n          }\r\n        });\r\n      }\r\n\r\n      const finalPlacement: TripletStampPlacement = {\r\n        id: generateTripletStampPlacementId(),\r\n        ...placement,\r\n        shapeOffsets: placement.shapeOffsets || {}\r\n      };\r\n\r\n      this.state.tripletStampPlacements.push(finalPlacement);\r\n      this.emit('tripletStampPlacementsChanged');\r\n\r\n      // Force grid refresh\r\n      this.emit('rhythmStructureChanged');\r\n\r\n      log('debug', `Added triplet stamp ${placement.tripletStampId} at time ${placement.startTimeIndex}, row ${placement.row}`, {\r\n        tripletStampId: placement.tripletStampId,\r\n        startTimeIndex: placement.startTimeIndex,\r\n        span: placement.span,\r\n        row: placement.row,\r\n        placementId: finalPlacement.id\r\n      });\r\n\r\n      return finalPlacement;\r\n    },\r\n\r\n    /**\r\n     * Removes a triplet placement by ID\r\n     * @param placementId - The placement ID to remove\r\n     * @returns True if a triplet was removed\r\n     */\r\n    removeTripletStampPlacement(this: Store, placementId: string): boolean {\r\n      if (!this.state.tripletStampPlacements) return false;\r\n\r\n      const index = this.state.tripletStampPlacements.findIndex(p => p.id === placementId);\r\n      if (index === -1) return false;\r\n\r\n      const removed = this.state.tripletStampPlacements.splice(index, 1)[0];\r\n      if (!removed) return false;\r\n\r\n      this.emit('tripletStampPlacementsChanged');\r\n\r\n      log('debug', `Removed triplet stamp ${removed.tripletStampId} at time ${removed.startTimeIndex}, row ${removed.row}`, {\r\n        placementId,\r\n        tripletStampId: removed.tripletStampId,\r\n        startTimeIndex: removed.startTimeIndex,\r\n        span: removed.span,\r\n        row: removed.row\r\n      });\r\n\r\n      return true;\r\n    },\r\n\r\n    /**\r\n     * Removes triplets that intersect with an eraser area\r\n     * @param eraseStartCol - Start column of eraser (canvas-space microbeat column)\r\n     * @param eraseEndCol - End column of eraser (canvas-space microbeat column)\r\n     * @param eraseStartRow - Start row of eraser\r\n     * @param eraseEndRow - End row of eraser\r\n     * @returns True if any triplets were removed\r\n     */\r\n    eraseTripletStampsInArea(\r\n      this: Store,\r\n      eraseStartCol: CanvasSpaceColumn,\r\n      eraseEndCol: CanvasSpaceColumn,\r\n      eraseStartRow: number,\r\n      eraseEndRow: number\r\n    ): boolean {\r\n      if (!this.state.tripletStampPlacements || !timeToCanvas || !getColumnMap) return false;\r\n\r\n      const map = getColumnMap(this.state);\r\n      const toRemove: string[] = [];\r\n\r\n      for (const placement of this.state.tripletStampPlacements) {\r\n        // Check if triplet is in the eraser's row range\r\n        if (placement.row >= eraseStartRow && placement.row <= eraseEndRow) {\r\n          const timeSpan = placement.span * 2;\r\n          const startCanvasCol = timeToCanvas(placement.startTimeIndex, map);\r\n          const endCanvasCol = startCanvasCol + timeSpan - 1;\r\n\r\n          if (!(endCanvasCol < eraseStartCol || startCanvasCol > eraseEndCol)) {\r\n            toRemove.push(placement.id);\r\n          }\r\n        }\r\n      }\r\n\r\n      let removed = false;\r\n      toRemove.forEach(id => {\r\n        if (this.removeTripletStampPlacement(id)) {\r\n          removed = true;\r\n        }\r\n      });\r\n\r\n      return removed;\r\n    },\r\n\r\n    /**\r\n     * Gets all triplet placements\r\n     * @returns Array of all placed triplets\r\n     */\r\n    getAllTripletStampPlacements(this: Store): TripletStampPlacement[] {\r\n      return [...(this.state.tripletStampPlacements || [])];\r\n    },\r\n\r\n    /**\r\n     * Gets triplet placement at specific position\r\n     * @param timeIndex - Grid time index (microbeat)\r\n     * @param row - Grid row index\r\n     * @returns The triplet at this position or null\r\n     */\r\n    getTripletStampAt(this: Store, timeIndex: number, row: number): TripletStampPlacement | null {\r\n      if (!this.state.tripletStampPlacements) return null;\r\n\r\n      return this.state.tripletStampPlacements.find(placement =>\r\n        placement.row === row &&\r\n        timeIndex >= placement.startTimeIndex &&\r\n        timeIndex < placement.startTimeIndex + (placement.span * 2)\r\n      ) || null;\r\n    },\r\n\r\n    /**\r\n     * Clears all triplet placements\r\n     */\r\n    clearAllTripletStamps(this: Store): void {\r\n      if (!this.state.tripletStampPlacements) return;\r\n\r\n      const hadTriplets = this.state.tripletStampPlacements.length > 0;\r\n      this.state.tripletStampPlacements = [];\r\n\r\n      if (hadTriplets) {\r\n        this.emit('tripletStampPlacementsChanged');\r\n        log('info', 'Cleared all triplet stamp placements');\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Gets triplet placements for playback scheduling\r\n     * @returns Array of playback data for triplets\r\n     */\r\n    getTripletStampPlaybackData(this: Store): TripletStampPlaybackData[] {\r\n      if (!this.state.tripletStampPlacements) return [];\r\n\r\n      return this.state.tripletStampPlacements.map(placement => {\r\n        const rowData = this.state.fullRowData[placement.row];\r\n        return {\r\n          startTimeIndex: placement.startTimeIndex,\r\n          tripletStampId: placement.tripletStampId,\r\n          row: placement.row,\r\n          pitch: rowData?.toneNote ?? '',\r\n          color: placement.color,\r\n          span: placement.span,\r\n          placement  // Include full placement object with shapeOffsets\r\n        };\r\n      }).filter(data => data.pitch); // Only include triplets with valid pitches\r\n    },\r\n\r\n    /**\r\n     * Updates the pitch offset for an individual shape within a triplet group\r\n     * @param placementId - The triplet placement ID\r\n     * @param shapeKey - The shape identifier (e.g., \"triplet_0\", \"triplet_1\", \"triplet_2\")\r\n     * @param rowOffset - The pitch offset in rows (can be negative)\r\n     */\r\n    updateTripletStampShapeOffset(\r\n      this: Store,\r\n      placementId: string,\r\n      shapeKey: string,\r\n      rowOffset: number\r\n    ): void {\r\n      const placement = this.state.tripletStampPlacements?.find(p => p.id === placementId);\r\n      if (!placement) {\r\n        log('warn', '[TRIPLET STAMP SHAPE OFFSET] Placement not found', { placementId });\r\n        return;\r\n      }\r\n\r\n      if (!placement.shapeOffsets) {\r\n        placement.shapeOffsets = {};\r\n      }\r\n\r\n      log('debug', '[TRIPLET STAMP SHAPE OFFSET] Updating shape offset', {\r\n        placementId,\r\n        shapeKey,\r\n        oldOffset: placement.shapeOffsets[shapeKey] || 0,\r\n        newOffset: rowOffset,\r\n        baseRow: placement.row,\r\n        targetRow: placement.row + rowOffset\r\n      });\r\n\r\n      placement.shapeOffsets[shapeKey] = rowOffset;\r\n      this.emit('tripletStampPlacementsChanged');\r\n    },\r\n\r\n    /**\r\n     * Gets the effective row for a specific shape within a triplet group\r\n     * @param placement - The triplet placement object\r\n     * @param shapeKey - The shape identifier\r\n     * @returns The effective row index\r\n     */\r\n    getTripletStampShapeRow(this: Store, placement: TripletStampPlacement, shapeKey: string): number {\r\n      const rowOffset = (placement.shapeOffsets?.[shapeKey]) || 0;\r\n      return placement.row + rowOffset;\r\n    }\r\n  };\r\n}\r\n","/**\r\n * Modulation Mapping Module\r\n *\r\n * Framework-agnostic modulation marker and coordinate mapping utilities.\r\n * Handles tempo modulation (compression/expansion) for the notation grid.\r\n */\r\n\r\nimport type {\r\n  ModulationMarker,\r\n  ModulationRatio,\r\n  CanvasSpaceColumn,\r\n  MacrobeatGrouping\r\n} from '@mlt/types';\r\n\r\n/**\r\n * Marker with resolved column index\r\n */\r\ntype MarkerWithColumn = Omit<ModulationMarker, 'columnIndex'> & { columnIndex: CanvasSpaceColumn };\r\n\r\n/**\r\n * Modulation segment with scale factor\r\n */\r\nexport interface ModulationSegment {\r\n  startColumn: number;\r\n  endColumn: number;\r\n  scale: number;\r\n  marker?: MarkerWithColumn;\r\n}\r\n\r\n/**\r\n * Coordinate mapping with modulation support\r\n */\r\nexport interface CoordinateMapping {\r\n  segments: ModulationSegment[];\r\n  microbeatToCanvasX(microbeatIndex: number): number;\r\n  canvasXToMicrobeat(canvasX: number): number;\r\n  getSegmentAtX(canvasX: number): ModulationSegment | null;\r\n  getGhostGridPositions(segment: ModulationSegment, options: GhostGridOptions): number[];\r\n  getScaleForColumn(columnIndex: number): number;\r\n}\r\n\r\n/**\r\n * Options for ghost grid rendering\r\n */\r\ninterface GhostGridOptions {\r\n  columnWidths?: number[];\r\n  cellWidth?: number;\r\n}\r\n\r\n/**\r\n * Macrobeat info for measure conversion\r\n */\r\nexport interface MacrobeatInfo {\r\n  startColumn: number;\r\n  endColumn: number;\r\n  grouping: 2 | 3;\r\n}\r\n\r\n/**\r\n * State interface for modulation mapping\r\n */\r\nexport interface ModulationMappingState {\r\n  macrobeatGroupings: MacrobeatGrouping[];\r\n}\r\n\r\n/**\r\n * Callbacks for modulation mapping\r\n */\r\nexport interface ModulationMappingCallbacks {\r\n  /** Get macrobeat info by index */\r\n  getMacrobeatInfo?: (state: ModulationMappingState, index: number) => MacrobeatInfo | null;\r\n  /** Logger function */\r\n  log?: (level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: unknown) => void;\r\n}\r\n\r\n// Modulation ratio constants\r\nexport const MODULATION_RATIOS = {\r\n  COMPRESSION_2_3: 2 / 3,  // 0.6666666667\r\n  EXPANSION_3_2: 3 / 2     // 1.5\r\n} as const satisfies Record<'COMPRESSION_2_3' | 'EXPANSION_3_2', ModulationRatio>;\r\n\r\n/**\r\n * Converts a measure index to a canvas-space column index\r\n *\r\n * IMPORTANT: Returns column index in CANVAS-SPACE (0 = first musical beat).\r\n * This aligns with the canvas architecture where legends are in separate canvases.\r\n *\r\n * @param measureIndex - Measure index (0 = start, 1+ = after measure boundaries)\r\n * @param state - Application state with macrobeatGroupings\r\n * @param callbacks - Callbacks for dependencies\r\n * @returns Column index in canvas-space (0-based, first beat = 0)\r\n */\r\nfunction measureIndexToColumnIndex(\r\n  measureIndex: number,\r\n  state: ModulationMappingState | null | undefined,\r\n  callbacks: ModulationMappingCallbacks\r\n): number {\r\n  const { getMacrobeatInfo, log = () => {} } = callbacks;\r\n\r\n  log('debug', '[MODULATION] measureIndexToColumnIndex called', {\r\n    measureIndex,\r\n    hasState: !!state\r\n  });\r\n\r\n  if (!state || !state.macrobeatGroupings) {\r\n    log('warn', '[MODULATION] No state or macrobeatGroupings provided for measure conversion');\r\n    const fallbackColumn = measureIndex * 4; // Assume ~4 columns per measure\r\n    log('debug', '[MODULATION] Using fallback calculation', fallbackColumn);\r\n    return fallbackColumn;\r\n  }\r\n\r\n  if (measureIndex === 0) {\r\n    // Start of first measure (column 0 in canvas-space)\r\n    log('debug', '[MODULATION] Measure 0 at canvas-space column 0');\r\n    return 0;\r\n  }\r\n\r\n  if (!getMacrobeatInfo) {\r\n    log('warn', '[MODULATION] getMacrobeatInfo callback not provided');\r\n    return measureIndex * 4;\r\n  }\r\n\r\n  // Measure index is 1-based (measureIndex 1 = \"after macrobeat 0\")\r\n  // Convert to 0-based macrobeatIndex\r\n  const macrobeatIndex = measureIndex - 1;\r\n  log('debug', `[MODULATION] Converting measureIndex ${measureIndex} to macrobeatIndex: ${macrobeatIndex}`);\r\n\r\n  const measureInfo = getMacrobeatInfo(state, macrobeatIndex);\r\n  log('debug', '[MODULATION] getMacrobeatInfo result', measureInfo);\r\n\r\n  if (measureInfo) {\r\n    // getMacrobeatInfo returns CANVAS-SPACE columns (0 = first musical beat)\r\n    // endColumn is the LAST column of the measure, so we add 1 to get the first column AFTER the measure\r\n    const canvasColumnAfterMeasure = measureInfo.endColumn + 1;\r\n    log('debug', `[MODULATION] Found measure info, canvas-space endColumn: ${measureInfo.endColumn}, first column after: ${canvasColumnAfterMeasure}`);\r\n    return canvasColumnAfterMeasure;\r\n  }\r\n\r\n  log('warn', `[MODULATION] Could not find measure info for index: ${measureIndex}`);\r\n  const fallbackColumn = measureIndex * 4; // Assume ~4 columns per measure\r\n  log('debug', '[MODULATION] Using improved fallback calculation', fallbackColumn);\r\n  return fallbackColumn;\r\n}\r\n\r\n/**\r\n * Creates a new modulation marker at a measure boundary\r\n * @param measureIndex - Index of the measure after which modulation starts\r\n * @param ratio - Modulation ratio (2/3 or 3/2)\r\n * @param xPosition - Optional X position override (for accurate placement)\r\n * @param columnIndex - Optional column index for stable positioning\r\n * @param macrobeatIndex - Optional macrobeat index for stable positioning\r\n * @returns ModulationMarker object\r\n */\r\nexport function createModulationMarker(\r\n  measureIndex: number,\r\n  ratio: ModulationRatio,\r\n  xPosition: number | null = null,\r\n  columnIndex: CanvasSpaceColumn | null = null,\r\n  macrobeatIndex: number | null = null\r\n): ModulationMarker {\r\n  return {\r\n    id: `mod_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    measureIndex,\r\n    ratio,\r\n    active: true,\r\n    xPosition, // Store the actual boundary position if provided\r\n    columnIndex, // Store column index for stable positioning\r\n    macrobeatIndex // Store macrobeat index for stable positioning\r\n  };\r\n}\r\n\r\n/**\r\n * Gets display text for a modulation ratio\r\n * @param ratio - The modulation ratio\r\n * @returns Display text like \"2:3\" or \"3:2\"\r\n */\r\nexport function getModulationDisplayText(ratio: number): string {\r\n  if (Math.abs(ratio - MODULATION_RATIOS.COMPRESSION_2_3) < 0.001) {\r\n    return '2:3';\r\n  } else if (Math.abs(ratio - MODULATION_RATIOS.EXPANSION_3_2) < 0.001) {\r\n    return '3:2';\r\n  }\r\n  return `${ratio}`;\r\n}\r\n\r\n/**\r\n * Gets the color for a modulation marker based on ratio\r\n * @param ratio - The modulation ratio\r\n * @returns CSS color string\r\n */\r\nexport function getModulationColor(ratio: number): string {\r\n  const DEFAULT_UI_YELLOW = '#ffc107';\r\n  if (Math.abs(ratio - MODULATION_RATIOS.COMPRESSION_2_3) < 0.001) {\r\n    return DEFAULT_UI_YELLOW;\r\n  } else if (Math.abs(ratio - MODULATION_RATIOS.EXPANSION_3_2) < 0.001) {\r\n    return DEFAULT_UI_YELLOW;\r\n  }\r\n  return DEFAULT_UI_YELLOW;\r\n}\r\n\r\n/**\r\n * Creates an empty coordinate mapping (no modulation)\r\n * @returns Empty mapping functions\r\n */\r\nfunction createEmptyMapping(): CoordinateMapping {\r\n  const segments: ModulationSegment[] = [{\r\n    startColumn: 0,\r\n    endColumn: Infinity,\r\n    scale: 1.0\r\n  }];\r\n\r\n  return {\r\n    segments,\r\n\r\n    getScaleForColumn(_columnIndex: number): number {\r\n      return 1.0; // No modulation\r\n    },\r\n\r\n    microbeatToCanvasX(): number {\r\n      // This method is no longer used - getColumnX handles everything\r\n      return 0;\r\n    },\r\n\r\n    canvasXToMicrobeat(): number {\r\n      // This method is no longer used\r\n      return 0;\r\n    },\r\n\r\n    getSegmentAtX(): ModulationSegment | null {\r\n      return segments[0] || null;\r\n    },\r\n\r\n    getGhostGridPositions(): number[] {\r\n      return []; // No ghost grid when no modulation\r\n    }\r\n  };\r\n}\r\n\r\n/**\r\n * Creates a coordinate mapping with modulation support\r\n * @param markers - Array of modulation markers\r\n * @param baseMicrobeatPx - Base microbeat pixel width\r\n * @param state - Application state\r\n * @param callbacks - Callbacks for dependencies\r\n * @returns CoordinateMapping object\r\n */\r\nexport function createCoordinateMapping(\r\n  markers: ModulationMarker[],\r\n  baseMicrobeatPx: number,\r\n  state: ModulationMappingState | null = null,\r\n  callbacks: ModulationMappingCallbacks = {}\r\n): CoordinateMapping {\r\n  const { log = () => {} } = callbacks;\r\n\r\n  // Early return if no markers\r\n  if (!markers || markers.length === 0) {\r\n    return createEmptyMapping();\r\n  }\r\n\r\n  // Sort markers by measure index\r\n  const sortedMarkers = [...markers.filter(m => m.active)].sort((a, b) => a.measureIndex - b.measureIndex);\r\n\r\n  // If no active markers, return empty mapping\r\n  if (sortedMarkers.length === 0) {\r\n    return createEmptyMapping();\r\n  }\r\n\r\n  log('debug', '[MODULATION] Creating coordinate mapping for markers', sortedMarkers);\r\n\r\n  // Convert measure-based markers to column indices using state info\r\n  const markersWithColumn: MarkerWithColumn[] = sortedMarkers.map(marker => {\r\n    // Always calculate from measure index for accurate positioning\r\n    // Don't trust stored xPosition as it may be from mouse clicks or outdated\r\n    const columnIndex = measureIndexToColumnIndex(marker.measureIndex, state, callbacks) as CanvasSpaceColumn;\r\n    log('debug', `[MODULATION] Marker at measure ${marker.measureIndex} calculated column=${columnIndex}`);\r\n    log('debug', '[MODULATION] Full marker data', marker);\r\n    log('debug', '[MODULATION] Final marker position', {\r\n      id: marker.id,\r\n      measureIndex: marker.measureIndex,\r\n      columnIndex\r\n    });\r\n\r\n    return {\r\n      ...marker,\r\n      columnIndex\r\n    };\r\n  });\r\n\r\n  // Create segments with cumulative scaling based on column indices\r\n  const segments: ModulationSegment[] = [];\r\n  let cumulativeScale = 1.0;\r\n\r\n  // Add initial segment (before first marker)\r\n  const firstMarker = markersWithColumn[0];\r\n  if (markersWithColumn.length === 0 || (firstMarker && firstMarker.columnIndex > 0)) {\r\n    // Initial segment ends where the modulated segment starts\r\n    const endColumn = firstMarker ? firstMarker.columnIndex : Infinity;\r\n    segments.push({\r\n      startColumn: 0,\r\n      endColumn: endColumn,\r\n      scale: 1.0\r\n    });\r\n  }\r\n\r\n  // Process each marker to create segments\r\n  for (let i = 0; i < markersWithColumn.length; i++) {\r\n    const marker = markersWithColumn[i]!;\r\n    const nextMarker = markersWithColumn[i + 1];\r\n    const nextMarkerColumn = nextMarker ? nextMarker.columnIndex : Infinity;\r\n\r\n    // Update cumulative scale\r\n    cumulativeScale *= marker.ratio;\r\n\r\n    // The marker column represents the first column AFTER the measure boundary (canvas-space)\r\n    segments.push({\r\n      startColumn: marker.columnIndex,  // Canvas-space\r\n      endColumn: nextMarkerColumn,  // Canvas-space\r\n      scale: cumulativeScale,\r\n      marker\r\n    });\r\n  }\r\n\r\n  const mapping: CoordinateMapping = {\r\n    segments,\r\n\r\n    /**\r\n     * Gets the modulation scale for a given column index\r\n     * @param columnIndex - Column index in musical space\r\n     * @returns Scale factor (1.0 = no modulation, 0.667 = compressed, 1.5 = expanded)\r\n     */\r\n    getScaleForColumn(columnIndex: number): number {\r\n      // Find which segment this column belongs to\r\n      for (const segment of segments) {\r\n        if (columnIndex >= segment.startColumn && columnIndex < segment.endColumn) {\r\n          return segment.scale;\r\n        }\r\n      }\r\n      // If not in any segment, return 1.0 (no modulation)\r\n      return 1.0;\r\n    },\r\n\r\n    /**\r\n     * Converts microbeat index to canvas x position\r\n     * NOTE: This method is deprecated - getColumnX in rendererUtils now handles modulation directly\r\n     */\r\n    microbeatToCanvasX(_microbeatIndex: number): number {\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Converts canvas x position to microbeat index\r\n     * NOTE: This method is deprecated - coordinate conversion now handled by getColumnFromX\r\n     */\r\n    canvasXToMicrobeat(_canvasX: number): number {\r\n      return 0;\r\n    },\r\n\r\n    /**\r\n     * Gets the segment containing a given canvas x position\r\n     * NOTE: This method is deprecated - not used in new column-based approach\r\n     */\r\n    getSegmentAtX(_canvasX: number): ModulationSegment | null {\r\n      return segments[0] || null;\r\n    },\r\n\r\n    /**\r\n     * Gets all ghost grid positions for a segment\r\n     * NOTE: This method is deprecated - ghost grid now handled differently\r\n     */\r\n    getGhostGridPositions(_segment: ModulationSegment, _options: GhostGridOptions): number[] {\r\n      return [];\r\n    }\r\n  };\r\n\r\n  return mapping;\r\n}\r\n\r\n/**\r\n * Converts a column's modulated trigger time to regular transport time for scheduling\r\n * @param columnIndex - The column index of the note\r\n * @param regularTimeMap - Regular time map (timeMap from transportService)\r\n * @returns Regular transport time in seconds\r\n */\r\nexport function columnToRegularTime(columnIndex: number, regularTimeMap: number[]): number {\r\n  if (columnIndex >= 0 && columnIndex < regularTimeMap.length) {\r\n    const regularTime = regularTimeMap[columnIndex];\r\n    if (regularTime !== undefined) {\r\n      return regularTime;\r\n    }\r\n  }\r\n\r\n  // Fallback: return a reasonable approximation\r\n  return columnIndex * 0.333; // Rough approximation\r\n}\r\n\r\n/**\r\n * Converts canvas x to time in seconds for audio scheduling\r\n * NOTE: This function is deprecated and may need to be rewritten for column-based approach\r\n */\r\nexport function canvasXToSeconds(\r\n  _canvasX: number,\r\n  _coordinateMapping: CoordinateMapping,\r\n  _baseMicrobeatDuration: number\r\n): number {\r\n  return 0;\r\n}\r\n\r\n/**\r\n * Converts time in seconds to canvas x position\r\n * NOTE: This function is deprecated and may need to be rewritten for column-based approach\r\n */\r\nexport function secondsToCanvasX(\r\n  _seconds: number,\r\n  _coordinateMapping: CoordinateMapping,\r\n  _baseMicrobeatDuration: number\r\n): number {\r\n  return 0;\r\n}\r\n","/**\r\n * Rhythm Actions Module\r\n *\r\n * Framework-agnostic rhythm and time signature manipulation actions.\r\n * All coordinate transformations use injectable columnMapService callbacks.\r\n */\r\n\r\nimport { createModulationMarker, MODULATION_RATIOS } from '../../rhythm/modulationMapping.js';\r\nimport type {\r\n  AnacrusisCache,\r\n  CanvasSpaceColumn,\r\n  MacrobeatBoundaryStyle,\r\n  MacrobeatGrouping,\r\n  ModulationMarker,\r\n  ModulationRatio,\r\n  PlacedNote,\r\n  SixteenthStampPlacement,\r\n  TripletStampPlacement,\r\n  Store,\r\n  TonicSign,\r\n  TonicSignGroups\r\n} from '@mlt/types';\r\nimport type { ColumnMap } from '../../services/columnMapService.js';\r\n\r\n/**\r\n * Callbacks for rhythm actions to access external services\r\n */\r\nexport interface RhythmActionCallbacks {\r\n  /** Get column map for coordinate conversions */\r\n  getColumnMap?: (state: any) => ColumnMap;\r\n  /** Convert visual column to time index */\r\n  visualToTimeIndex?: (state: any, visualIndex: number, groupings: MacrobeatGrouping[]) => number | null;\r\n  /** Convert time index to visual column */\r\n  timeIndexToVisualColumn?: (state: any, timeIndex: number, groupings: MacrobeatGrouping[]) => number | null;\r\n  /** Get time boundary after a macrobeat */\r\n  getTimeBoundaryAfterMacrobeat?: (state: any, index: number, groupings: MacrobeatGrouping[]) => number;\r\n  /** Logger function */\r\n  log?: (level: 'debug' | 'info' | 'warn' | 'error', context: string, message: string, data?: unknown, category?: string) => void;\r\n}\r\n\r\n// Anacrusis constants\r\nexport const ANACRUSIS_ON_GROUPINGS: MacrobeatGrouping[] = new Array<MacrobeatGrouping>(19).fill(2);\r\nexport const ANACRUSIS_ON_STYLES: MacrobeatBoundaryStyle[] = [\r\n  'anacrusis', 'anacrusis', 'solid', 'dashed', 'dashed', 'dashed', 'solid',\r\n  'dashed', 'dashed', 'dashed', 'solid', 'dashed', 'dashed', 'dashed', 'solid',\r\n  'dashed', 'dashed', 'dashed', 'solid'\r\n];\r\nexport const ANACRUSIS_OFF_GROUPINGS: MacrobeatGrouping[] = new Array<MacrobeatGrouping>(16).fill(2);\r\nexport const ANACRUSIS_OFF_STYLES: MacrobeatBoundaryStyle[] = [\r\n  'dashed', 'dashed', 'dashed', 'solid',\r\n  'dashed', 'dashed', 'dashed', 'solid',\r\n  'dashed', 'dashed', 'dashed', 'solid',\r\n  'dashed', 'dashed', 'dashed' // Last measure completed by isLastBeat logic\r\n];\r\n\r\ntype GroupingArray = MacrobeatGrouping[];\r\ntype BoundaryStyleArray = MacrobeatBoundaryStyle[];\r\n\r\n/**\r\n * Helper to recompute tonic sign column indices after rhythm structure changes\r\n */\r\nfunction recomputeTonicColumns(\r\n  state: { tonicSignGroups?: TonicSignGroups },\r\n  getColumnMap: (state: any) => ColumnMap\r\n): void {\r\n  const map = getColumnMap(state);\r\n  const tonicStartByUuid = new Map<string, number>();\r\n\r\n  map.entries.forEach(entry => {\r\n    if (entry.type === 'tonic' && entry.tonicSignUuid && typeof entry.canvasIndex === 'number') {\r\n      tonicStartByUuid.set(entry.tonicSignUuid, entry.canvasIndex);\r\n    }\r\n  });\r\n\r\n  Object.entries(state.tonicSignGroups || {}).forEach(([uuid, group]) => {\r\n    const start = tonicStartByUuid.get(uuid);\r\n    if (start === undefined) { return; }\r\n    group.forEach((sign: TonicSign) => {\r\n      sign.columnIndex = start as CanvasSpaceColumn;\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Creates rhythm action methods with dependency injection\r\n */\r\n// Default empty column map for fallback\r\nconst EMPTY_COLUMN_MAP: ColumnMap = {\r\n  entries: [],\r\n  visualToCanvas: new Map(),\r\n  visualToTime: new Map(),\r\n  canvasToVisual: new Map(),\r\n  canvasToTime: new Map(),\r\n  timeToCanvas: new Map(),\r\n  timeToVisual: new Map(),\r\n  macrobeatBoundaries: [],\r\n  totalVisualColumns: 0,\r\n  totalCanvasColumns: 0,\r\n  totalTimeColumns: 0,\r\n  totalWidthUnmodulated: 0\r\n};\r\n\r\nexport function createRhythmActions(callbacks: RhythmActionCallbacks = {}) {\r\n  const {\r\n    getColumnMap = () => EMPTY_COLUMN_MAP,\r\n    visualToTimeIndex = () => null,\r\n    timeIndexToVisualColumn = () => null,\r\n    getTimeBoundaryAfterMacrobeat = () => 0,\r\n    log = () => {}\r\n  } = callbacks;\r\n\r\n  return {\r\n    setAnacrusis(this: Store, enabled: boolean): void {\r\n      if (this.state.hasAnacrusis === enabled) { return; }\r\n\r\n      const oldGroupings: GroupingArray = [...this.state.macrobeatGroupings];\r\n      const oldBoundaryStyles: BoundaryStyleArray = [...this.state.macrobeatBoundaryStyles];\r\n      const oldTotalBeats = oldGroupings.reduce((sum, val) => sum + val, 0);\r\n\r\n      let newGroupings: GroupingArray;\r\n      let newBoundaryStyles: BoundaryStyleArray;\r\n\r\n      if (!enabled) {\r\n        const firstSolidIndex = oldBoundaryStyles.findIndex(style => style === 'solid');\r\n        let removalCount = 0;\r\n\r\n        if (firstSolidIndex !== -1) {\r\n          removalCount = firstSolidIndex + 1;\r\n        } else {\r\n          while (\r\n            removalCount < oldBoundaryStyles.length &&\r\n            oldBoundaryStyles[removalCount] === 'anacrusis'\r\n          ) {\r\n            removalCount++;\r\n          }\r\n        }\r\n\r\n        removalCount = Math.min(removalCount, oldGroupings.length);\r\n\r\n        const removedGroupings = oldGroupings.slice(0, removalCount);\r\n        const removedStyles = oldBoundaryStyles.slice(0, removalCount);\r\n\r\n        if (removalCount > 0) {\r\n          this._anacrusisCache = {\r\n            groupings: removedGroupings,\r\n            boundaryStyles: removedStyles\r\n          };\r\n        } else {\r\n          this._anacrusisCache = null;\r\n        }\r\n\r\n        newGroupings = oldGroupings.slice(removalCount);\r\n        newBoundaryStyles = oldBoundaryStyles\r\n          .slice(removalCount)\r\n          .map(style => (style === 'anacrusis' ? 'dashed' : style));\r\n\r\n        if (newGroupings.length === 0) {\r\n          newGroupings = [...ANACRUSIS_OFF_GROUPINGS];\r\n          newBoundaryStyles = [...ANACRUSIS_OFF_STYLES];\r\n        }\r\n\r\n        log('debug', 'rhythmActions', 'Disabled anacrusis', {\r\n          removalCount,\r\n          removedColumns: removedGroupings.reduce((sum, val) => sum + val, 0)\r\n        }, 'state');\r\n      } else {\r\n        const cache: AnacrusisCache | null | undefined = this._anacrusisCache;\r\n        const anacrusisLength = ANACRUSIS_ON_GROUPINGS.length - ANACRUSIS_OFF_GROUPINGS.length;\r\n        const defaultGroupings = ANACRUSIS_ON_GROUPINGS.slice(0, anacrusisLength);\r\n        const defaultStyles = ANACRUSIS_ON_STYLES.slice(0, anacrusisLength);\r\n\r\n        const groupingsToInsert = cache?.groupings?.length\r\n          ? [...cache.groupings]\r\n          : [...defaultGroupings];\r\n        const stylesToInsert = cache?.boundaryStyles?.length\r\n          ? [...cache.boundaryStyles]\r\n          : [...defaultStyles];\r\n\r\n        newGroupings = [...groupingsToInsert, ...oldGroupings];\r\n        newBoundaryStyles = [...stylesToInsert, ...oldBoundaryStyles];\r\n\r\n        if (!cache?.boundaryStyles?.length) {\r\n          for (let i = 0; i < stylesToInsert.length; i++) {\r\n            newBoundaryStyles[i] = i < stylesToInsert.length - 1 ? 'anacrusis' : 'solid';\r\n          }\r\n        }\r\n\r\n        this._anacrusisCache = null;\r\n\r\n        log('debug', 'rhythmActions', 'Enabled anacrusis', {\r\n          insertedCount: groupingsToInsert.length,\r\n          insertedColumns: groupingsToInsert.reduce((sum, val) => sum + val, 0)\r\n        }, 'state');\r\n      }\r\n\r\n      const newTotalBeats = newGroupings.reduce((sum, val) => sum + val, 0);\r\n      const timeShift = newTotalBeats - oldTotalBeats;\r\n\r\n      this.state.hasAnacrusis = enabled;\r\n      this.state.macrobeatGroupings = [...newGroupings];\r\n      this.state.macrobeatBoundaryStyles = [...newBoundaryStyles];\r\n      recomputeTonicColumns(this.state, getColumnMap);\r\n\r\n      if (timeShift !== 0) {\r\n        const notesToRemove: PlacedNote[] = [];\r\n\r\n        this.state.placedNotes.forEach(note => {\r\n          const startTime = visualToTimeIndex(this.state, note.startColumnIndex, oldGroupings);\r\n          const endTime = visualToTimeIndex(this.state, note.endColumnIndex, oldGroupings);\r\n\r\n          if (startTime === null || endTime === null) {\r\n            return;\r\n          }\r\n\r\n          const newStartTime = startTime + timeShift;\r\n          const newEndTime = endTime + timeShift;\r\n\r\n          if (newStartTime < 0) {\r\n            notesToRemove.push(note);\r\n            return;\r\n          }\r\n\r\n          const newStartColumn = timeIndexToVisualColumn(this.state, newStartTime, newGroupings);\r\n          const newEndColumn = timeIndexToVisualColumn(this.state, newEndTime, newGroupings);\r\n\r\n          if (newStartColumn === null || newEndColumn === null) {\r\n            notesToRemove.push(note);\r\n            return;\r\n          }\r\n\r\n          note.startColumnIndex = newStartColumn as CanvasSpaceColumn;\r\n          note.endColumnIndex = newEndColumn as CanvasSpaceColumn;\r\n        });\r\n\r\n        notesToRemove.forEach(noteToRemove => {\r\n          const index = this.state.placedNotes.indexOf(noteToRemove);\r\n          if (index > -1) {\r\n            this.state.placedNotes.splice(index, 1);\r\n          }\r\n        });\r\n\r\n        const stampsToRemove: SixteenthStampPlacement[] = [];\r\n\r\n        this.state.sixteenthStampPlacements.forEach(stamp => {\r\n          const startTime = visualToTimeIndex(this.state, stamp.startColumn, oldGroupings);\r\n          const endTime = visualToTimeIndex(this.state, stamp.endColumn, oldGroupings);\r\n\r\n          if (startTime === null || endTime === null) {\r\n            return;\r\n          }\r\n\r\n          const newStartTime = startTime + timeShift;\r\n          const newEndTime = endTime + timeShift;\r\n\r\n          if (newStartTime < 0) {\r\n            stampsToRemove.push(stamp);\r\n            return;\r\n          }\r\n\r\n          const newStartColumn = timeIndexToVisualColumn(this.state, newStartTime, newGroupings);\r\n          const newEndColumn = timeIndexToVisualColumn(this.state, newEndTime, newGroupings);\r\n\r\n          if (newStartColumn === null || newEndColumn === null) {\r\n            stampsToRemove.push(stamp);\r\n            return;\r\n          }\r\n\r\n          stamp.startColumn = newStartColumn as CanvasSpaceColumn;\r\n          stamp.endColumn = newEndColumn as CanvasSpaceColumn;\r\n        });\r\n\r\n        stampsToRemove.forEach(stampToRemove => {\r\n          const index = this.state.sixteenthStampPlacements.indexOf(stampToRemove);\r\n          if (index > -1) {\r\n            this.state.sixteenthStampPlacements.splice(index, 1);\r\n          }\r\n        });\r\n\r\n        const tripletsToRemove: TripletStampPlacement[] = [];\r\n\r\n        if (this.state.tripletStampPlacements) {\r\n          this.state.tripletStampPlacements.forEach(triplet => {\r\n            const newStartTime = triplet.startTimeIndex + timeShift;\r\n            if (newStartTime < 0) {\r\n              tripletsToRemove.push(triplet);\r\n            } else {\r\n              triplet.startTimeIndex = newStartTime;\r\n            }\r\n          });\r\n\r\n          tripletsToRemove.forEach(tripletToRemove => {\r\n            const index = this.state.tripletStampPlacements.indexOf(tripletToRemove);\r\n            if (index > -1) {\r\n              this.state.tripletStampPlacements.splice(index, 1);\r\n            }\r\n          });\r\n        }\r\n\r\n        // Update modulation markers to reflect the new grid layout\r\n        const markersToRemove: ModulationMarker[] = [];\r\n        const anacrusisShift = enabled\r\n          ? (newGroupings.length - oldGroupings.length)\r\n          : -(oldGroupings.length - newGroupings.length);\r\n\r\n        this.state.tempoModulationMarkers.forEach(marker => {\r\n          const newMeasureIndex = marker.measureIndex + anacrusisShift;\r\n\r\n          if (newMeasureIndex < 0) {\r\n            markersToRemove.push(marker);\r\n            return;\r\n          }\r\n\r\n          marker.measureIndex = newMeasureIndex;\r\n          marker.columnIndex = null;\r\n          marker.xPosition = null;\r\n          marker.macrobeatIndex = null;\r\n        });\r\n\r\n        markersToRemove.forEach(markerToRemove => {\r\n          const index = this.state.tempoModulationMarkers.indexOf(markerToRemove);\r\n          if (index > -1) {\r\n            this.state.tempoModulationMarkers.splice(index, 1);\r\n          }\r\n        });\r\n      }\r\n\r\n      this.emit('anacrusisChanged', enabled);\r\n      this.emit('notesChanged');\r\n      this.emit('sixteenthStampPlacementsChanged');\r\n      this.emit('tripletStampPlacementsChanged');\r\n      this.emit('tempoModulationMarkersChanged');\r\n      this.emit('rhythmStructureChanged');\r\n      this.recordState();\r\n    },\r\n\r\n    toggleMacrobeatGrouping(this: Store, index: number): void {\r\n      if (index === undefined || index < 0 || index >= this.state.macrobeatGroupings.length) {\r\n        log('error', 'rhythmActions', `Invalid index for toggleMacrobeatGrouping: ${index}`, null, 'state');\r\n        return;\r\n      }\r\n\r\n      const oldGroupings = [...this.state.macrobeatGroupings];\r\n      const currentValue = oldGroupings[index]!;\r\n      const newValue = currentValue === 2 ? 3 : 2;\r\n      const delta = newValue - currentValue;\r\n\r\n      const newGroupings = [...oldGroupings];\r\n      newGroupings[index] = newValue;\r\n\r\n      const boundaryTime = getTimeBoundaryAfterMacrobeat(this.state, index, oldGroupings);\r\n\r\n      const notesToRemove: PlacedNote[] = [];\r\n\r\n      this.state.placedNotes.forEach(note => {\r\n        const startTime = visualToTimeIndex(this.state, note.startColumnIndex, oldGroupings);\r\n        const endTime = visualToTimeIndex(this.state, note.endColumnIndex, oldGroupings);\r\n\r\n        if (startTime === null || endTime === null) {\r\n          return;\r\n        }\r\n\r\n        if (startTime >= boundaryTime) {\r\n          const newStartTime = startTime + delta;\r\n          const newEndTime = endTime + delta;\r\n          const newStartCol = timeIndexToVisualColumn(this.state, newStartTime, newGroupings);\r\n          const newEndCol = timeIndexToVisualColumn(this.state, newEndTime, newGroupings);\r\n          if (newStartCol !== null && newEndCol !== null) {\r\n            note.startColumnIndex = newStartCol as CanvasSpaceColumn;\r\n            note.endColumnIndex = newEndCol as CanvasSpaceColumn;\r\n          } else {\r\n            notesToRemove.push(note);\r\n          }\r\n        }\r\n      });\r\n\r\n      if (notesToRemove.length) {\r\n        notesToRemove.forEach(n => {\r\n          const idx = this.state.placedNotes.indexOf(n);\r\n          if (idx > -1) { this.state.placedNotes.splice(idx, 1); }\r\n        });\r\n      }\r\n\r\n      this.state.macrobeatGroupings = newGroupings;\r\n      recomputeTonicColumns(this.state, getColumnMap);\r\n\r\n      this.emit('notesChanged');\r\n      this.emit('rhythmStructureChanged');\r\n\r\n      this.recordState();\r\n    },\r\n\r\n    cycleMacrobeatBoundaryStyle(this: Store, index: number): void {\r\n      if (index === undefined || index < 0 || index >= this.state.macrobeatBoundaryStyles.length) {\r\n        log('error', 'rhythmActions', `Invalid index for cycleMacrobeatBoundaryStyle: ${index}`, null, 'state');\r\n        return;\r\n      }\r\n\r\n      const isInAnacrusis = this._isBoundaryInAnacrusis(index);\r\n\r\n      let styles: BoundaryStyleArray;\r\n      if (isInAnacrusis) {\r\n        styles = ['dashed', 'solid', 'anacrusis'];\r\n      } else {\r\n        styles = ['dashed', 'solid'];\r\n      }\r\n\r\n      const currentStyle = this.state.macrobeatBoundaryStyles[index] ?? 'dashed';\r\n      const currentIndex = styles.indexOf(currentStyle);\r\n\r\n      const nextIndex = currentIndex === -1 ? 0 : (currentIndex + 1) % styles.length;\r\n      const nextStyle = styles[nextIndex] ?? 'dashed';\r\n      this.state.macrobeatBoundaryStyles[index] = nextStyle;\r\n\r\n      this.emit('rhythmStructureChanged');\r\n      this.recordState();\r\n    },\r\n\r\n    _isBoundaryInAnacrusis(this: Store, boundaryIndex: number): boolean {\r\n      if (!this.state.hasAnacrusis) { return false; }\r\n\r\n      for (let i = 0; i <= boundaryIndex; i++) {\r\n        if (this.state.macrobeatBoundaryStyles[i] === 'solid') {\r\n          return i === boundaryIndex;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n\r\n    increaseMacrobeatCount(this: Store): void {\r\n      this.state.macrobeatGroupings.push(2);\r\n      this.state.macrobeatBoundaryStyles.push('dashed');\r\n      this.emit('rhythmStructureChanged');\r\n      this.recordState();\r\n    },\r\n\r\n    decreaseMacrobeatCount(this: Store): void {\r\n      if (this.state.macrobeatGroupings.length > 1) {\r\n        const lastMacrobeatIndex = this.state.macrobeatGroupings.length - 1;\r\n        const boundaryTime = getTimeBoundaryAfterMacrobeat(\r\n          this.state,\r\n          lastMacrobeatIndex - 1,\r\n          this.state.macrobeatGroupings\r\n        );\r\n\r\n        const notesToRemove: PlacedNote[] = [];\r\n        this.state.placedNotes.forEach(note => {\r\n          const startTime = visualToTimeIndex(this.state, note.startColumnIndex, this.state.macrobeatGroupings);\r\n          if (startTime !== null && startTime >= boundaryTime) {\r\n            notesToRemove.push(note);\r\n          }\r\n        });\r\n\r\n        notesToRemove.forEach(note => {\r\n          const idx = this.state.placedNotes.indexOf(note);\r\n          if (idx > -1) {\r\n            this.state.placedNotes.splice(idx, 1);\r\n          }\r\n        });\r\n\r\n        const stampsToRemove: SixteenthStampPlacement[] = [];\r\n        this.state.sixteenthStampPlacements.forEach(stamp => {\r\n          const startTime = visualToTimeIndex(this.state, stamp.startColumn, this.state.macrobeatGroupings);\r\n          if (startTime !== null && startTime >= boundaryTime) {\r\n            stampsToRemove.push(stamp);\r\n          }\r\n        });\r\n\r\n        stampsToRemove.forEach(stamp => {\r\n          const idx = this.state.sixteenthStampPlacements.indexOf(stamp);\r\n          if (idx > -1) {\r\n            this.state.sixteenthStampPlacements.splice(idx, 1);\r\n          }\r\n        });\r\n\r\n        const tripletsToRemove: TripletStampPlacement[] = [];\r\n        if (this.state.tripletStampPlacements) {\r\n          this.state.tripletStampPlacements.forEach(triplet => {\r\n            if (triplet.startTimeIndex >= boundaryTime) {\r\n              tripletsToRemove.push(triplet);\r\n            }\r\n          });\r\n\r\n          tripletsToRemove.forEach(triplet => {\r\n            const idx = this.state.tripletStampPlacements.indexOf(triplet);\r\n            if (idx > -1) {\r\n              this.state.tripletStampPlacements.splice(idx, 1);\r\n            }\r\n          });\r\n        }\r\n\r\n        this.state.macrobeatGroupings.pop();\r\n        this.state.macrobeatBoundaryStyles.pop();\r\n\r\n        if (notesToRemove.length > 0) {\r\n          this.emit('notesChanged');\r\n        }\r\n        if (stampsToRemove.length > 0) {\r\n          this.emit('sixteenthStampPlacementsChanged');\r\n        }\r\n        if (tripletsToRemove.length > 0) {\r\n          this.emit('tripletStampPlacementsChanged');\r\n        }\r\n        this.emit('rhythmStructureChanged');\r\n        this.recordState();\r\n      }\r\n    },\r\n\r\n    updateTimeSignature(this: Store, measureIndex: number, newGroupings: GroupingArray): void {\r\n      if (!Array.isArray(newGroupings) || newGroupings.length === 0) {\r\n        log('error', 'rhythmActions', 'Invalid groupings provided to updateTimeSignature', null, 'state');\r\n        return;\r\n      }\r\n\r\n      let measureStartIndex = 0;\r\n      let measureEndIndex = 0;\r\n      let currentMeasure = 0;\r\n\r\n      for (let i = 0; i < this.state.macrobeatGroupings.length; i++) {\r\n        if (currentMeasure === measureIndex) {\r\n          measureStartIndex = i;\r\n          break;\r\n        }\r\n\r\n        const isLastBeat = (i === this.state.macrobeatGroupings.length - 1);\r\n        const boundaryStyle = this.state.macrobeatBoundaryStyles[i];\r\n        const isSolidBoundary = (boundaryStyle === 'solid');\r\n\r\n        if (isSolidBoundary || isLastBeat) {\r\n          currentMeasure++;\r\n        }\r\n      }\r\n\r\n      currentMeasure = 0;\r\n      for (let i = 0; i < this.state.macrobeatGroupings.length; i++) {\r\n        if (currentMeasure === measureIndex) {\r\n          const isLastBeat = (i === this.state.macrobeatGroupings.length - 1);\r\n          const boundaryStyle = this.state.macrobeatBoundaryStyles[i];\r\n          const isSolidBoundary = (boundaryStyle === 'solid');\r\n\r\n          if (isSolidBoundary || isLastBeat) {\r\n            measureEndIndex = i;\r\n            break;\r\n          }\r\n        } else if (currentMeasure < measureIndex) {\r\n          const isLastBeat = (i === this.state.macrobeatGroupings.length - 1);\r\n          const boundaryStyle = this.state.macrobeatBoundaryStyles[i];\r\n          const isSolidBoundary = (boundaryStyle === 'solid');\r\n\r\n          if (isSolidBoundary || isLastBeat) {\r\n            currentMeasure++;\r\n          }\r\n        }\r\n      }\r\n\r\n      const oldLength = measureEndIndex - measureStartIndex + 1;\r\n      const newLength = newGroupings.length;\r\n      const oldTimeSpan = this.state.macrobeatGroupings.slice(measureStartIndex, measureEndIndex + 1)\r\n        .reduce((sum, val) => sum + val, 0);\r\n      const newTimeSpan = newGroupings.reduce((sum, val) => sum + val, 0);\r\n      const timeShift = newTimeSpan - oldTimeSpan;\r\n\r\n      const boundaryTime = getTimeBoundaryAfterMacrobeat(this.state, measureEndIndex, this.state.macrobeatGroupings);\r\n\r\n      if (timeShift !== 0) {\r\n        const nextMacrobeatGroupings = (() => {\r\n          const tmp: GroupingArray = [...this.state.macrobeatGroupings];\r\n          tmp.splice(measureStartIndex, oldLength, ...newGroupings);\r\n          return tmp;\r\n        })();\r\n\r\n        const notesToRemove: PlacedNote[] = [];\r\n\r\n        this.state.placedNotes.forEach(note => {\r\n          const startTime = visualToTimeIndex(this.state, note.startColumnIndex, this.state.macrobeatGroupings);\r\n          const endTime = visualToTimeIndex(this.state, note.endColumnIndex, this.state.macrobeatGroupings);\r\n\r\n          if (startTime === null || endTime === null) {\r\n            return;\r\n          }\r\n\r\n          if (startTime >= boundaryTime) {\r\n            const newStartTime = startTime + timeShift;\r\n            const newEndTime = endTime + timeShift;\r\n            const newStartCol = timeIndexToVisualColumn(this.state, newStartTime, nextMacrobeatGroupings);\r\n            const newEndCol = timeIndexToVisualColumn(this.state, newEndTime, nextMacrobeatGroupings);\r\n\r\n            if (newStartCol !== null && newEndCol !== null) {\r\n              note.startColumnIndex = newStartCol as CanvasSpaceColumn;\r\n              note.endColumnIndex = newEndCol as CanvasSpaceColumn;\r\n            } else {\r\n              notesToRemove.push(note);\r\n            }\r\n          }\r\n        });\r\n\r\n        if (notesToRemove.length) {\r\n          notesToRemove.forEach(n => {\r\n            const idx = this.state.placedNotes.indexOf(n);\r\n            if (idx > -1) { this.state.placedNotes.splice(idx, 1); }\r\n          });\r\n        }\r\n      }\r\n\r\n      const newGroupingsCopy = [...newGroupings];\r\n      const newStylesArray = new Array<MacrobeatBoundaryStyle>(Math.max(newLength - 1, 0)).fill('dashed');\r\n\r\n      if (measureEndIndex < this.state.macrobeatBoundaryStyles.length) {\r\n        const originalFinalStyle = this.state.macrobeatBoundaryStyles[measureEndIndex] ?? 'dashed';\r\n        newStylesArray.push(originalFinalStyle);\r\n      }\r\n\r\n      this.state.macrobeatGroupings.splice(measureStartIndex, oldLength, ...newGroupingsCopy);\r\n      this.state.macrobeatBoundaryStyles.splice(measureStartIndex, oldLength - 1, ...newStylesArray);\r\n\r\n      this.emit('notesChanged');\r\n      this.emit('rhythmStructureChanged');\r\n      this.recordState();\r\n    },\r\n\r\n    addModulationMarker(\r\n      this: Store,\r\n      measureIndex: number,\r\n      ratio: ModulationRatio,\r\n      xPosition: number | null = null,\r\n      columnIndex: CanvasSpaceColumn | null = null,\r\n      macrobeatIndex: number | null = null\r\n    ): string | null {\r\n      if (!Object.values(MODULATION_RATIOS).includes(ratio)) {\r\n        log('error', 'rhythmActions', `Invalid modulation ratio: ${ratio}`, null, 'state');\r\n        return null;\r\n      }\r\n\r\n      const existingMarkerIndex = this.state.tempoModulationMarkers.findIndex((marker: ModulationMarker) => {\r\n        if (marker.measureIndex === measureIndex) {\r\n          return true;\r\n        }\r\n\r\n        if (macrobeatIndex !== null && marker.macrobeatIndex === macrobeatIndex) {\r\n          return true;\r\n        }\r\n\r\n        if (columnIndex !== null && marker.columnIndex === columnIndex) {\r\n          return true;\r\n        }\r\n\r\n        return false;\r\n      });\r\n\r\n      if (existingMarkerIndex !== -1) {\r\n        const existingMarker = this.state.tempoModulationMarkers[existingMarkerIndex]!;\r\n        log('info', 'rhythmActions', `Replacing existing modulation marker ${existingMarker.id} at measure ${measureIndex} (old ratio: ${existingMarker.ratio}, new ratio: ${ratio})`, null, 'state');\r\n\r\n        existingMarker.ratio = ratio;\r\n        existingMarker.xPosition = xPosition;\r\n        if (columnIndex !== null) { existingMarker.columnIndex = columnIndex; }\r\n        if (macrobeatIndex !== null) { existingMarker.macrobeatIndex = macrobeatIndex; }\r\n\r\n        this.emit('tempoModulationMarkersChanged');\r\n        this.recordState();\r\n\r\n        return existingMarker.id;\r\n      }\r\n\r\n      const marker = createModulationMarker(measureIndex, ratio, xPosition, columnIndex, macrobeatIndex);\r\n      this.state.tempoModulationMarkers.push(marker);\r\n\r\n      this.state.tempoModulationMarkers.sort((a, b) => a.measureIndex - b.measureIndex);\r\n\r\n      this.emit('tempoModulationMarkersChanged');\r\n      this.recordState();\r\n\r\n      log('info', 'rhythmActions', `Added modulation marker ${marker.id} at measure ${measureIndex} with ratio=${ratio}, columnIndex=${columnIndex}`, null, 'state');\r\n      return marker.id;\r\n    },\r\n\r\n    removeModulationMarker(this: Store, markerId: string): void {\r\n      const index = this.state.tempoModulationMarkers.findIndex(m => m.id === markerId);\r\n      if (index === -1) {\r\n        log('warn', 'rhythmActions', `Modulation marker not found: ${markerId}`, null, 'state');\r\n        return;\r\n      }\r\n\r\n      this.state.tempoModulationMarkers.splice(index, 1);\r\n      this.emit('tempoModulationMarkersChanged');\r\n      this.recordState();\r\n\r\n      log('info', 'rhythmActions', `Removed modulation marker ${markerId}`, null, 'state');\r\n    },\r\n\r\n    setModulationRatio(this: Store, markerId: string, ratio: ModulationRatio): void {\r\n      if (!Object.values(MODULATION_RATIOS).includes(ratio)) {\r\n        log('error', 'rhythmActions', `Invalid modulation ratio: ${ratio}`, null, 'state');\r\n        return;\r\n      }\r\n\r\n      const marker = this.state.tempoModulationMarkers.find(m => m.id === markerId);\r\n      if (!marker) {\r\n        log('warn', 'rhythmActions', `Modulation marker not found: ${markerId}`, null, 'state');\r\n        return;\r\n      }\r\n\r\n      marker.ratio = ratio;\r\n      this.emit('tempoModulationMarkersChanged');\r\n      this.recordState();\r\n\r\n      log('info', 'rhythmActions', `Updated modulation marker ${markerId} ratio to ${ratio}`, null, 'state');\r\n    },\r\n\r\n    moveModulationMarker(this: Store, markerId: string, measureIndex: number): void {\r\n      const marker = this.state.tempoModulationMarkers.find(m => m.id === markerId);\r\n      if (!marker) {\r\n        log('warn', 'rhythmActions', `Modulation marker not found: ${markerId}`, null, 'state');\r\n        return;\r\n      }\r\n\r\n      marker.measureIndex = measureIndex;\r\n\r\n      this.state.tempoModulationMarkers.sort((a, b) => a.measureIndex - b.measureIndex);\r\n\r\n      this.emit('tempoModulationMarkersChanged');\r\n      this.recordState();\r\n\r\n      log('info', 'rhythmActions', `Moved modulation marker ${markerId} to measure ${measureIndex}`, null, 'state');\r\n    },\r\n\r\n    toggleModulationMarker(this: Store, markerId: string): void {\r\n      const marker = this.state.tempoModulationMarkers.find(m => m.id === markerId);\r\n      if (!marker) {\r\n        log('warn', 'rhythmActions', `Modulation marker not found: ${markerId}`, null, 'state');\r\n        return;\r\n      }\r\n\r\n      marker.active = !marker.active;\r\n      this.emit('tempoModulationMarkersChanged');\r\n      this.recordState();\r\n\r\n      log('info', 'rhythmActions', `Toggled modulation marker ${markerId} active state to ${marker.active}`, null, 'state');\r\n    },\r\n\r\n    clearModulationMarkers(this: Store): void {\r\n      const removedCount = this.state.tempoModulationMarkers.length;\r\n      this.state.tempoModulationMarkers = [];\r\n      this.emit('tempoModulationMarkersChanged');\r\n      this.recordState();\r\n\r\n      log('info', 'rhythmActions', `Cleared ${removedCount} modulation markers`, null, 'state');\r\n    }\r\n  };\r\n}\r\n","/**\r\n * State Store Factory\r\n *\r\n * Event-emitter based state store for the notation engine.\r\n * This provides a clean, framework-agnostic state management system\r\n * that can be used both as a singleton (for backward compatibility)\r\n * and as factory-created instances (for the engine package).\r\n *\r\n * Key features:\r\n * - Event-based reactivity (on/emit/off pattern)\r\n * - Action methods bound to state\r\n * - Optional localStorage persistence\r\n * - Undo/redo history\r\n * - No DOM dependencies (storage adapter is injectable)\r\n */\r\n\r\nimport type { AppState, Store, TimbreState, HistoryEntry } from '@mlt/types';\r\nimport { fullRowData } from './pitchData.js';\r\nimport { getInitialState } from './initialState.js';\r\nimport { createNoteActions, type NoteActionCallbacks } from './actions/noteActions.js';\r\nimport { createSixteenthStampActions, type SixteenthStampActionCallbacks } from './actions/sixteenthStampActions.js';\r\nimport { createTripletStampActions, type TripletStampActionCallbacks } from './actions/tripletStampActions.js';\r\nimport { createRhythmActions, type RhythmActionCallbacks } from './actions/rhythmActions.js';\r\n\r\n// Event callback type\r\nexport type EventCallback<T = unknown> = (data?: T) => void;\r\n\r\n// Unsubscribe function\r\nexport type Unsubscribe = () => void;\r\n\r\n/**\r\n * Storage adapter interface for persistence\r\n * This allows injecting localStorage, sessionStorage, or a mock for testing\r\n */\r\nexport interface StorageAdapter {\r\n  getItem(key: string): string | null;\r\n  setItem(key: string, value: string): void;\r\n  removeItem(key: string): void;\r\n}\r\n\r\n/**\r\n * Configuration for store creation\r\n */\r\nexport interface StoreConfig {\r\n  /** Storage key for persistence */\r\n  storageKey?: string;\r\n  /** Storage adapter (defaults to no persistence) */\r\n  storage?: StorageAdapter;\r\n  /** Initial state override */\r\n  initialState?: Partial<AppState>;\r\n  /** Callback when state should be reloaded (replaces window.location.reload) */\r\n  onClearState?: () => void;\r\n  /** Callbacks for note actions */\r\n  noteActionCallbacks?: NoteActionCallbacks;\r\n  /** Callbacks for sixteenth stamp actions */\r\n  sixteenthStampActionCallbacks?: SixteenthStampActionCallbacks;\r\n  /** Callbacks for triplet stamp actions */\r\n  tripletStampActionCallbacks?: TripletStampActionCallbacks;\r\n  /** Callbacks for rhythm actions */\r\n  rhythmActionCallbacks?: RhythmActionCallbacks;\r\n}\r\n\r\n/**\r\n * Extended store instance with lifecycle methods\r\n */\r\nexport interface StoreInstance extends Store {\r\n  /** Whether this is a cold start (no persisted state) */\r\n  isColdStart: boolean;\r\n  /** Dispose of the store and clean up */\r\n  dispose(): void;\r\n  /** Unsubscribe from an event */\r\n  off(eventName: string, callback: EventCallback): void;\r\n  /** Save state to storage (if configured) */\r\n  saveState(): void;\r\n}\r\n\r\n// Helper to safely restore timbres, ensuring coeffs/phases are Float32Array\r\nfunction restoreTimbres(timbresSnapshot: Record<string, TimbreState>): Record<string, TimbreState> {\r\n  const newTimbres = JSON.parse(JSON.stringify(timbresSnapshot));\r\n  for (const color in newTimbres) {\r\n    const timbre = newTimbres[color];\r\n    if (timbre.coeffs && typeof timbre.coeffs === 'object' && !Array.isArray(timbre.coeffs)) {\r\n      timbre.coeffs = new Float32Array(Object.values(timbre.coeffs));\r\n    } else if (Array.isArray(timbre.coeffs)) {\r\n      timbre.coeffs = new Float32Array(timbre.coeffs);\r\n    }\r\n    if (timbre.phases && typeof timbre.phases === 'object' && !Array.isArray(timbre.phases)) {\r\n      timbre.phases = new Float32Array(Object.values(timbre.phases));\r\n    } else if (Array.isArray(timbre.phases)) {\r\n      timbre.phases = new Float32Array(timbre.phases);\r\n    }\r\n  }\r\n  return newTimbres;\r\n}\r\n\r\n/**\r\n * Load state from storage\r\n */\r\nconst VALID_BOUNDARY_STYLES = new Set(['dashed', 'solid', 'anacrusis']);\n\nfunction isValidMacrobeatGroupings(value: unknown): value is Array<2 | 3> {\n  return Array.isArray(value)\n    && value.length > 0\n    && value.every((entry) => entry === 2 || entry === 3);\n}\n\nfunction isValidMacrobeatBoundaryStyles(\n  value: unknown,\n  groupingsLength: number\n): value is Array<'dashed' | 'solid' | 'anacrusis'> {\n  return Array.isArray(value)\n    && value.length === Math.max(groupingsLength - 1, 0)\n    && value.every((entry) => VALID_BOUNDARY_STYLES.has(entry));\n}\n\nfunction loadStateFromStorage(storage: StorageAdapter | undefined, storageKey: string): Partial<AppState> | undefined {\n  if (!storage) return undefined;\n\n  try {\n    const serializedState = storage.getItem(storageKey);\n    if (serializedState === null) {\n      return undefined;\r\n    }\r\n    const parsedState = JSON.parse(serializedState);\r\n\r\n    const groupings = parsedState.macrobeatGroupings;\n    if (!isValidMacrobeatGroupings(groupings)) {\n      storage.removeItem(storageKey);\n      return undefined;\n    }\n    if (!isValidMacrobeatBoundaryStyles(parsedState.macrobeatBoundaryStyles, groupings.length)) {\n      storage.removeItem(storageKey);\n      return undefined;\n    }\n\n    // Remove timbres from persisted state - always use defaults.\n    // This ensures the Sine preset loads on each session.\n    delete parsedState.timbres;\n\r\n    // Validate pitch range\r\n    if (parsedState.pitchRange) {\r\n      const totalRows = fullRowData.length;\r\n      const maxIndex = Math.max(0, totalRows - 1);\r\n      const topIndex = Math.max(0, Math.min(maxIndex, parsedState.pitchRange.topIndex ?? 0));\r\n      const bottomIndex = Math.max(topIndex, Math.min(maxIndex, parsedState.pitchRange.bottomIndex ?? maxIndex));\r\n      parsedState.pitchRange = { topIndex, bottomIndex };\r\n    }\r\n\r\n    // Validate playhead mode\r\n    if ('playheadMode' in parsedState) {\r\n      const mode = parsedState.playheadMode;\r\n      if (mode !== 'cursor' && mode !== 'microbeat' && mode !== 'macrobeat') {\r\n        delete parsedState.playheadMode;\r\n      }\r\n    }\r\n\r\n    // Ensure fullRowData is always complete\r\n    parsedState.fullRowData = [...fullRowData];\r\n\r\n    return parsedState;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Save state to storage\r\n */\r\nfunction saveStateToStorage(state: AppState, storage: StorageAdapter | undefined, storageKey: string): void {\r\n  if (!storage) return;\r\n\r\n  try {\r\n    // NOTE: timbres are intentionally NOT persisted\r\n    // This ensures the default Sine preset loads on each session\r\n    // Users can change presets during a session, but they reset on reload\r\n    const stateToPersist = JSON.parse(JSON.stringify({\r\n      placedNotes: state.placedNotes,\r\n      placedChords: state.placedChords,\r\n      tonicSignGroups: state.tonicSignGroups,\r\n      sixteenthStampPlacements: state.sixteenthStampPlacements,\r\n      tripletStampPlacements: state.tripletStampPlacements,\r\n      // timbres: state.timbres, // Removed - always use default Sine preset\r\n      macrobeatGroupings: state.macrobeatGroupings,\r\n      macrobeatBoundaryStyles: state.macrobeatBoundaryStyles,\r\n      hasAnacrusis: state.hasAnacrusis,\r\n      baseMicrobeatPx: state.baseMicrobeatPx,\r\n      tempoModulationMarkers: state.tempoModulationMarkers,\r\n      tempo: state.tempo,\r\n      activeChordIntervals: state.activeChordIntervals,\r\n      selectedNote: state.selectedNote,\r\n      annotations: state.annotations,\r\n      pitchRange: state.pitchRange,\r\n      degreeDisplayMode: state.degreeDisplayMode,\r\n      showOctaveLabels: state.showOctaveLabels,\r\n      longNoteStyle: state.longNoteStyle,\r\n      playheadMode: state.playheadMode\r\n    }));\r\n\r\n    const serializedState = JSON.stringify(stateToPersist);\r\n    storage.setItem(storageKey, serializedState);\r\n  } catch {\r\n    // Silently fail on storage errors\r\n  }\r\n}\r\n\r\n/**\r\n * Create a new store instance\r\n */\r\nexport function createStore(config: StoreConfig = {}): StoreInstance {\r\n  const {\r\n    storageKey = 'studentNotationState',\r\n    storage,\r\n    initialState: configInitialState,\r\n    onClearState,\r\n    noteActionCallbacks = {},\r\n    sixteenthStampActionCallbacks = {},\r\n    tripletStampActionCallbacks = {},\r\n    rhythmActionCallbacks = {}\r\n  } = config;\r\n\r\n  // Event subscribers\r\n  const subscribers: Record<string, EventCallback[]> = {};\r\n\r\n  // Load persisted state\r\n  const persistedState = loadStateFromStorage(storage, storageKey);\r\n  const isColdStart = !persistedState;\r\n\r\n  // Merge initial state\r\n  const baseInitialState = getInitialState();\r\n  const mergedState: AppState = {\r\n    ...baseInitialState,\r\n    ...persistedState,\r\n    ...configInitialState\r\n  } as AppState;\r\n\r\n  // Create the store object with state and event methods\r\n  const store: StoreInstance = {\r\n    state: mergedState,\r\n    isColdStart,\r\n\r\n    on<T = unknown>(eventName: string, callback: EventCallback<T>): void {\r\n      if (!subscribers[eventName]) {\r\n        subscribers[eventName] = [];\r\n      }\r\n      subscribers[eventName].push(callback as EventCallback);\r\n    },\r\n\r\n    off(eventName: string, callback: EventCallback): void {\r\n      if (subscribers[eventName]) {\r\n        const index = subscribers[eventName].indexOf(callback);\r\n        if (index > -1) {\r\n          subscribers[eventName].splice(index, 1);\r\n        }\r\n      }\r\n    },\r\n\r\n    emit<T = unknown>(eventName: string, data?: T): void {\r\n      if (subscribers[eventName]) {\r\n        subscribers[eventName].forEach(callback => {\r\n          try {\r\n            callback(data);\r\n          } catch (error) {\r\n            console.error(`Error in listener for event \"${eventName}\"`, error);\r\n          }\r\n        });\r\n      }\r\n    },\r\n\r\n    dispose(): void {\r\n      // Clear all subscribers\r\n      for (const key in subscribers) {\r\n        delete subscribers[key];\r\n      }\r\n    },\r\n\r\n    saveState(): void {\r\n      saveStateToStorage(store.state, storage, storageKey);\r\n    },\r\n\r\n    // ========== HISTORY ACTIONS ==========\r\n    recordState(): void {\r\n      store.state.history = store.state.history.slice(0, store.state.historyIndex + 1);\r\n\r\n      const timbresForHistory = JSON.parse(JSON.stringify(store.state.timbres));\r\n\r\n      const newSnapshot: HistoryEntry = {\r\n        notes: JSON.parse(JSON.stringify(store.state.placedNotes)),\r\n        tonicSignGroups: JSON.parse(JSON.stringify(store.state.tonicSignGroups)),\r\n        placedChords: JSON.parse(JSON.stringify(store.state.placedChords)),\r\n        sixteenthStampPlacements: JSON.parse(JSON.stringify(store.state.sixteenthStampPlacements)),\r\n        tripletStampPlacements: JSON.parse(JSON.stringify(store.state.tripletStampPlacements || [])),\r\n        timbres: timbresForHistory,\r\n        annotations: store.state.annotations ? JSON.parse(JSON.stringify(store.state.annotations)) : [],\r\n        lassoSelection: JSON.parse(JSON.stringify(store.state.lassoSelection))\r\n      };\r\n      store.state.history.push(newSnapshot);\r\n      store.state.historyIndex++;\r\n      store.emit('historyChanged');\r\n      store.saveState();\r\n    },\r\n\r\n    undo(): void {\r\n      if (store.state.historyIndex > 0) {\r\n        store.state.historyIndex--;\r\n        const snapshot = store.state.history[store.state.historyIndex];\r\n        if (!snapshot) return;\r\n        store.state.placedNotes = JSON.parse(JSON.stringify(snapshot.notes));\r\n        store.state.tonicSignGroups = JSON.parse(JSON.stringify(snapshot.tonicSignGroups));\r\n        store.state.sixteenthStampPlacements = JSON.parse(JSON.stringify(snapshot.sixteenthStampPlacements || []));\r\n        store.state.tripletStampPlacements = JSON.parse(JSON.stringify(snapshot.tripletStampPlacements || []));\r\n        store.state.timbres = restoreTimbres(snapshot.timbres);\r\n        store.state.annotations = snapshot.annotations ? JSON.parse(JSON.stringify(snapshot.annotations)) : [];\r\n        store.emit('notesChanged');\r\n        store.emit('sixteenthStampPlacementsChanged');\r\n        store.emit('tripletStampPlacementsChanged');\r\n        store.emit('rhythmStructureChanged');\r\n        if (store.state.selectedNote?.color) {\r\n          store.emit('timbreChanged', store.state.selectedNote.color);\r\n        }\r\n        store.emit('annotationsChanged');\r\n        store.emit('historyChanged');\r\n      }\r\n    },\r\n\r\n    redo(): void {\r\n      if (store.state.historyIndex < store.state.history.length - 1) {\r\n        store.state.historyIndex++;\r\n        const snapshot = store.state.history[store.state.historyIndex];\r\n        if (!snapshot) return;\r\n        store.state.placedNotes = JSON.parse(JSON.stringify(snapshot.notes));\r\n        store.state.tonicSignGroups = JSON.parse(JSON.stringify(snapshot.tonicSignGroups));\r\n        store.state.sixteenthStampPlacements = JSON.parse(JSON.stringify(snapshot.sixteenthStampPlacements || []));\r\n        store.state.tripletStampPlacements = JSON.parse(JSON.stringify(snapshot.tripletStampPlacements || []));\r\n        store.state.timbres = restoreTimbres(snapshot.timbres);\r\n        store.state.annotations = snapshot.annotations ? JSON.parse(JSON.stringify(snapshot.annotations)) : [];\r\n        store.emit('notesChanged');\r\n        store.emit('sixteenthStampPlacementsChanged');\r\n        store.emit('tripletStampPlacementsChanged');\r\n        store.emit('rhythmStructureChanged');\r\n        if (store.state.selectedNote?.color) {\r\n          store.emit('timbreChanged', store.state.selectedNote.color);\r\n        }\r\n        store.emit('annotationsChanged');\r\n        store.emit('historyChanged');\r\n      }\r\n    },\r\n\r\n    clearSavedState(): void {\r\n      if (storage) {\r\n        storage.removeItem(storageKey);\r\n        storage.removeItem('effectDialValues');\r\n      }\r\n      if (onClearState) {\r\n        onClearState();\r\n      }\r\n    },\r\n\r\n    // ========== VIEW ACTIONS ==========\r\n    setPlaybackState(isPlaying: boolean, isPaused: boolean): void {\r\n      store.state.isPlaying = isPlaying;\r\n      store.state.isPaused = isPaused;\r\n      store.emit('playbackStateChanged', { isPlaying, isPaused });\r\n    },\r\n\r\n    setLooping(isLooping: boolean): void {\r\n      store.state.isLooping = isLooping;\r\n      store.emit('loopingChanged', isLooping);\r\n    },\r\n\r\n    setTempo(tempo: number): void {\r\n      store.state.tempo = tempo;\r\n      store.emit('tempoChanged', tempo);\r\n    },\r\n\r\n    setPlayheadMode(mode: 'cursor' | 'microbeat' | 'macrobeat'): void {\r\n      store.state.playheadMode = mode;\r\n      store.emit('playheadModeChanged', mode);\r\n    },\r\n\r\n    setSelectedTool(tool: string, tonicNumber?: string | number): void {\r\n      const oldTool = store.state.selectedTool;\r\n      store.state.previousTool = oldTool;\r\n      store.state.selectedTool = tool;\r\n\r\n      // Update tonic number if provided\r\n      if (tonicNumber !== undefined) {\r\n        const numericTonic = typeof tonicNumber === 'string' ? parseInt(tonicNumber, 10) : tonicNumber;\r\n        if (!isNaN(numericTonic)) {\r\n          store.state.selectedToolTonicNumber = numericTonic;\r\n        }\r\n      }\r\n\r\n      store.emit('toolChanged', { newTool: tool, oldTool });\r\n    },\r\n\r\n    setSelectedNote(shape: 'circle' | 'oval' | 'diamond', color: string): void {\r\n      const oldNote = { ...store.state.selectedNote };\r\n      store.state.selectedNote = { shape, color };\r\n      store.emit('noteChanged', { newNote: store.state.selectedNote, oldNote });\r\n    },\r\n\r\n    setPitchRange(range: Partial<AppState['pitchRange']>): void {\r\n      store.state.pitchRange = { ...store.state.pitchRange, ...range };\r\n      store.emit('pitchRangeChanged', store.state.pitchRange);\r\n    },\r\n\r\n    setDegreeDisplayMode(mode: 'off' | 'diatonic' | 'modal'): void {\r\n      store.state.degreeDisplayMode = mode;\r\n      store.emit('degreeDisplayModeChanged', mode);\r\n    },\r\n\r\n    setLongNoteStyle(style: 'style1' | 'style2'): void {\r\n      store.state.longNoteStyle = style;\r\n      store.emit('longNoteStyleChanged', style);\r\n    },\r\n\r\n    toggleAccidentalMode(type: 'sharp' | 'flat'): void {\r\n      store.state.accidentalMode[type] = !store.state.accidentalMode[type];\r\n      store.emit('accidentalModeChanged', store.state.accidentalMode);\r\n    },\r\n\r\n    toggleFrequencyLabels(): void {\r\n      store.state.showFrequencyLabels = !store.state.showFrequencyLabels;\r\n      store.emit('frequencyLabelsChanged', store.state.showFrequencyLabels);\r\n    },\r\n\r\n    toggleOctaveLabels(): void {\r\n      store.state.showOctaveLabels = !store.state.showOctaveLabels;\r\n      store.emit('octaveLabelsChanged', store.state.showOctaveLabels);\r\n    },\r\n\r\n    toggleFocusColours(): void {\r\n      store.state.focusColours = !store.state.focusColours;\r\n      store.emit('focusColoursChanged', store.state.focusColours);\r\n    },\r\n\r\n    toggleWaveformExtendedView(): void {\r\n      store.state.waveformExtendedView = !store.state.waveformExtendedView;\r\n      store.emit('waveformExtendedViewChanged', store.state.waveformExtendedView);\r\n    },\r\n\r\n    setLayoutConfig(config: { cellWidth?: number; cellHeight?: number; columnWidths?: number[] }): void {\r\n      if (config.cellWidth !== undefined) {\r\n        store.state.cellWidth = config.cellWidth;\r\n      }\r\n      if (config.cellHeight !== undefined) {\r\n        store.state.cellHeight = config.cellHeight;\r\n      }\r\n      if (config.columnWidths !== undefined) {\r\n        store.state.columnWidths = config.columnWidths;\r\n      }\r\n      store.emit('layoutConfigChanged', config);\r\n    },\r\n\r\n    setDeviceProfile(profile: Partial<AppState['deviceProfile']>): void {\r\n      store.state.deviceProfile = { ...store.state.deviceProfile, ...profile };\r\n      store.emit('deviceProfileChanged', store.state.deviceProfile);\r\n    },\r\n\r\n    setPrintPreviewActive(isActive: boolean): void {\r\n      store.state.isPrintPreviewActive = isActive;\r\n      store.emit('printPreviewStateChanged', isActive);\r\n    },\r\n\r\n    setPrintOptions(options: Partial<AppState['printOptions']>): void {\r\n      store.state.printOptions = { ...store.state.printOptions, ...options };\r\n      store.emit('printOptionsChanged', store.state.printOptions);\r\n    },\r\n\r\n    setAdsrTimeAxisScale(scale: number): void {\r\n      store.state.adsrTimeAxisScale = scale;\r\n      store.emit('adsrTimeAxisScaleChanged', scale);\r\n    },\r\n\r\n    setAdsrComponentWidth(): void {\r\n      // Placeholder - implementation depends on app-specific logic\r\n    },\r\n\r\n    shiftGridUp(): void {\r\n      // Placeholder - implementation depends on app-specific logic\r\n    },\r\n\r\n    shiftGridDown(): void {\r\n      // Placeholder - implementation depends on app-specific logic\r\n    },\r\n\r\n    setGridPosition(): void {\r\n      // Placeholder - implementation depends on app-specific logic\r\n    },\r\n\r\n    setKeySignature(key?: string): void {\r\n      store.state.keySignature = key;\r\n      store.emit('keySignatureChanged', key);\r\n    },\r\n\r\n    // ========== HARMONY ACTIONS ==========\r\n    setActiveChordIntervals(intervals: string[]): void {\r\n      store.state.activeChordIntervals = intervals;\r\n      store.emit('activeChordIntervalsChanged', intervals);\r\n    },\r\n\r\n    setIntervalsInversion(isInverted: boolean): void {\r\n      store.state.isIntervalsInverted = isInverted;\r\n      store.emit('intervalsInversionChanged', isInverted);\r\n    },\r\n\r\n    setChordPosition(position: number): void {\r\n      store.state.chordPositionState = position;\r\n      store.emit('chordPositionChanged', position);\r\n    },\r\n\r\n    // ========== TIMBRE ACTIONS ==========\r\n    setADSR(color: string, adsr: Partial<AppState['timbres'][string]['adsr']>): void {\r\n      if (store.state.timbres[color]) {\r\n        store.state.timbres[color].adsr = { ...store.state.timbres[color].adsr, ...adsr };\r\n        store.emit('timbreChanged', color);\r\n      }\r\n    },\r\n\r\n    setHarmonicCoefficients(color: string, coeffs: Float32Array): void {\r\n      if (store.state.timbres[color]) {\r\n        store.state.timbres[color].coeffs = coeffs;\r\n        store.emit('timbreChanged', color);\r\n      }\r\n    },\r\n\r\n    setHarmonicPhases(color: string, phases: Float32Array): void {\r\n      if (store.state.timbres[color]) {\r\n        store.state.timbres[color].phases = phases;\r\n        store.emit('timbreChanged', color);\r\n      }\r\n    },\r\n\r\n    setFilterSettings(color: string, settings: Partial<AppState['timbres'][string]['filter']>): void {\r\n      if (store.state.timbres[color]) {\r\n        store.state.timbres[color].filter = { ...store.state.timbres[color].filter, ...settings };\r\n        store.emit('timbreChanged', color);\r\n      }\r\n    },\r\n\r\n    applyPreset(color: string, preset: Partial<AppState['timbres'][string]>): void {\r\n      if (store.state.timbres[color]) {\r\n        Object.assign(store.state.timbres[color], preset);\r\n        store.emit('timbreChanged', color);\r\n      }\r\n    },\r\n\r\n    // ========== NOTE ACTIONS ==========\r\n    // Extracted from note actions module\r\n    ...createNoteActions(noteActionCallbacks),\r\n\r\n    // ========== SIXTEENTH STAMP ACTIONS ==========\r\n    // Extracted from sixteenth stamp actions module\r\n    ...createSixteenthStampActions(sixteenthStampActionCallbacks),\r\n\r\n    // ========== TRIPLET STAMP ACTIONS ==========\r\n    // Extracted from triplet stamp actions module\r\n    ...createTripletStampActions(tripletStampActionCallbacks),\r\n\r\n    // ========== RHYTHM ACTIONS ==========\r\n    // Extracted from rhythm actions module\r\n    ...createRhythmActions(rhythmActionCallbacks)\r\n  };\r\n\r\n  // Set up automatic persistence on key events\r\n  if (storage) {\r\n    store.on('tempoChanged', () => store.saveState());\r\n    store.on('degreeDisplayModeChanged', () => store.saveState());\r\n    store.on('longNoteStyleChanged', () => store.saveState());\r\n    store.on('playheadModeChanged', () => store.saveState());\r\n  }\r\n\r\n  // Save initial state if cold start\r\n  if (isColdStart && storage) {\r\n    store.saveState();\r\n  }\r\n\r\n  return store;\r\n}\r\n","/**\r\n * Column Mapping Service\r\n *\r\n * Framework-agnostic column mapping service that manages the canonical column map\r\n * for all grid rendering and interaction logic. Provides O(1) coordinate\r\n * conversions between visual, canvas, and time column spaces with caching.\r\n *\r\n * Coordinate Systems:\r\n * - Visual: Full grid including left legends (2 cols) + musical + right legends (2 cols)\r\n * - Canvas: Musical columns only (0 = first beat), excludes legends, includes tonics\r\n * - Time: Time-bearing columns only (0 = first microbeat), excludes legends and tonics\r\n */\r\n\r\nimport type {\r\n  TonicSign,\r\n  TonicSignGroups,\r\n  MacrobeatGrouping,\r\n  MacrobeatBoundaryStyle\r\n} from '@mlt/types';\r\n\r\n/**\r\n * Complete metadata for a single column\r\n */\r\nexport interface ColumnEntry {\r\n  visualIndex: number;           // Full-space index (includes legends)\r\n  canvasIndex: number | null;    // Canvas-space index (null for legends)\r\n  timeIndex: number | null;      // Time-bearing index (null for non-playable)\r\n  type: 'legend-left' | 'legend-right' | 'tonic' | 'beat';\r\n  widthMultiplier: number;       // Column width in abstract units\r\n  xOffsetUnmodulated: number;    // Cumulative X offset in abstract units\r\n  macrobeatIndex: number | null; // Which macrobeat this column belongs to\r\n  beatInMacrobeat: number | null; // Position within macrobeat (0-based)\r\n  isMacrobeatStart: boolean;     // First beat of macrobeat\r\n  isMacrobeatEnd: boolean;       // Last beat of macrobeat\r\n  isPlayable: boolean;           // Can notes be placed here?\r\n  tonicSignUuid: string | null;  // UUID if this is a tonic column\r\n}\r\n\r\n/**\r\n * Macrobeat boundary information in all coordinate spaces\r\n */\r\nexport interface MacrobeatBoundary {\r\n  macrobeatIndex: number;\r\n  visualColumn: number;          // Visual-space column at boundary\r\n  canvasColumn: number;          // Canvas-space column at boundary\r\n  timeColumn: number;            // Time-space column at boundary\r\n  boundaryType: 'solid' | 'dashed' | 'anacrusis';\r\n  isMeasureStart: boolean;       // True for solid boundaries\r\n}\r\n\r\n/**\r\n * Complete column map with all metadata and lookup tables\r\n */\r\nexport interface ColumnMap {\r\n  entries: ColumnEntry[];\r\n\r\n  // Fast bidirectional lookups (O(1))\r\n  visualToCanvas: Map<number, number | null>;\r\n  visualToTime: Map<number, number | null>;\r\n  canvasToVisual: Map<number, number>;\r\n  canvasToTime: Map<number, number | null>;\r\n  timeToCanvas: Map<number, number>;\r\n  timeToVisual: Map<number, number>;\r\n\r\n  // Boundaries\r\n  macrobeatBoundaries: MacrobeatBoundary[];\r\n\r\n  // Totals\r\n  totalVisualColumns: number;\r\n  totalCanvasColumns: number;\r\n  totalTimeColumns: number;\r\n  totalWidthUnmodulated: number;\r\n}\r\n\r\n/**\r\n * State interface for column mapping\r\n */\r\nexport interface ColumnMapState {\r\n  macrobeatGroupings: MacrobeatGrouping[];\r\n  macrobeatBoundaryStyles: MacrobeatBoundaryStyle[];\r\n  tonicSignGroups: TonicSignGroups;\r\n}\r\n\r\n/**\r\n * Callbacks for column mapping service\r\n */\r\nexport interface ColumnMapCallbacks {\r\n  /** Get placed tonic signs from state */\r\n  getPlacedTonicSigns?: (state: ColumnMapState) => TonicSign[];\r\n  /** Side column width multiplier */\r\n  sideColumnWidth?: number;\r\n  /** Beat column width multiplier */\r\n  beatColumnWidth?: number;\r\n}\r\n\r\n/**\r\n * Cache key for invalidation\r\n */\r\ninterface CacheKey {\r\n  macrobeatGroupings: number[];\r\n  tonicSignsHash: string;\r\n  macrobeatBoundaryStyles: string[];\r\n}\r\n\r\n/**\r\n * Create a column mapping service instance\r\n */\r\nexport function createColumnMapService(callbacks: ColumnMapCallbacks = {}) {\r\n  const {\r\n    getPlacedTonicSigns = () => [],\r\n    sideColumnWidth = 0.25,\r\n    beatColumnWidth = 1.0\r\n  } = callbacks;\r\n\r\n  let cachedMap: ColumnMap | null = null;\r\n  let cacheKey: CacheKey | null = null;\r\n\r\n  /**\r\n   * Builds cache key from relevant state\r\n   */\r\n  function buildCacheKey(state: ColumnMapState): CacheKey {\r\n    const tonicSigns = getPlacedTonicSigns(state);\r\n    const tonicSignsHash = tonicSigns\r\n      .map(ts => `${ts.columnIndex}:${ts.preMacrobeatIndex}:${ts.uuid || ''}`)\r\n      .sort()\r\n      .join('|');\r\n\r\n    return {\r\n      macrobeatGroupings: [...state.macrobeatGroupings],\r\n      tonicSignsHash,\r\n      macrobeatBoundaryStyles: [...state.macrobeatBoundaryStyles]\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Checks if cached map is still valid\r\n   */\r\n  function isCacheValid(newKey: CacheKey): boolean {\r\n    if (!cacheKey) return false;\r\n\r\n    return (\r\n      cacheKey.tonicSignsHash === newKey.tonicSignsHash &&\r\n      JSON.stringify(cacheKey.macrobeatGroupings) === JSON.stringify(newKey.macrobeatGroupings) &&\r\n      JSON.stringify(cacheKey.macrobeatBoundaryStyles) === JSON.stringify(newKey.macrobeatBoundaryStyles)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Builds the complete column map from state\r\n   */\r\n  function buildColumnMap(state: ColumnMapState): ColumnMap {\r\n    const { macrobeatGroupings, macrobeatBoundaryStyles } = state;\r\n    const tonicSigns = getPlacedTonicSigns(state);\r\n    const sortedTonics = [...tonicSigns].sort((a, b) => a.preMacrobeatIndex - b.preMacrobeatIndex);\r\n\r\n    const entries: ColumnEntry[] = [];\r\n    const macrobeatBoundaries: MacrobeatBoundary[] = [];\r\n\r\n    let visualIndex = 0;\r\n    let canvasIndex = 0;\r\n    let timeIndex = 0;\r\n    let xOffset = 0;\r\n    let tonicCursor = 0;\r\n\r\n    /**\r\n     * Helper to add tonic columns for a specific macrobeat position\r\n     */\r\n    const addTonicColumns = (preMacrobeatIndex: number): void => {\r\n      while (tonicCursor < sortedTonics.length) {\r\n        const tonic = sortedTonics[tonicCursor];\r\n        if (!tonic) break;\r\n        if (tonic.preMacrobeatIndex !== preMacrobeatIndex) break;\r\n\r\n        const uuid = tonic.uuid || '';\r\n\r\n        // Each tonic sign occupies 2 canvas columns (zero time)\r\n        for (let i = 0; i < 2; i++) {\r\n          entries.push({\r\n            visualIndex,\r\n            canvasIndex,\r\n            timeIndex: null,\r\n            type: 'tonic',\r\n            widthMultiplier: beatColumnWidth,\r\n            xOffsetUnmodulated: xOffset,\r\n            macrobeatIndex: null,\r\n            beatInMacrobeat: null,\r\n            isMacrobeatStart: false,\r\n            isMacrobeatEnd: false,\r\n            isPlayable: false,\r\n            tonicSignUuid: i === 0 ? uuid : null  // Only first column stores UUID\r\n          });\r\n\r\n          visualIndex++;\r\n          canvasIndex++;\r\n          xOffset += beatColumnWidth;\r\n        }\r\n\r\n        // Advance past all instances with same UUID\r\n        const currentUuid = uuid;\r\n        do {\r\n          tonicCursor++;\r\n        } while (\r\n          tonicCursor < sortedTonics.length &&\r\n          ((sortedTonics[tonicCursor]?.uuid || '') === currentUuid)\r\n        );\r\n      }\r\n    };\r\n\r\n    // Left legends (2 columns)\r\n    for (let i = 0; i < 2; i++) {\r\n      entries.push({\r\n        visualIndex,\r\n        canvasIndex: null,\r\n        timeIndex: null,\r\n        type: 'legend-left',\r\n        widthMultiplier: sideColumnWidth,\r\n        xOffsetUnmodulated: xOffset,\r\n        macrobeatIndex: null,\r\n        beatInMacrobeat: null,\r\n        isMacrobeatStart: false,\r\n        isMacrobeatEnd: false,\r\n        isPlayable: false,\r\n        tonicSignUuid: null\r\n      });\r\n      visualIndex++;\r\n      xOffset += sideColumnWidth;\r\n    }\r\n\r\n    // Tonics before first macrobeat (preMacrobeatIndex = -1)\r\n    addTonicColumns(-1);\r\n\r\n    // Process each macrobeat\r\n    macrobeatGroupings.forEach((grouping, mbIndex) => {\r\n      // Add beat columns\r\n      for (let beatIdx = 0; beatIdx < grouping; beatIdx++) {\r\n        entries.push({\r\n          visualIndex,\r\n          canvasIndex,\r\n          timeIndex,\r\n          type: 'beat',\r\n          widthMultiplier: beatColumnWidth,\r\n          xOffsetUnmodulated: xOffset,\r\n          macrobeatIndex: mbIndex,\r\n          beatInMacrobeat: beatIdx,\r\n          isMacrobeatStart: beatIdx === 0,\r\n          isMacrobeatEnd: beatIdx === grouping - 1,\r\n          isPlayable: true,\r\n          tonicSignUuid: null\r\n        });\r\n\r\n        visualIndex++;\r\n        canvasIndex++;\r\n        timeIndex++;\r\n        xOffset += beatColumnWidth;\r\n      }\r\n\r\n      // Record macrobeat boundary (at end of macrobeat)\r\n      const boundaryStyle = macrobeatBoundaryStyles[mbIndex] || 'dashed';\r\n      macrobeatBoundaries.push({\r\n        macrobeatIndex: mbIndex,\r\n        visualColumn: visualIndex - 1,\r\n        canvasColumn: canvasIndex - 1,\r\n        timeColumn: timeIndex - 1,\r\n        boundaryType: boundaryStyle as 'solid' | 'dashed' | 'anacrusis',\r\n        isMeasureStart: boundaryStyle === 'solid'\r\n      });\r\n\r\n      // Add tonics after this macrobeat\r\n      addTonicColumns(mbIndex);\r\n    });\r\n\r\n    // Right legends (2 columns)\r\n    for (let i = 0; i < 2; i++) {\r\n      entries.push({\r\n        visualIndex,\r\n        canvasIndex: null,\r\n        timeIndex: null,\r\n        type: 'legend-right',\r\n        widthMultiplier: sideColumnWidth,\r\n        xOffsetUnmodulated: xOffset,\r\n        macrobeatIndex: null,\r\n        beatInMacrobeat: null,\r\n        isMacrobeatStart: false,\r\n        isMacrobeatEnd: false,\r\n        isPlayable: false,\r\n        tonicSignUuid: null\r\n      });\r\n      visualIndex++;\r\n      xOffset += sideColumnWidth;\r\n    }\r\n\r\n    // Build lookup maps for O(1) conversions\r\n    const visualToCanvas = new Map<number, number | null>();\r\n    const visualToTime = new Map<number, number | null>();\r\n    const canvasToVisual = new Map<number, number>();\r\n    const canvasToTime = new Map<number, number | null>();\r\n    const timeToCanvas = new Map<number, number>();\r\n    const timeToVisual = new Map<number, number>();\r\n\r\n    entries.forEach(entry => {\r\n      visualToCanvas.set(entry.visualIndex, entry.canvasIndex);\r\n      visualToTime.set(entry.visualIndex, entry.timeIndex);\r\n\r\n      if (entry.canvasIndex !== null) {\r\n        canvasToVisual.set(entry.canvasIndex, entry.visualIndex);\r\n        canvasToTime.set(entry.canvasIndex, entry.timeIndex);\r\n      }\r\n\r\n      if (entry.timeIndex !== null) {\r\n        if (entry.canvasIndex !== null) {\r\n          timeToCanvas.set(entry.timeIndex, entry.canvasIndex);\r\n        }\r\n        timeToVisual.set(entry.timeIndex, entry.visualIndex);\r\n      }\r\n    });\r\n\r\n    return {\r\n      entries,\r\n      visualToCanvas,\r\n      visualToTime,\r\n      canvasToVisual,\r\n      canvasToTime,\r\n      timeToCanvas,\r\n      timeToVisual,\r\n      macrobeatBoundaries,\r\n      totalVisualColumns: visualIndex,\r\n      totalCanvasColumns: canvasIndex,\r\n      totalTimeColumns: timeIndex,\r\n      totalWidthUnmodulated: xOffset\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Gets the column map, returning cached version if valid\r\n   */\r\n  function getColumnMap(state: ColumnMapState): ColumnMap {\r\n    const currentKey = buildCacheKey(state);\r\n\r\n    if (cachedMap && isCacheValid(currentKey)) {\r\n      return cachedMap;\r\n    }\r\n\r\n    cachedMap = buildColumnMap(state);\r\n    cacheKey = currentKey;\r\n    return cachedMap;\r\n  }\r\n\r\n  /**\r\n   * Invalidates the cache (call when state changes)\r\n   */\r\n  function invalidate(): void {\r\n    cachedMap = null;\r\n    cacheKey = null;\r\n  }\r\n\r\n  return {\r\n    getColumnMap,\r\n    invalidate,\r\n    buildColumnMap\r\n  };\r\n}\r\n\r\nexport type ColumnMapService = ReturnType<typeof createColumnMapService>;\r\n\r\n/**\r\n * Coordinate conversion helper functions\r\n * These can be used standalone or as part of rhythm action callbacks\r\n */\r\n\r\nexport function visualToCanvas(visualIndex: number, map: ColumnMap): number | null {\r\n  return map.visualToCanvas.get(visualIndex) ?? null;\r\n}\r\n\r\nexport function visualToTime(visualIndex: number, map: ColumnMap): number | null {\r\n  return map.visualToTime.get(visualIndex) ?? null;\r\n}\r\n\r\nexport function canvasToVisual(canvasIndex: number, map: ColumnMap): number {\r\n  const result = map.canvasToVisual.get(canvasIndex);\r\n  return result !== undefined ? result : canvasIndex + 2; // +2 fallback for left legends\r\n}\r\n\r\nexport function canvasToTime(canvasIndex: number, map: ColumnMap): number | null {\r\n  return map.canvasToTime.get(canvasIndex) ?? null;\r\n}\r\n\r\nexport function timeToCanvas(timeIndex: number, map: ColumnMap): number {\r\n  const result = map.timeToCanvas.get(timeIndex);\r\n  return result !== undefined ? result : timeIndex;\r\n}\r\n\r\nexport function timeToVisual(timeIndex: number, map: ColumnMap): number {\r\n  const result = map.timeToVisual.get(timeIndex);\r\n  return result !== undefined ? result : timeIndex + 2; // +2 fallback for left legends\r\n}\r\n\r\n/**\r\n * Gets the cumulative time boundary after a macrobeat\r\n */\r\nexport function getTimeBoundaryAfterMacrobeat(\r\n  macrobeatIndex: number,\r\n  macrobeatGroupings: number[]\r\n): number {\r\n  if (macrobeatIndex === undefined || macrobeatIndex === null) return 0;\r\n  let time = 0;\r\n  for (let i = 0; i <= macrobeatIndex && i < macrobeatGroupings.length; i++) {\r\n    const grouping = macrobeatGroupings[i];\r\n    if (typeof grouping === 'number') {\r\n      time += grouping;\r\n    }\r\n  }\r\n  return time;\r\n}\r\n\r\n/**\r\n * Column metadata queries\r\n */\r\n\r\nexport function getColumnEntry(visualIndex: number, map: ColumnMap): ColumnEntry | null {\r\n  return map.entries[visualIndex] || null;\r\n}\r\n\r\nexport function getColumnEntryByCanvas(canvasIndex: number, map: ColumnMap): ColumnEntry | null {\r\n  const visualIndex = map.canvasToVisual.get(canvasIndex);\r\n  return visualIndex !== undefined ? (map.entries[visualIndex] || null) : null;\r\n}\r\n\r\nexport function isPlayableColumn(canvasIndex: number, map: ColumnMap): boolean {\r\n  const entry = getColumnEntryByCanvas(canvasIndex, map);\r\n  return entry?.isPlayable ?? false;\r\n}\r\n\r\nexport function getColumnType(canvasIndex: number, map: ColumnMap): ColumnEntry['type'] | null {\r\n  const entry = getColumnEntryByCanvas(canvasIndex, map);\r\n  return entry?.type ?? null;\r\n}\r\n\r\n/**\r\n * Macrobeat boundary queries\r\n */\r\n\r\nexport function getMacrobeatBoundary(macrobeatIndex: number, map: ColumnMap): MacrobeatBoundary | null {\r\n  return map.macrobeatBoundaries.find(b => b.macrobeatIndex === macrobeatIndex) || null;\r\n}\r\n\r\n/**\r\n * Column width helpers\r\n */\r\n\r\nexport function getCanvasColumnWidths(map: ColumnMap): number[] {\r\n  const widths: number[] = [];\r\n\r\n  for (const entry of map.entries) {\r\n    if (entry.canvasIndex !== null) {\r\n      widths[entry.canvasIndex] = entry.widthMultiplier;\r\n    }\r\n  }\r\n\r\n  return widths;\r\n}\r\n\r\nexport function getTotalCanvasWidth(map: ColumnMap): number {\r\n  let total = 0;\r\n\r\n  for (const entry of map.entries) {\r\n    if (entry.canvasIndex !== null) {\r\n      total += entry.widthMultiplier;\r\n    }\r\n  }\r\n\r\n  return total;\r\n}\r\n","/**\n * Student Notation Engine - Public Controller API\n *\n * This is the main public interface for the engine. It provides a clean,\n * framework-agnostic API for UI components and tutorial systems to control\n * the notation editor.\n *\n * IMPORTANT: This controller does NOT depend on DOM IDs or any specific UI framework.\n * Canvas contexts and other DOM refs should be passed in during initialization.\n */\n\nimport type {\n  AppState,\n  PlacedNote,\n  NoteShape,\n  PitchRange,\n  ADSREnvelope,\n  FilterSettings,\n  LassoSelection,\n  DegreeDisplayMode,\n  PlayheadMode,\n  LongNoteStyle,\n  CanvasSpaceColumn,\n  ModulationRatio,\n  SixteenthStampPlacement,\n  TripletStampPlacement,\n} from '@mlt/types';\n\nimport { createStore, type StoreInstance, type StorageAdapter } from './state/store.js';\nimport { createColumnMapService, visualToTime, timeToVisual, getTimeBoundaryAfterMacrobeat } from './services/columnMapService.js';\nimport { renderPitchGrid, renderDrumGrid } from './canvas/index.js';\nimport type { PitchGridRenderOptions, DrumGridRenderOptions } from './canvas/index.js';\n\n/**\n * Configuration for engine initialization\n */\nexport interface EngineConfig {\n  /** Canvas context for the pitch grid */\n  pitchGridContext?: CanvasRenderingContext2D;\n  /** Canvas context for the pitch grid playhead */\n  pitchPlayheadContext?: CanvasRenderingContext2D;\n  /** Canvas context for the pitch grid hover indicator */\n  pitchHoverContext?: CanvasRenderingContext2D;\n  /** Canvas context for the drum grid */\n  drumGridContext?: CanvasRenderingContext2D;\n  /** Canvas context for the drum grid playhead */\n  drumPlayheadContext?: CanvasRenderingContext2D;\n  /** Canvas context for the drum grid hover indicator */\n  drumHoverContext?: CanvasRenderingContext2D;\n  /** Initial state (optional, for restoring saved state) */\n  initialState?: Partial<AppState>;\n  /** Storage key for localStorage persistence */\n  storageKey?: string;\n  /** Storage adapter (defaults to localStorage if available) */\n  storage?: StorageAdapter;\n  /** Enable debug logging */\n  debug?: boolean;\n}\n\n/**\n * Selection item for multi-select operations\n */\nexport interface SelectionItem {\n  type: 'note' | 'sixteenthStamp' | 'tripletStamp';\n  id: string;\n}\n\n/**\n * Event callback type\n */\nexport type EventCallback<T = unknown> = (data: T) => void;\n\n/**\n * The main engine controller interface\n */\nexport interface EngineController {\n  // ============================================================================\n  // INITIALIZATION\n  // ============================================================================\n\n  /**\n   * Initialize the engine with configuration\n   */\n  init(config: EngineConfig): void;\n\n  /**\n   * Dispose of the engine and clean up resources\n   */\n  dispose(): void;\n\n  /**\n   * Check if engine is initialized\n   */\n  isInitialized(): boolean;\n\n  // ============================================================================\n  // TOOL SELECTION\n  // ============================================================================\n\n  /**\n   * Set the current editing tool\n   */\n  setTool(tool: 'note' | 'eraser' | 'chord' | 'tonic' | 'modulation' | 'sixteenth' | 'triplet'): void;\n\n  /**\n   * Get the current tool\n   */\n  getTool(): string;\n\n  /**\n   * Set the note shape for the note tool\n   */\n  setNoteShape(shape: NoteShape): void;\n\n  /**\n   * Set the note color for the note tool\n   */\n  setNoteColor(color: string): void;\n\n  // ============================================================================\n  // NOTE MANIPULATION\n  // ============================================================================\n\n  /**\n   * Insert a new note at the specified position\n   */\n  insertNote(row: number, startColumn: number, endColumn?: number): PlacedNote | null;\n\n  /**\n   * Delete a note by ID\n   */\n  deleteNote(noteId: string): boolean;\n\n  /**\n   * Delete all selected items\n   */\n  deleteSelection(): void;\n\n  /**\n   * Move a note to a new position\n   */\n  moveNote(noteId: string, toRow: number, toColumn: number): void;\n\n  /**\n   * Update a note's tail (end column)\n   */\n  setNoteTail(noteId: string, endColumn: number): void;\n\n  /**\n   * Clear all notes\n   */\n  clearAllNotes(): void;\n\n  // ============================================================================\n  // SELECTION\n  // ============================================================================\n\n  /**\n   * Set the current selection\n   */\n  setSelection(items: SelectionItem[]): void;\n\n  /**\n   * Clear the current selection\n   */\n  clearSelection(): void;\n\n  /**\n   * Select all items\n   */\n  selectAll(): void;\n\n  /**\n   * Get current selection\n   */\n  getSelection(): LassoSelection;\n\n  /**\n   * Check if there's an active selection\n   */\n  hasSelection(): boolean;\n\n  // ============================================================================\n  // PLAYBACK\n  // ============================================================================\n\n  /**\n   * Start playback from the beginning\n   */\n  play(): void;\n\n  /**\n   * Pause playback\n   */\n  pause(): void;\n\n  /**\n   * Resume paused playback\n   */\n  resume(): void;\n\n  /**\n   * Stop playback and reset to beginning\n   */\n  stop(): void;\n\n  /**\n   * Check if currently playing\n   */\n  isPlaying(): boolean;\n\n  /**\n   * Check if currently paused\n   */\n  isPaused(): boolean;\n\n  /**\n   * Set the tempo in BPM\n   */\n  setTempo(bpm: number): void;\n\n  /**\n   * Get the current tempo\n   */\n  getTempo(): number;\n\n  /**\n   * Enable or disable looping\n   */\n  setLooping(enabled: boolean): void;\n\n  /**\n   * Check if looping is enabled\n   */\n  isLooping(): boolean;\n\n  /**\n   * Set the playhead visualization mode\n   */\n  setPlayheadMode(mode: PlayheadMode): void;\n\n  // ============================================================================\n  // HISTORY\n  // ============================================================================\n\n  /**\n   * Undo the last action\n   */\n  undo(): void;\n\n  /**\n   * Redo the last undone action\n   */\n  redo(): void;\n\n  /**\n   * Check if undo is available\n   */\n  canUndo(): boolean;\n\n  /**\n   * Check if redo is available\n   */\n  canRedo(): boolean;\n\n  /**\n   * Record current state for undo\n   */\n  recordState(): void;\n\n  // ============================================================================\n  // RHYTHM STRUCTURE\n  // ============================================================================\n\n  /**\n   * Add a macrobeat to the end\n   */\n  addMacrobeat(): void;\n\n  /**\n   * Remove the last macrobeat\n   */\n  removeMacrobeat(): void;\n\n  /**\n   * Set the grouping for a specific macrobeat\n   */\n  setMacrobeatGrouping(index: number, grouping: 2 | 3): void;\n\n  /**\n   * Toggle anacrusis (pickup measure)\n   */\n  toggleAnacrusis(): void;\n\n  /**\n   * Add a modulation marker\n   */\n  addModulationMarker(measureIndex: number, ratio: ModulationRatio): string | null;\n\n  /**\n   * Remove a modulation marker\n   */\n  removeModulationMarker(markerId: string): void;\n\n  // ============================================================================\n  // VIEW\n  // ============================================================================\n\n  /**\n   * Set the visible pitch range\n   */\n  setPitchRange(topIndex: number, bottomIndex: number): void;\n\n  /**\n   * Get the current pitch range\n   */\n  getPitchRange(): PitchRange;\n\n  /**\n   * Set degree display mode\n   */\n  setDegreeDisplayMode(mode: DegreeDisplayMode): void;\n\n  /**\n   * Set the long note rendering style\n   */\n  setLongNoteStyle(style: LongNoteStyle): void;\n\n  // ============================================================================\n  // TIMBRE\n  // ============================================================================\n\n  /**\n   * Set ADSR envelope for a timbre\n   */\n  setTimbreADSR(color: string, adsr: Partial<ADSREnvelope>): void;\n\n  /**\n   * Set harmonic coefficients for a timbre\n   */\n  setTimbreHarmonics(color: string, coeffs: number[]): void;\n\n  /**\n   * Set filter settings for a timbre\n   */\n  setTimbreFilter(color: string, settings: Partial<FilterSettings>): void;\n\n  // ============================================================================\n  // STATE ACCESS\n  // ============================================================================\n\n  /**\n   * Get a readonly snapshot of the current state\n   */\n  getState(): Readonly<AppState>;\n\n  /**\n   * Get all placed notes\n   */\n  getNotes(): readonly PlacedNote[];\n\n  /**\n   * Get a note at a specific position\n   */\n  getNoteAt(row: number, column: number): PlacedNote | null;\n\n  /**\n   * Get all sixteenth stamp placements\n   */\n  getSixteenthStamps(): readonly SixteenthStampPlacement[];\n\n  /**\n   * Get all triplet stamp placements\n   */\n  getTripletStamps(): readonly TripletStampPlacement[];\n\n  // ============================================================================\n  // IMPORT/EXPORT\n  // ============================================================================\n\n  /**\n   * Export the current score as CSV\n   */\n  exportCSV(): string;\n\n  /**\n   * Import a score from CSV\n   */\n  importCSV(csv: string): void;\n\n  /**\n   * Export the complete state as JSON\n   */\n  exportState(): string;\n\n  /**\n   * Import state from JSON\n   */\n  importState(json: string): void;\n\n  // ============================================================================\n  // EVENTS\n  // ============================================================================\n\n  /**\n   * Subscribe to an engine event\n   */\n  on(event: string, callback: EventCallback): void;\n\n  /**\n   * Unsubscribe from an engine event\n   */\n  off(event: string, callback: EventCallback): void;\n\n  // ============================================================================\n  // RENDERING\n  // ============================================================================\n\n  /**\n   * Request a re-render of all canvases\n   */\n  render(): void;\n\n  /**\n   * Request a re-render of the pitch grid only\n   */\n  renderPitchGrid(): void;\n\n  /**\n   * Request a re-render of the drum grid only\n   */\n  renderDrumGrid(): void;\n}\n\n/**\n * Lesson mode API for tutorials\n */\nexport interface LessonModeAPI {\n  /**\n   * Set which actions are allowed (whitelist)\n   */\n  setAllowedActions(actions: string[]): void;\n\n  /**\n   * Set which actions are blocked (blacklist)\n   */\n  setBlockedActions(actions: string[]): void;\n\n  /**\n   * Clear all action restrictions\n   */\n  clearActionRestrictions(): void;\n\n  /**\n   * Highlight a UI target for the user\n   */\n  highlightTarget(target: HighlightTarget): void;\n\n  /**\n   * Clear all highlights\n   */\n  clearHighlights(): void;\n\n  /**\n   * Wait for a specific action to be performed\n   */\n  waitForAction(action: string, timeout?: number): Promise<ActionEvent>;\n\n  /**\n   * Wait for state to match a condition\n   */\n  waitForState(predicate: (state: AppState) => boolean): Promise<void>;\n\n  /**\n   * Intercept and optionally block actions\n   */\n  onAction(action: string, handler: ActionHandler): () => void;\n}\n\n/**\n * Target for visual highlighting\n */\nexport type HighlightTarget =\n  | { type: 'tool'; id: string }\n  | { type: 'button'; id: string }\n  | { type: 'cell'; row: number; column: number }\n  | { type: 'note'; noteId: string }\n  | { type: 'region'; x: number; y: number; width: number; height: number };\n\n/**\n * Action event for interception\n */\nexport interface ActionEvent {\n  action: string;\n  args: unknown[];\n  timestamp: number;\n}\n\n/**\n * Action handler that can block actions\n */\nexport type ActionHandler = (event: ActionEvent) => boolean | void | Promise<boolean | void>;\n\n/**\n * Create a new engine controller instance\n */\nexport function createEngineController(): EngineController {\n  let initialized = false;\n  let store: StoreInstance | null = null;\n  let columnMapService: ReturnType<typeof createColumnMapService> | null = null;\n\n  // Canvas contexts\n  let pitchGridContext: CanvasRenderingContext2D | null = null;\n  let drumGridContext: CanvasRenderingContext2D | null = null;\n\n  // Debug flag\n  let debugMode = false;\n\n  // Logger function\n  const log = (level: 'debug' | 'info' | 'warn' | 'error', context: string, message: string, data?: unknown, category?: string) => {\n    if (!debugMode && level === 'debug') return;\n    const prefix = `[${category || 'engine'}:${context}]`;\n    console[level](prefix, message, data || '');\n  };\n\n  // Wrapper for callback-compatible log (level, message, data) format\n  const callbackLog = (level: 'debug' | 'info' | 'warn' | 'error', message: string, data?: unknown) => {\n    log(level, 'controller', message, data);\n  };\n\n  const controller: EngineController = {\n    // ============================================================================\n    // INITIALIZATION\n    // ============================================================================\n\n    init(config: EngineConfig): void {\n      if (initialized) {\n        log('warn', 'controller', 'Engine already initialized');\n        return;\n      }\n\n      debugMode = config.debug || false;\n      log('info', 'controller', 'Initializing engine');\n\n      // Store canvas contexts\n      pitchGridContext = config.pitchGridContext || null;\n      drumGridContext = config.drumGridContext || null;\n\n      // Create column map service\n      columnMapService = createColumnMapService({\n        getPlacedTonicSigns: (state) => {\n          if (!store) return [];\n          const signs = [];\n          for (const group of Object.values(state.tonicSignGroups || {})) {\n            signs.push(...group);\n          }\n          return signs;\n        }\n      });\n\n      // Get storage adapter (use localStorage if available and no custom adapter provided)\n      let storage: StorageAdapter | undefined = config.storage;\n      if (!storage && typeof window !== 'undefined' && window.localStorage) {\n        storage = window.localStorage;\n      }\n\n      // Create store with all callbacks\n      store = createStore({\n        storageKey: config.storageKey || 'studentNotationState',\n        storage,\n        initialState: config.initialState,\n        noteActionCallbacks: {\n          log: callbackLog\n        },\n        rhythmActionCallbacks: {\n          getColumnMap: (state) => columnMapService!.getColumnMap(state),\n          visualToTimeIndex: (state, visualIndex, groupings) =>\n            visualToTime(visualIndex, columnMapService!.getColumnMap(state)),\n          timeIndexToVisualColumn: (state, timeIndex, groupings) =>\n            timeToVisual(timeIndex, columnMapService!.getColumnMap(state)),\n          getTimeBoundaryAfterMacrobeat: (state, index, groupings) =>\n            getTimeBoundaryAfterMacrobeat(index, groupings),\n          log: callbackLog\n        },\n        sixteenthStampActionCallbacks: {\n          log: callbackLog\n        },\n        tripletStampActionCallbacks: {\n          canvasToTime: (canvasIndex, map) => {\n            return map.canvasToTime.get(canvasIndex) ?? null;\n          },\n          timeToCanvas: (timeIndex, map) => {\n            return map.timeToCanvas.get(timeIndex) ?? 0;\n          },\n          getColumnMap: (state) => columnMapService!.getColumnMap(state),\n          log: callbackLog\n        }\n      });\n\n      // Subscribe to state changes to invalidate column map cache\n      store.on('rhythmStructureChanged', () => {\n        columnMapService?.invalidate();\n      });\n\n      store.on('notesChanged', () => {\n        this.renderPitchGrid();\n      });\n\n      store.on('sixteenthStampPlacementsChanged', () => {\n        this.renderDrumGrid();\n      });\n\n      store.on('tripletStampPlacementsChanged', () => {\n        this.renderDrumGrid();\n      });\n\n      initialized = true;\n      log('info', 'controller', 'Engine initialized successfully');\n\n      // Initial render if canvases provided\n      if (pitchGridContext || drumGridContext) {\n        this.render();\n      }\n    },\n\n    dispose(): void {\n      if (!initialized) return;\n\n      log('info', 'controller', 'Disposing engine');\n\n      if (store) {\n        store.dispose();\n        store = null;\n      }\n\n      columnMapService = null;\n      pitchGridContext = null;\n      drumGridContext = null;\n      initialized = false;\n    },\n\n    isInitialized(): boolean {\n      return initialized;\n    },\n\n    // ============================================================================\n    // TOOL SELECTION\n    // ============================================================================\n\n    setTool(tool: string): void {\n      if (!store) return;\n      store.setSelectedTool(tool);\n    },\n\n    getTool(): string {\n      return store?.state.selectedTool || 'note';\n    },\n\n    setNoteShape(shape: NoteShape): void {\n      if (!store) return;\n      const currentColor = store.state.selectedNote.color;\n      store.setSelectedNote(shape, currentColor);\n    },\n\n    setNoteColor(color: string): void {\n      if (!store) return;\n      const currentShape = store.state.selectedNote.shape as NoteShape;\n      store.setSelectedNote(currentShape, color);\n    },\n\n    // ============================================================================\n    // NOTE MANIPULATION\n    // ============================================================================\n\n    insertNote(row: number, startColumn: number, endColumn?: number): PlacedNote | null {\n      if (!store) return null;\n\n      const note: Partial<PlacedNote> = {\n        row,\n        startColumnIndex: startColumn as CanvasSpaceColumn,\n        endColumnIndex: (endColumn ?? startColumn) as CanvasSpaceColumn,\n        shape: store.state.selectedNote.shape as NoteShape,\n        color: store.state.selectedNote.color\n      };\n\n      return store.addNote(note);\n    },\n\n    deleteNote(noteId: string): boolean {\n      if (!store) return false;\n\n      const note = store.state.placedNotes.find(n => n.uuid === noteId);\n      if (!note) return false;\n\n      store.removeNote(note);\n      return true;\n    },\n\n    deleteSelection(): void {\n      if (!store) return;\n\n      const selection = store.state.lassoSelection;\n      if (!selection.isActive || selection.selectedItems.length === 0) return;\n\n      const notesToDelete = selection.selectedItems\n        .filter(item => item.type === 'note')\n        .map(item => store!.state.placedNotes.find(n => n.uuid === item.id))\n        .filter(n => n !== undefined) as PlacedNote[];\n\n      if (notesToDelete.length > 0) {\n        store.removeMultipleNotes(notesToDelete);\n      }\n\n      // Clear selection after delete\n      this.clearSelection();\n    },\n\n    moveNote(noteId: string, toRow: number, toColumn: number): void {\n      if (!store) return;\n\n      const note = store.state.placedNotes.find(n => n.uuid === noteId);\n      if (!note) return;\n\n      store.updateNoteRow(note, toRow);\n      store.updateNotePosition(note, toColumn as CanvasSpaceColumn);\n    },\n\n    setNoteTail(noteId: string, endColumn: number): void {\n      if (!store) return;\n\n      const note = store.state.placedNotes.find(n => n.uuid === noteId);\n      if (!note) return;\n\n      store.updateNoteTail(note, endColumn as CanvasSpaceColumn);\n    },\n\n    clearAllNotes(): void {\n      if (!store) return;\n      store.clearAllNotes();\n    },\n\n    // ============================================================================\n    // SELECTION\n    // ============================================================================\n\n    setSelection(items: SelectionItem[]): void {\n      if (!store) return;\n\n      // Convert to LassoSelection format - need to include full data\n      const selectedItems: LassoSelection['selectedItems'] = items\n        .map(item => {\n          if (item.type === 'note') {\n            const note = store!.state.placedNotes.find(n => n.uuid === item.id);\n            if (!note) return null;\n            return { type: 'note' as const, id: item.id, data: note };\n          } else if (item.type === 'sixteenthStamp') {\n            const stamp = store!.state.sixteenthStampPlacements.find(s => s.id === item.id);\n            if (!stamp) return null;\n            return { type: 'sixteenthStamp' as const, id: item.id, data: stamp };\n          } else if (item.type === 'tripletStamp') {\n            const stamp = store!.state.tripletStampPlacements.find(s => s.id === item.id);\n            if (!stamp) return null;\n            return { type: 'tripletStamp' as const, id: item.id, data: stamp };\n          }\n          return null;\n        })\n        .filter((item): item is NonNullable<typeof item> => item !== null);\n\n      store.state.lassoSelection = {\n        isActive: selectedItems.length > 0,\n        selectedItems,\n        convexHull: [] // Would need to calculate from note positions\n      };\n\n      store.emit('selectionChanged', store.state.lassoSelection);\n    },\n\n    clearSelection(): void {\n      if (!store) return;\n\n      store.state.lassoSelection = {\n        isActive: false,\n        selectedItems: [],\n        convexHull: []\n      };\n\n      store.emit('selectionChanged', store.state.lassoSelection);\n    },\n\n    selectAll(): void {\n      if (!store) return;\n\n      const items: LassoSelection['selectedItems'] = store.state.placedNotes.map(note => ({\n        type: 'note' as const,\n        id: note.uuid,\n        data: note\n      }));\n\n      store.state.lassoSelection = {\n        isActive: items.length > 0,\n        selectedItems: items,\n        convexHull: []\n      };\n\n      store.emit('selectionChanged', store.state.lassoSelection);\n    },\n\n    getSelection(): LassoSelection {\n      return store?.state.lassoSelection || { isActive: false, selectedItems: [], convexHull: [] };\n    },\n\n    hasSelection(): boolean {\n      return store?.state.lassoSelection.isActive && store.state.lassoSelection.selectedItems.length > 0 || false;\n    },\n\n    // ============================================================================\n    // PLAYBACK\n    // ============================================================================\n\n    play(): void {\n      if (!store) return;\n      store.setPlaybackState(true, false);\n      log('info', 'playback', 'Play started');\n    },\n\n    pause(): void {\n      if (!store) return;\n      store.setPlaybackState(true, true);\n      log('info', 'playback', 'Paused');\n    },\n\n    resume(): void {\n      if (!store) return;\n      store.setPlaybackState(true, false);\n      log('info', 'playback', 'Resumed');\n    },\n\n    stop(): void {\n      if (!store) return;\n      store.setPlaybackState(false, false);\n      log('info', 'playback', 'Stopped');\n    },\n\n    isPlaying(): boolean {\n      return store?.state.isPlaying || false;\n    },\n\n    isPaused(): boolean {\n      return store?.state.isPaused || false;\n    },\n\n    setTempo(bpm: number): void {\n      if (!store) return;\n      store.setTempo(bpm);\n    },\n\n    getTempo(): number {\n      return store?.state.tempo || 120;\n    },\n\n    setLooping(enabled: boolean): void {\n      if (!store) return;\n      store.setLooping(enabled);\n    },\n\n    isLooping(): boolean {\n      return store?.state.isLooping || false;\n    },\n\n    setPlayheadMode(mode: PlayheadMode): void {\n      if (!store) return;\n      store.setPlayheadMode(mode);\n    },\n\n    // ============================================================================\n    // HISTORY\n    // ============================================================================\n\n    undo(): void {\n      if (!store) return;\n      store.undo();\n    },\n\n    redo(): void {\n      if (!store) return;\n      store.redo();\n    },\n\n    canUndo(): boolean {\n      return (store?.state.historyIndex || 0) > 0;\n    },\n\n    canRedo(): boolean {\n      return (store?.state.historyIndex || 0) < (store?.state.history.length || 0) - 1;\n    },\n\n    recordState(): void {\n      if (!store) return;\n      store.recordState();\n    },\n\n    // ============================================================================\n    // RHYTHM STRUCTURE\n    // ============================================================================\n\n    addMacrobeat(): void {\n      if (!store) return;\n      store.increaseMacrobeatCount();\n    },\n\n    removeMacrobeat(): void {\n      if (!store) return;\n      store.decreaseMacrobeatCount();\n    },\n\n    setMacrobeatGrouping(index: number, grouping: 2 | 3): void {\n      if (!store) return;\n\n      const current = store.state.macrobeatGroupings[index];\n      if (current !== grouping) {\n        store.toggleMacrobeatGrouping(index);\n      }\n    },\n\n    toggleAnacrusis(): void {\n      if (!store) return;\n      store.setAnacrusis(!store.state.hasAnacrusis);\n    },\n\n    addModulationMarker(measureIndex: number, ratio: ModulationRatio): string | null {\n      if (!store) return null;\n      return store.addModulationMarker(measureIndex, ratio);\n    },\n\n    removeModulationMarker(markerId: string): void {\n      if (!store) return;\n      store.removeModulationMarker(markerId);\n    },\n\n    // ============================================================================\n    // VIEW\n    // ============================================================================\n\n    setPitchRange(topIndex: number, bottomIndex: number): void {\n      if (!store) return;\n      store.setPitchRange({ topIndex, bottomIndex });\n    },\n\n    getPitchRange(): PitchRange {\n      return store?.state.pitchRange || { topIndex: 0, bottomIndex: 87 };\n    },\n\n    setDegreeDisplayMode(mode: DegreeDisplayMode): void {\n      if (!store) return;\n      store.setDegreeDisplayMode(mode);\n    },\n\n    setLongNoteStyle(style: LongNoteStyle): void {\n      if (!store) return;\n      store.setLongNoteStyle(style);\n    },\n\n    // ============================================================================\n    // TIMBRE\n    // ============================================================================\n\n    setTimbreADSR(color: string, adsr: Partial<ADSREnvelope>): void {\n      if (!store) return;\n      store.setADSR(color, adsr);\n    },\n\n    setTimbreHarmonics(color: string, coeffs: number[]): void {\n      if (!store) return;\n      store.setHarmonicCoefficients(color, new Float32Array(coeffs));\n    },\n\n    setTimbreFilter(color: string, settings: Partial<FilterSettings>): void {\n      if (!store) return;\n      store.setFilterSettings(color, settings);\n    },\n\n    // ============================================================================\n    // STATE ACCESS\n    // ============================================================================\n\n    getState(): Readonly<AppState> {\n      if (!store) {\n        throw new Error('Engine not initialized');\n      }\n      return store.state;\n    },\n\n    getNotes(): readonly PlacedNote[] {\n      return store?.state.placedNotes || [];\n    },\n\n    getNoteAt(row: number, column: number): PlacedNote | null {\n      if (!store) return null;\n\n      return store.state.placedNotes.find(\n        note => note.row === row &&\n                note.startColumnIndex <= column &&\n                note.endColumnIndex >= column\n      ) || null;\n    },\n\n    getSixteenthStamps(): readonly SixteenthStampPlacement[] {\n      return store?.state.sixteenthStampPlacements || [];\n    },\n\n    getTripletStamps(): readonly TripletStampPlacement[] {\n      return store?.state.tripletStampPlacements || [];\n    },\n\n    // ============================================================================\n    // IMPORT/EXPORT\n    // ============================================================================\n\n    exportCSV(): string {\n      if (!store) return '';\n\n      const header = 'uuid,row,startColumn,endColumn,color,shape';\n      const rows = store.state.placedNotes.map(n =>\n        `${n.uuid},${n.row},${n.startColumnIndex},${n.endColumnIndex},${n.color},${n.shape}`\n      );\n      return [header, ...rows].join('\\n');\n    },\n\n    importCSV(csv: string): void {\n      if (!store) return;\n\n      const lines = csv.split('\\n').filter(line => line.trim());\n      if (lines.length === 0) return;\n\n      // Skip header\n      const dataLines = lines.slice(1);\n\n      const notes: Partial<PlacedNote>[] = dataLines.map(line => {\n        const [uuid, row, startColumn, endColumn, color, shape] = line.split(',');\n        return {\n          uuid,\n          row: parseInt(row || '0', 10),\n          startColumnIndex: parseInt(startColumn || '0', 10) as CanvasSpaceColumn,\n          endColumnIndex: parseInt(endColumn || '0', 10) as CanvasSpaceColumn,\n          color: color || 'blue',\n          shape: (shape || 'circle') as NoteShape\n        };\n      });\n\n      store.loadNotes(notes);\n    },\n\n    exportState(): string {\n      if (!store) return '{}';\n      return JSON.stringify(store.state, null, 2);\n    },\n\n    importState(json: string): void {\n      if (!store) return;\n\n      try {\n        const state = JSON.parse(json);\n        Object.assign(store.state, state);\n        store.emit('stateImported', state);\n        this.render();\n      } catch (error) {\n        log('error', 'import', 'Failed to import state', error);\n      }\n    },\n\n    // ============================================================================\n    // EVENTS\n    // ============================================================================\n\n    on(event: string, callback: EventCallback): void {\n      if (!store) return;\n      store.on(event, callback);\n    },\n\n    off(event: string, callback: EventCallback): void {\n      if (!store) return;\n      store.off(event, callback);\n    },\n\n    // ============================================================================\n    // RENDERING\n    // ============================================================================\n\n    render(): void {\n      this.renderPitchGrid();\n      this.renderDrumGrid();\n    },\n\n    renderPitchGrid(): void {\n      if (!pitchGridContext || !store || !columnMapService) return;\n      // TODO: Canvas rendering requires more complex setup with viewport info and coordinate utilities\n      // For now, this is a placeholder - apps should use the app's existing renderers\n      log('debug', 'controller', 'renderPitchGrid called - canvas rendering not yet wired');\n    },\n\n    renderDrumGrid(): void {\n      if (!drumGridContext || !store || !columnMapService) return;\n      // TODO: Canvas rendering requires more complex setup with coordinate utilities\n      // For now, this is a placeholder - apps should use the app's existing renderers\n      log('debug', 'controller', 'renderDrumGrid called - canvas rendering not yet wired');\n    }\n  };\n\n  return controller;\n}\n\n/**\n * Create a lesson mode API wrapper around an engine controller\n */\nexport function createLessonMode(_engine: EngineController): LessonModeAPI {\n  // This will be implemented in Phase 6 - Tutorial App\n  throw new Error('Not yet implemented - will be in @mlt/tutorial-runtime package');\n}\n","/**\n * Filtered Voice\n *\n * A custom Tone.js synth voice with:\n * - Multi-mode filter (HP/BP/LP with crossfade blend)\n * - Vibrato (frequency modulation via LFO)\n * - Tremolo (amplitude modulation via LFO)\n * - Preset gain control\n *\n * Framework-agnostic - no DOM dependencies.\n */\nimport * as Tone from 'tone';\n\nexport interface FilteredVoiceOptions extends Tone.SynthOptions {\n  filter?: FilterParams;\n  vibrato?: VibratoParams;\n  tremelo?: TremoloParams;  // Note: 'tremelo' spelling for consistency with existing code\n  gain?: number;\n}\n\nexport interface FilterParams {\n  enabled: boolean;\n  cutoff: number;      // MIDI note number offset\n  resonance: number;   // 0-100\n  blend: number;       // 0-2: 0=HP, 1=BP, 2=LP\n}\n\nexport interface VibratoParams {\n  speed: number;  // 0-100\n  span: number;   // 0-100\n}\n\nexport interface TremoloParams {\n  speed: number;  // 0-100\n  span: number;   // 0-100\n}\n\n/**\n * Optional logger interface for debug output.\n * If not provided, logging is silently skipped.\n */\nexport interface VoiceLogger {\n  debug(category: string, message: string, data?: unknown, context?: string): void;\n}\n\n// Module-level logger that can be set\nlet voiceLogger: VoiceLogger | null = null;\n\n/**\n * Set the logger for FilteredVoice instances.\n * Call this once during initialization if you want debug logging.\n */\nexport function setVoiceLogger(logger: VoiceLogger | null): void {\n  voiceLogger = logger;\n}\n\n/**\n * A custom synth voice with a sophisticated series/parallel filter blend.\n */\nexport class FilteredVoice extends Tone.Synth {\n  // Audio effect nodes\n  presetGain!: Tone.Gain;\n  vibratoLFO!: Tone.LFO;\n  vibratoDepth!: Tone.Scale;\n  vibratoGain!: Tone.Gain;\n  tremoloLFO!: Tone.LFO;\n  tremoloDepth!: Tone.Scale;\n  tremoloGain!: Tone.Gain;\n\n  // Filter nodes\n  hpFilter!: Tone.Filter;\n  lpFilterForBP!: Tone.Filter;\n  lpFilterSolo!: Tone.Filter;\n\n  // Output nodes\n  hpOutput!: Tone.Gain;\n  bpOutput!: Tone.Gain;\n  lpOutput!: Tone.Gain;\n\n  // Crossfade nodes\n  hp_bp_fade!: Tone.CrossFade;\n  main_fade!: Tone.CrossFade;\n  wetDryFade!: Tone.CrossFade;\n\n  constructor(options: FilteredVoiceOptions) {\n    super(options);\n\n    // --- Create all necessary audio nodes ---\n    this.presetGain = new Tone.Gain(options.gain || 1.0);\n\n    // --- Vibrato LFO and frequency modulation ---\n    this.vibratoLFO = new Tone.LFO(0, 0);\n    this.vibratoDepth = new Tone.Scale(-1, 1);\n    this.vibratoGain = new Tone.Gain(0);\n\n    // Connect vibrato chain: LFO -> Scale -> Gain -> Oscillator frequency\n    this.vibratoLFO.connect(this.vibratoDepth);\n    this.vibratoDepth.connect(this.vibratoGain);\n    this.vibratoGain.connect(this.oscillator.frequency);\n\n    // --- Tremolo LFO and amplitude modulation ---\n    this.tremoloLFO = new Tone.LFO(0, 0);\n    this.tremoloDepth = new Tone.Scale(0, 1);\n    this.tremoloGain = new Tone.Gain(1);\n\n    // Connect tremolo chain: LFO -> Scale -> Gain\n    this.tremoloLFO.connect(this.tremoloDepth);\n    this.tremoloDepth.connect(this.tremoloGain.gain);\n\n    // Filters for the three distinct paths\n    this.hpFilter = new Tone.Filter({ type: 'highpass' });\n    this.lpFilterForBP = new Tone.Filter({ type: 'lowpass' });\n    this.lpFilterSolo = new Tone.Filter({ type: 'lowpass' });\n\n    // Gain nodes to tap the audio from different points in the chain\n    this.hpOutput = new Tone.Gain();\n    this.bpOutput = new Tone.Gain();\n    this.lpOutput = new Tone.Gain();\n\n    // Cross-faders to blend between the three outputs\n    this.hp_bp_fade = new Tone.CrossFade(0);\n    this.main_fade = new Tone.CrossFade(0);\n\n    // Wet/Dry control for filter bypass\n    this.wetDryFade = new Tone.CrossFade(0);\n\n    // --- Audio Routing ---\n    // 1. Oscillator -> Preset Gain Node\n    this.oscillator.connect(this.presetGain);\n\n    // 2. Preset Gain -> Dry Path & Wet Path (start)\n    this.presetGain.connect(this.wetDryFade.a); // Dry Path\n\n    // 3. Setup Wet Path (now fed from presetGain)\n    // A) High-Pass path\n    this.presetGain.connect(this.hpFilter);\n    this.hpFilter.connect(this.hpOutput);\n\n    // B) Band-Pass path (HPF -> LPF in series)\n    this.hpFilter.connect(this.lpFilterForBP);\n    this.lpFilterForBP.connect(this.bpOutput);\n\n    // C) Low-Pass path (a separate, parallel LPF)\n    this.presetGain.connect(this.lpFilterSolo);\n    this.lpFilterSolo.connect(this.lpOutput);\n\n    // 4. Route the three paths into the blender\n    this.hpOutput.connect(this.hp_bp_fade.a);\n    this.bpOutput.connect(this.hp_bp_fade.b);\n    this.lpOutput.connect(this.main_fade.b);\n    this.hp_bp_fade.connect(this.main_fade.a);\n\n    // 5. Connect the blended (wet) signal to the wet/dry fader\n    this.main_fade.connect(this.wetDryFade.b);\n\n    // 6. Apply tremolo gain to the signal before the envelope\n    this.wetDryFade.connect(this.tremoloGain);\n\n    // 7. Final output goes to the main amplitude envelope\n    this.tremoloGain.connect(this.envelope);\n\n    if (options.filter) {\n      this._setFilter(options.filter);\n    }\n\n    if (options.vibrato) {\n      this._setVibrato(options.vibrato);\n    } else {\n      this._setVibrato({ speed: 0, span: 0 });\n    }\n\n    if (options.tremelo) {\n      this._setTremolo(options.tremelo);\n    } else {\n      this._setTremolo({ speed: 0, span: 0 });\n    }\n  }\n\n  _setPresetGain(value: number): void {\n    if (this.presetGain) {\n      this.presetGain.gain.value = value;\n    }\n  }\n\n  _setVibrato(params: VibratoParams, time = Tone.now()): void {\n    if (!this.vibratoLFO || !this.vibratoGain) return;\n\n    // Convert 0-100% speed to 0-16 Hz (linear mapping)\n    const speedHz = (params.speed / 100) * 16;\n    const rawContextState = ((Tone.getContext() as any)?.rawContext?.state ?? Tone.context.state) as string;\n    const isAudioRunning = rawContextState === 'running';\n\n    // If speed is 0 or span is 0, disable vibrato completely\n    if (params.speed === 0 || params.span === 0) {\n      if (isAudioRunning && this.vibratoLFO.state === 'started') {\n        this.vibratoLFO.stop(time);\n      }\n      this.vibratoLFO.frequency.value = 0;\n      this.vibratoGain.gain.value = 0;\n      return;\n    }\n\n    // Start LFO if it was stopped\n    if (isAudioRunning && this.vibratoLFO.state !== 'started') {\n      this.vibratoLFO.start(time);\n    }\n\n    this.vibratoLFO.frequency.value = speedHz;\n\n    // Convert 0-100% span to proper Hz deviation\n    // 100% span = ±50 cents maximum deviation\n    const maxCents = 50;\n    const centsAmplitude = (params.span / 100) * maxCents;\n\n    // Convert cents to Hz deviation for frequency modulation\n    const centRatio = centsAmplitude / 1200;\n    const hzDeviationFactor = Math.pow(2, centRatio) - 1;\n\n    // For vibrato, we need a reasonable Hz range. Using 440Hz as reference\n    const referenceFreq = 440;\n    const hzDeviation = referenceFreq * hzDeviationFactor;\n\n    this.vibratoGain.gain.value = hzDeviation;\n    voiceLogger?.debug('FilteredVoice', 'Vibrato gain set', { hzDeviation, centsAmplitude }, 'audio');\n  }\n\n  _setTremolo(params: TremoloParams, time = Tone.now()): void {\n    if (!this.tremoloLFO || !this.tremoloGain) return;\n\n    // Convert 0-100% speed to 0-16 Hz (linear mapping)\n    const speedHz = (params.speed / 100) * 16;\n    const rawContextState = ((Tone.getContext() as any)?.rawContext?.state ?? Tone.context.state) as string;\n    const isAudioRunning = rawContextState === 'running';\n\n    // If speed is 0 or span is 0, disable tremolo completely\n    if (params.speed === 0 || params.span === 0) {\n      if (isAudioRunning && this.tremoloLFO.state === 'started') {\n        this.tremoloLFO.stop(time);\n      }\n      this.tremoloLFO.frequency.value = 0;\n      this.tremoloGain.gain.cancelScheduledValues(time);\n      this.tremoloGain.gain.value = 1.0;\n      return;\n    }\n\n    // Start LFO if it was stopped\n    if (isAudioRunning && this.tremoloLFO.state !== 'started') {\n      this.tremoloLFO.start(time);\n    }\n\n    this.tremoloLFO.frequency.value = speedHz;\n\n    // Convert 0-100% span to amplitude modulation depth\n    const spanAmount = params.span / 100;\n\n    // Set tremolo depth scale to modulate from (1 - span) to 1.0\n    const minGain = Math.max(0, 1 - spanAmount);\n    const maxGain = 1.0;\n\n    this.tremoloDepth.min = minGain;\n    this.tremoloDepth.max = maxGain;\n  }\n\n  _setFilter(params: FilterParams): void {\n    this.wetDryFade.fade.value = params.enabled ? 1 : 0;\n\n    const freq = Tone.Midi(params.cutoff + 35).toFrequency();\n    const q = (params.resonance / 100) * 12 + 0.1;\n\n    // Set parameters on all three filters\n    this.hpFilter.set({ frequency: freq, Q: q });\n    this.lpFilterForBP.set({ frequency: freq, Q: q });\n    this.lpFilterSolo.set({ frequency: freq, Q: q });\n\n    const blend = params.blend;\n\n    // Blend from HP (0) -> BP (1)\n    if (blend <= 1.0) {\n      this.main_fade.fade.value = 0;\n      this.hp_bp_fade.fade.value = blend;\n    }\n    // Blend from BP (1) -> LP (2)\n    else {\n      this.main_fade.fade.value = blend - 1.0;\n      this.hp_bp_fade.fade.value = 1.0;\n    }\n  }\n}\n","/**\n * Gain Manager\n *\n * Handles polyphony-aware gain scaling for the synth engine.\n * Smoothly adjusts master gain based on active voice count to\n * maintain consistent perceived volume levels.\n */\nimport * as Tone from 'tone';\n\nexport interface GainManagerOptions {\n  polyphonyReference?: number;\n  smoothingTauMs?: number;\n  masterGainRampMs?: number;\n  gainUpdateIntervalMs?: number;\n}\n\nexport const DEFAULT_GAIN_MANAGER_OPTIONS: Required<GainManagerOptions> = {\n  polyphonyReference: 32,\n  smoothingTauMs: 200,\n  masterGainRampMs: 50,\n  gainUpdateIntervalMs: 16\n};\n\nexport function getPerVoiceBaselineGain(polyphonyReference = DEFAULT_GAIN_MANAGER_OPTIONS.polyphonyReference): number {\n  return 1.0 / Math.sqrt(polyphonyReference);\n}\n\nexport class GainManager {\n  private readonly masterGain: Tone.Gain;\n  private readonly options: Required<GainManagerOptions>;\n  private readonly perVoiceBaselineGain: number;\n\n  private activeVoiceCount = 0;\n  private smoothedVoiceCount: number;\n  private gainUpdateLoopId: ReturnType<typeof setInterval> | null = null;\n\n  constructor(masterGain: Tone.Gain, options: GainManagerOptions = {}) {\n    this.masterGain = masterGain;\n    this.options = { ...DEFAULT_GAIN_MANAGER_OPTIONS, ...options };\n    this.perVoiceBaselineGain = getPerVoiceBaselineGain(this.options.polyphonyReference);\n    this.smoothedVoiceCount = this.options.polyphonyReference;\n  }\n\n  start(): void {\n    this.stop();\n    this.gainUpdateLoopId = setInterval(() => this.updateMasterGain(), this.options.gainUpdateIntervalMs);\n  }\n\n  stop(): void {\n    if (this.gainUpdateLoopId === null) {\n      return;\n    }\n    clearInterval(this.gainUpdateLoopId);\n    this.gainUpdateLoopId = null;\n  }\n\n  noteOn(voiceCount = 1): void {\n    if (voiceCount <= 0) {\n      return;\n    }\n    this.activeVoiceCount += voiceCount;\n  }\n\n  noteOff(voiceCount = 1): void {\n    if (voiceCount <= 0) {\n      return;\n    }\n    this.activeVoiceCount = Math.max(0, this.activeVoiceCount - voiceCount);\n  }\n\n  clampActiveVoiceCountToAtMost(maxVoiceCount: number): void {\n    if (!Number.isFinite(maxVoiceCount)) {\n      return;\n    }\n    this.activeVoiceCount = Math.max(0, Math.min(this.activeVoiceCount, Math.floor(maxVoiceCount)));\n  }\n\n  resetActiveVoiceCount(): void {\n    this.activeVoiceCount = 0;\n  }\n\n  getActiveVoiceCount(): number {\n    return this.activeVoiceCount;\n  }\n\n  private updateMasterGain(): void {\n    const { polyphonyReference, smoothingTauMs, masterGainRampMs, gainUpdateIntervalMs } = this.options;\n\n    const now = Tone.now();\n\n    if (this.activeVoiceCount === 0) {\n      const alpha = 0.01;\n      this.smoothedVoiceCount = alpha * polyphonyReference + (1 - alpha) * this.smoothedVoiceCount;\n      return;\n    }\n\n    const deltaT = gainUpdateIntervalMs / 1000;\n    const alpha = 1 - Math.exp(-deltaT / (smoothingTauMs / 1000));\n\n    const currentVoices = Math.max(1, this.activeVoiceCount);\n    this.smoothedVoiceCount = alpha * currentVoices + (1 - alpha) * this.smoothedVoiceCount;\n\n    const scaleFactor = Math.sqrt(polyphonyReference / this.smoothedVoiceCount);\n    const targetGain = this.perVoiceBaselineGain * scaleFactor;\n\n    this.masterGain.gain.rampTo(targetGain, masterGainRampMs / 1000, now);\n  }\n}\n","/**\n * Clipping Monitor\n *\n * Monitors audio levels and warns when approaching clipping thresholds.\n * Framework-agnostic - callbacks handle the warning notifications.\n */\nimport type * as Tone from 'tone';\n\nexport interface ClippingMonitorOptions {\n  clippingWarningThresholdDb?: number;\n  clippingMonitorIntervalMs?: number;\n  clippingWarningCooldownMs?: number;\n  onWarning?: (levelDb: number) => void;\n}\n\nexport const DEFAULT_CLIPPING_MONITOR_OPTIONS: Required<Omit<ClippingMonitorOptions, 'onWarning'>> = {\n  clippingWarningThresholdDb: -3.0,\n  clippingMonitorIntervalMs: 500,\n  clippingWarningCooldownMs: 2000\n};\n\nexport class ClippingMonitor {\n  private readonly meter: Tone.Meter;\n  private readonly options: Required<Omit<ClippingMonitorOptions, 'onWarning'>> & { onWarning?: (levelDb: number) => void };\n  private clippingMonitorId: ReturnType<typeof setInterval> | null = null;\n  private lastClippingWarningAt = 0;\n\n  constructor(meter: Tone.Meter, options: ClippingMonitorOptions = {}) {\n    this.meter = meter;\n    this.options = { ...DEFAULT_CLIPPING_MONITOR_OPTIONS, ...options };\n  }\n\n  start(): void {\n    this.stop();\n    this.lastClippingWarningAt = 0;\n\n    this.clippingMonitorId = setInterval(() => {\n      const level = this.meter.getValue();\n      const levelValue = Array.isArray(level) ? level[0] : level;\n      if (levelValue === undefined) {\n        return;\n      }\n      if (levelValue <= this.options.clippingWarningThresholdDb) {\n        return;\n      }\n\n      const now = Date.now();\n      if (now - this.lastClippingWarningAt < this.options.clippingWarningCooldownMs) {\n        return;\n      }\n\n      this.lastClippingWarningAt = now;\n      this.options.onWarning?.(levelValue);\n    }, this.options.clippingMonitorIntervalMs);\n  }\n\n  stop(): void {\n    if (this.clippingMonitorId === null) {\n      return;\n    }\n    clearInterval(this.clippingMonitorId);\n    this.clippingMonitorId = null;\n  }\n}\n","/**\n * Synth Engine\n *\n * Framework-agnostic polyphonic synthesizer manager using Tone.js.\n * This is the engine package version with no DOM or window dependencies.\n *\n * Key design decisions:\n * - All dependencies are injected via config\n * - No window globals\n * - No store subscriptions (caller handles events)\n * - Optional effects manager and harmonic filter\n */\n\nimport * as Tone from 'tone';\nimport { FilteredVoice } from './FilteredVoice.js';\nimport { GainManager, getPerVoiceBaselineGain } from './GainManager.js';\nimport { ClippingMonitor } from './ClippingMonitor.js';\nimport type {\n  SynthEngineInstance,\n  SynthEngineConfig,\n  InternalTimbreState,\n  SynthLogger\n} from './types.js';\n\n/**\n * Create a new synth engine instance\n */\nexport function createSynthEngine(config: SynthEngineConfig): SynthEngineInstance {\n  const {\n    timbres,\n    masterVolume = 0,\n    effectsManager,\n    harmonicFilter,\n    logger,\n    audioInit,\n    getDrumVolume\n  } = config;\n\n  // Internal state\n  const synths: Record<string, Tone.PolySynth> = {};\n  let masterGain: Tone.Gain | null = null;\n  let volumeControl: Tone.Volume | null = null;\n  let compressor: Tone.Compressor | null = null;\n  let limiter: Tone.Limiter | null = null;\n  let clippingMeter: Tone.Meter | null = null;\n  let waveformAnalyzers: Record<string, Tone.Analyser> = {};\n  let gainManager: GainManager | null = null;\n  let clippingMonitor: ClippingMonitor | null = null;\n\n  // Copy of timbres for internal mutation\n  const internalTimbres: Record<string, InternalTimbreState> = { ...timbres };\n\n  // Logger helper\n  const log: SynthLogger = logger ?? {\n    debug: () => {},\n    info: () => {},\n    warn: () => {}\n  };\n\n  /**\n   * Get coefficients for a color, using harmonic filter if provided\n   */\n  function getCoefficients(color: string): Float32Array {\n    if (harmonicFilter) {\n      return harmonicFilter.getFilteredCoefficients(color);\n    }\n    // Fallback to raw coefficients from timbre\n    const timbre = internalTimbres[color];\n    if (timbre?.coeffs) {\n      return timbre.coeffs;\n    }\n    // Default to sine wave\n    return new Float32Array([0, 1]);\n  }\n\n  /**\n   * Normalize coefficients if total amplitude exceeds 1.0\n   */\n  function normalizeCoefficients(coeffs: Float32Array): number[] {\n    const totalAmplitude = coeffs.reduce((sum, coeff) => sum + Math.abs(coeff), 0);\n    if (totalAmplitude > 1.0) {\n      return Array.from(coeffs).map(coeff => coeff / totalAmplitude);\n    }\n    return Array.from(coeffs);\n  }\n\n  const instance: SynthEngineInstance = {\n    init() {\n      // Stop any existing monitors\n      this.stopBackgroundMonitors();\n\n      // === Build Master Audio Chain ===\n      // Signal flow: synths → masterGain → volumeControl → compressor → limiter → destination\n\n      // 1. Master gain node (polyphony-aware scaling with smoothing)\n      masterGain = new Tone.Gain(getPerVoiceBaselineGain());\n      gainManager = new GainManager(masterGain);\n      gainManager.start();\n\n      // 2. User volume control (independent of automatic gain scaling)\n      volumeControl = new Tone.Volume(masterVolume);\n\n      // 3. Bus compressor (gentle glue, transparent action)\n      compressor = new Tone.Compressor({\n        threshold: -12,\n        ratio: 3,\n        attack: 0.01,\n        release: 0.1,\n        knee: 6\n      });\n\n      // 4. True-peak limiter (safety net, should rarely engage)\n      limiter = new Tone.Limiter(-3.0);\n\n      // 5. Clipping detection meter\n      clippingMeter = new Tone.Meter();\n\n      // Connect chain: masterGain → volumeControl → compressor → limiter → destination → meter\n      masterGain.connect(volumeControl);\n      volumeControl.connect(compressor);\n      compressor.connect(limiter);\n      limiter.toDestination();\n      limiter.connect(clippingMeter);\n\n      // Start monitoring for clipping\n      if (clippingMeter) {\n        clippingMonitor = new ClippingMonitor(clippingMeter, {\n          onWarning: (levelDb) => {\n            log.warn('SynthEngine', 'Limiter input approaching clipping threshold', { level: levelDb }, 'audio');\n          }\n        });\n        clippingMonitor.start();\n      }\n\n      // Create synths for each timbre\n      for (const color in internalTimbres) {\n        const timbre = internalTimbres[color];\n        if (!timbre) continue;\n\n        // Initialize defaults if not present\n        if (!timbre.vibrato) {\n          timbre.vibrato = { speed: 0, span: 0 };\n        }\n        if (!timbre.tremelo) {\n          timbre.tremelo = { speed: 0, span: 0 };\n        }\n\n        const filteredCoeffs = getCoefficients(color);\n        const normalizedCoeffs = normalizeCoefficients(filteredCoeffs);\n        const presetGain = timbre.gain || 1.0;\n\n        const synth = new Tone.PolySynth({\n          voice: FilteredVoice,\n          options: {\n            oscillator: { type: 'custom', partials: normalizedCoeffs },\n            envelope: timbre.adsr,\n            filter: timbre.filter,\n            vibrato: timbre.vibrato,\n            tremelo: timbre.tremelo,\n            gain: presetGain\n          } as any\n        }).connect(masterGain) as any;\n\n        // Apply synth-level effects if effects manager is available\n        if (effectsManager && masterGain) {\n          effectsManager.applySynthEffects(synth, color, masterGain);\n        }\n\n        // Hook into voice creation to apply vibrato/tremolo to new voices\n        const originalTriggerAttack = synth.triggerAttack.bind(synth);\n        synth.triggerAttack = function(...args: any[]) {\n          const result = originalTriggerAttack(...args);\n\n          // Apply current settings to newly created voices\n          // Use Tone.Draw.schedule to sync with the audio timeline\n          // Schedule slightly after the attack time to ensure voice exists\n          const triggerTime = args[1] ?? Tone.now();\n          const effectApplicationTime = triggerTime + 0.005; // 5ms after attack in audio time\n\n          Tone.Draw.schedule(() => {\n            const activeVoices = this._activeVoices;\n\n            if (effectsManager) {\n              if (activeVoices && activeVoices.size > 0) {\n                activeVoices.forEach((voice: any) => {\n                  if (!voice.effectsApplied) {\n                    effectsManager.applyEffectsToVoice(voice, color);\n                    voice.effectsApplied = true;\n                  }\n                });\n              } else if (this._voices && Array.isArray(this._voices)) {\n                this._voices.forEach((voice: any) => {\n                  if (voice && !voice.effectsApplied) {\n                    effectsManager.applyEffectsToVoice(voice, color);\n                    voice.effectsApplied = true;\n                  }\n                });\n              }\n            } else {\n              // Fallback to legacy approach\n              if (activeVoices && activeVoices.size > 0) {\n                activeVoices.forEach((voice: any) => {\n                  if (voice._setVibrato && voice.vibratoApplied !== true) {\n                    voice._setVibrato(this._currentVibrato);\n                    voice.vibratoApplied = true;\n                  }\n                  if (voice._setTremolo && voice.tremoloApplied !== true) {\n                    voice._setTremolo(this._currentTremolo);\n                    voice.tremoloApplied = true;\n                  }\n                });\n              } else if (this._voices && Array.isArray(this._voices)) {\n                this._voices.forEach((voice: any) => {\n                  if (voice?._setVibrato && voice.vibratoApplied !== true) {\n                    voice._setVibrato(this._currentVibrato);\n                    voice.vibratoApplied = true;\n                  }\n                  if (voice?._setTremolo && voice.tremoloApplied !== true) {\n                    voice._setTremolo(this._currentTremolo);\n                    voice.tremoloApplied = true;\n                  }\n                });\n              }\n            }\n          }, effectApplicationTime);\n\n          return result;\n        };\n\n        // Store current settings on synth for future reference\n        synth._currentVibrato = timbre.vibrato;\n        synth._currentTremolo = timbre.tremelo;\n        synth._currentFilter = timbre.filter;\n\n        synths[color] = synth;\n        log.debug('SynthEngine', `Created filtered synth for color: ${color}`, null, 'audio');\n      }\n\n      log.info('SynthEngine', 'Initialized with multi-timbral support', null, 'audio');\n    },\n\n    updateSynthForColor(color: string) {\n      const timbre = internalTimbres[color];\n      const synth = synths[color];\n      if (!synth || !timbre) return;\n\n      // Initialize vibrato if it doesn't exist\n      if (!timbre.vibrato) {\n        timbre.vibrato = { speed: 0, span: 0 };\n      }\n\n      // Initialize tremolo if it doesn't exist\n      if (!timbre.tremelo) {\n        timbre.tremelo = { speed: 0, span: 0 };\n      }\n\n      log.debug('SynthEngine', `Updating timbre for color ${color}`, null, 'audio');\n\n      const filteredCoeffs = getCoefficients(color);\n      const normalizedCoeffs = normalizeCoefficients(filteredCoeffs);\n\n      synth.set({\n        oscillator: { partials: normalizedCoeffs },\n        envelope: timbre.adsr\n      });\n\n      // Re-apply synth-level effects when timbre changes\n      if (effectsManager && masterGain) {\n        effectsManager.applySynthEffects(synth, color, masterGain);\n      }\n\n      // Update stored settings on synth for future voices\n      // @ts-expect-error - Custom runtime properties added to synth\n      synth._currentVibrato = timbre.vibrato;\n      // @ts-expect-error - Custom runtime properties added to synth\n      synth._currentTremolo = timbre.tremelo;\n      // @ts-expect-error - Custom runtime properties added to synth\n      synth._currentFilter = timbre.filter;\n\n      // Try setting parameters on existing voices\n      // @ts-expect-error - Accessing private Tone.js property\n      const activeVoices = synth._activeVoices;\n\n      if (activeVoices && activeVoices.size > 0) {\n        activeVoices.forEach((voice: any) => {\n          if (voice._setFilter) {\n            voice._setFilter(timbre.filter);\n          }\n          if (voice._setVibrato) {\n            voice._setVibrato(timbre.vibrato);\n            voice.vibratoApplied = true;\n          }\n          if (voice._setTremolo) {\n            voice._setTremolo(timbre.tremelo);\n            voice.tremoloApplied = true;\n          }\n          if (voice._setPresetGain) {\n            const presetGain = timbre.gain || 1.0;\n            voice._setPresetGain(presetGain);\n          }\n        });\n        // @ts-expect-error - Accessing private Tone.js property\n      } else if (synth._voices && Array.isArray(synth._voices)) {\n        // @ts-expect-error - Accessing private Tone.js property\n        synth._voices.forEach((voice: any) => {\n          if (voice?._setVibrato) {\n            voice._setVibrato(timbre.vibrato);\n            voice.vibratoApplied = true;\n          }\n          if (voice?._setTremolo) {\n            voice._setTremolo(timbre.tremelo);\n            voice.tremoloApplied = true;\n          }\n          if (voice?._setFilter) {\n            voice._setFilter(timbre.filter);\n          }\n          if (voice?._setPresetGain) {\n            const presetGain = timbre.gain || 1.0;\n            voice._setPresetGain(presetGain);\n          }\n        });\n      }\n    },\n\n    setBpm(tempo: number) {\n      try {\n        if (Tone?.Transport?.bpm) {\n          Tone.Transport.bpm.value = tempo;\n          log.debug('SynthEngine', `Tone.Transport BPM updated to ${tempo}`, null, 'audio');\n        }\n      } catch (error) {\n        log.warn('SynthEngine', 'Unable to update BPM on Tone.Transport', { tempo, error }, 'audio');\n      }\n    },\n\n    setVolume(dB: number) {\n      if (volumeControl) {\n        volumeControl.volume.value = dB;\n      }\n    },\n\n    async playNote(pitch: string | number, duration: number | string, time = Tone.now()) {\n      // Use provided audio init or default to Tone.start()\n      const init = audioInit || (() => Tone.start());\n      await init();\n\n      // Get the first available synth\n      const colors = Object.keys(synths);\n      if (colors.length === 0) return;\n\n      const [firstColor] = colors;\n      if (!firstColor) return;\n      const synth = synths[firstColor];\n      if (synth) {\n        synth.triggerAttackRelease(pitch, duration, time);\n      }\n    },\n\n    /**\n     * Trigger note attack. Used by Transport scheduling with explicit time parameter.\n     * For interactive (user-initiated) triggers, use triggerAttackInteractive instead.\n     */\n    triggerAttack(pitch: string | number, color: string, time = Tone.now(), isDrum = false) {\n      const synth = synths[color];\n      if (!synth) return;\n\n      // Increment active voice count\n      gainManager?.noteOn(1);\n\n      if (isDrum && getDrumVolume) {\n        // Apply drum volume by temporarily adjusting synth volume\n        const drumVolume = getDrumVolume();\n        const originalVolume = synth.volume.value;\n        const drumVolumeDB = originalVolume + 20 * Math.log10(drumVolume);\n        synth.volume.value = drumVolumeDB;\n\n        synth.triggerAttack(pitch, time);\n\n        // Reset volume 100ms after the drum hit using audio-synchronized scheduling\n        // Tone.Draw.schedule syncs with the audio context for precise timing\n        Tone.Draw.schedule(() => {\n          if (synth?.volume) {\n            synth.volume.value = originalVolume;\n          }\n        }, time + 0.1);\n      } else {\n        synth.triggerAttack(pitch, time);\n      }\n    },\n\n    /**\n     * Trigger note attack for interactive (user-initiated) events.\n     * Adds a small scheduling offset (20ms) to help the audio thread process\n     * the event without pops or clicks.\n     *\n     * Use this for mouse clicks, keyboard presses, or other immediate UI triggers.\n     */\n    triggerAttackInteractive(pitch: string | number, color: string) {\n      // Small offset helps avoid performance-related audio pops\n      // 20ms is imperceptible but gives the audio thread breathing room\n      instance.triggerAttack(pitch, color, Tone.now() + 0.02);\n    },\n\n    quickReleasePitches(pitches: Array<string | number>, color: string) {\n      const synth = synths[color];\n      if (!synth || !pitches || pitches.length === 0) return;\n\n      let originalRelease: number | undefined;\n      try {\n        const currentConfig = typeof synth.get === 'function' ? synth.get() : null;\n        // Tone.js Time can be string or number - we only need number here\n        const release = currentConfig?.envelope?.release;\n        originalRelease = typeof release === 'number' ? release : undefined;\n\n        // Use a tiny but non-zero release to avoid audible clicks\n        synth.set({ envelope: { release: 0.01 } });\n\n        pitches.forEach(pitch => {\n          synth.triggerRelease(pitch, Tone.now());\n        });\n\n        // Clamp active voice count to current synth voices after quick release\n        const currentVoices = (synth as any)._activeVoices?.size ?? (synth as any)._voices?.length ?? gainManager?.getActiveVoiceCount() ?? 0;\n        gainManager?.clampActiveVoiceCountToAtMost(currentVoices);\n      } catch (err) {\n        log.warn('SynthEngine', 'quickReleasePitches failed', { err, color, pitches }, 'audio');\n      } finally {\n        if (originalRelease !== undefined) {\n          try {\n            synth.set({ envelope: { release: originalRelease } });\n          } catch {\n            // Ignore restore errors\n          }\n        }\n      }\n    },\n\n    triggerRelease(pitch: string | number, color: string, time = Tone.now()) {\n      const synth = synths[color];\n      if (!synth) return;\n\n      synth.triggerRelease(pitch, time);\n\n      // Decrement active voice count\n      gainManager?.noteOff(1);\n\n      // Clamp to actual synth voices to avoid drift\n      const currentVoices = (synth as any)._activeVoices?.size ?? (synth as any)._voices?.length ?? gainManager?.getActiveVoiceCount() ?? 0;\n      gainManager?.clampActiveVoiceCountToAtMost(currentVoices);\n    },\n\n    releaseAll() {\n      for (const color in synths) {\n        synths[color]?.releaseAll();\n      }\n      gainManager?.resetActiveVoiceCount();\n    },\n\n    // === Waveform Visualization ===\n\n    createWaveformAnalyzer(color: string): Tone.Analyser | null {\n      const synth = synths[color];\n      if (!synth) {\n        log.warn('SynthEngine', `No synth found for color: ${color}`, null, 'audio');\n        return null;\n      }\n\n      if (!waveformAnalyzers[color]) {\n        waveformAnalyzers[color] = new Tone.Analyser('waveform', 1024);\n        synth.connect(waveformAnalyzers[color]);\n        log.debug('SynthEngine', `Created waveform analyzer for color: ${color}`, null, 'waveform');\n      }\n\n      return waveformAnalyzers[color];\n    },\n\n    getWaveformAnalyzer(color: string): Tone.Analyser | null {\n      return waveformAnalyzers[color] || null;\n    },\n\n    getAllWaveformAnalyzers(): Map<string, Tone.Analyser> {\n      const activeAnalyzers = new Map<string, Tone.Analyser>();\n      for (const color in waveformAnalyzers) {\n        if (waveformAnalyzers[color]) {\n          activeAnalyzers.set(color, waveformAnalyzers[color]);\n        }\n      }\n      return activeAnalyzers;\n    },\n\n    removeWaveformAnalyzer(color: string) {\n      if (waveformAnalyzers[color]) {\n        waveformAnalyzers[color].dispose();\n        delete waveformAnalyzers[color];\n        log.debug('SynthEngine', `Removed waveform analyzer for color: ${color}`, null, 'waveform');\n      }\n    },\n\n    disposeAllWaveformAnalyzers() {\n      for (const color in waveformAnalyzers) {\n        if (waveformAnalyzers[color]) {\n          waveformAnalyzers[color].dispose();\n        }\n      }\n      waveformAnalyzers = {};\n      log.debug('SynthEngine', 'Disposed all waveform analyzers', null, 'waveform');\n    },\n\n    // === Node Access ===\n\n    getSynth(color: string): unknown | null {\n      return synths[color] || null;\n    },\n\n    getAllSynths(): Record<string, unknown> {\n      return { ...synths };\n    },\n\n    getMainVolumeNode(): Tone.Volume | null {\n      return volumeControl || null;\n    },\n\n    getMasterGainNode(): Tone.Gain | null {\n      return masterGain || null;\n    },\n\n    // === Cleanup ===\n\n    stopBackgroundMonitors() {\n      clippingMonitor?.stop();\n      gainManager?.stop();\n    },\n\n    dispose() {\n      this.stopBackgroundMonitors();\n      this.disposeAllWaveformAnalyzers();\n\n      // Dispose synths\n      for (const color in synths) {\n        synths[color]?.dispose();\n      }\n\n      // Dispose audio chain\n      masterGain?.dispose();\n      volumeControl?.dispose();\n      compressor?.dispose();\n      limiter?.dispose();\n      clippingMeter?.dispose();\n\n      log.debug('SynthEngine', 'Disposed SynthEngine', null, 'audio');\n    }\n  };\n\n  return instance;\n}\n","/**\r\n * Time Map Calculator\r\n *\r\n * Calculates the mapping between grid columns and playback time.\r\n * Handles modulation adjustments and tonic column time skipping.\r\n *\r\n * Framework-agnostic - accepts state and callbacks as parameters.\r\n */\r\n\r\nimport * as Tone from 'tone';\r\nimport type {\r\n  LoopBounds,\r\n  TimeMapConfig,\r\n  TimeMapState,\r\n  MacrobeatInfo,\r\n  PlacedTonicSign,\r\n  TransportLogger,\r\n  GetMacrobeatInfoCallback,\r\n  GetPlacedTonicSignsCallback,\r\n  UpdatePlayheadModelCallback\r\n} from './types.js';\r\n\r\nconst LOOP_EPSILON = 1e-4;\r\n\r\n/**\r\n * Configuration for time map calculator instance\r\n */\r\nexport interface TimeMapCalculatorConfig {\r\n  /** Function to get macrobeat info by index */\r\n  getMacrobeatInfo: GetMacrobeatInfoCallback;\r\n  /** Function to get placed tonic signs */\r\n  getPlacedTonicSigns: GetPlacedTonicSignsCallback;\r\n  /** Function to get tonic span column indices from placed tonic signs */\r\n  getTonicSpanColumnIndices: (tonicSigns: PlacedTonicSign[]) => Set<number>;\r\n  /** Optional callback to update playhead model */\r\n  updatePlayheadModel?: UpdatePlayheadModelCallback;\r\n  /** Optional logger */\r\n  logger?: TransportLogger;\r\n}\r\n\r\n/**\r\n * Time map calculator instance\r\n */\r\nexport interface TimeMapCalculatorInstance {\r\n  /** Get the duration of one microbeat in seconds */\r\n  getMicrobeatDuration(tempo: number): number;\r\n  /** Calculate the time map from state */\r\n  calculate(state: TimeMapState): void;\r\n  /** Get the current time map */\r\n  getTimeMap(): number[];\r\n  /** Get the cached musical end time */\r\n  getMusicalEndTime(): number;\r\n  /** Find the time where non-anacrusis section starts */\r\n  findNonAnacrusisStart(state: TimeMapState): number;\r\n  /** Apply modulation to a time value */\r\n  applyModulationToTime(baseTime: number, columnIndex: number, state: TimeMapState): number;\r\n  /** Set loop bounds on Tone.Transport */\r\n  setLoopBounds(loopStart: number, loopEnd: number, tempo: number): void;\r\n  /** Get configured loop bounds */\r\n  getConfiguredLoopBounds(): LoopBounds;\r\n  /** Set configured loop bounds directly */\r\n  setConfiguredLoopBounds(loopStart: number, loopEnd: number): void;\r\n  /** Clear configured loop bounds */\r\n  clearConfiguredLoopBounds(): void;\r\n  /** Reapply configured loop bounds if they've drifted */\r\n  reapplyConfiguredLoopBounds(isLooping: boolean): void;\r\n  /** Update loop bounds from current timeline */\r\n  updateLoopBoundsFromTimeline(state: TimeMapState): void;\r\n}\r\n\r\n/**\r\n * Create a time map calculator instance.\r\n */\r\nexport function createTimeMapCalculator(config: TimeMapCalculatorConfig): TimeMapCalculatorInstance {\r\n  const {\r\n    getMacrobeatInfo,\r\n    getPlacedTonicSigns,\r\n    getTonicSpanColumnIndices,\r\n    updatePlayheadModel,\r\n    logger\r\n  } = config;\r\n\r\n  // Internal state\r\n  let timeMap: number[] = [];\r\n  let cachedMusicalEndTime = 0;\r\n  let configuredLoopStart = 0;\r\n  let configuredLoopEnd = 0;\r\n\r\n  // Logger helper\r\n  const log: TransportLogger = logger ?? {\r\n    debug: () => {}\r\n  };\r\n\r\n  /**\r\n   * Get the duration of one microbeat in seconds based on tempo.\r\n   */\r\n  function getMicrobeatDuration(tempo: number): number {\r\n    const microbeatBPM = tempo * 2;\r\n    return 60 / microbeatBPM;\r\n  }\r\n\r\n  /**\r\n   * Calculate the regular (non-modulated) time map.\r\n   */\r\n  function calculateRegularTimeMap(\r\n    microbeatDuration: number,\r\n    columnWidths: number[],\r\n    placedTonicSigns: PlacedTonicSign[]\r\n  ): void {\r\n    let currentTime = 0;\r\n\r\n    log.debug('TimeMapCalculator', '[TIMEMAP] Building timeMap', {\r\n      columnCount: columnWidths.length,\r\n      tonicSignCount: placedTonicSigns.length,\r\n      microbeatDuration\r\n    });\r\n\r\n    const totalColumns = columnWidths.length;\r\n    const tonicSpanColumns = getTonicSpanColumnIndices(placedTonicSigns);\r\n\r\n    for (let i = 0; i < totalColumns; i++) {\r\n      timeMap[i] = currentTime;\r\n\r\n      const isTonicColumn = tonicSpanColumns.has(i);\r\n      if (!isTonicColumn) {\r\n        currentTime += (columnWidths[i] || 0) * microbeatDuration;\r\n      } else {\r\n        log.debug('TimeMapCalculator', `[TIMEMAP] Column ${i} is tonic, not advancing time`);\r\n      }\r\n\r\n      if (i < 5) {\r\n        const entry = timeMap[i];\r\n        if (entry !== undefined) {\r\n          log.debug('TimeMapCalculator', `[TIMEMAP] timeMap[${i}] = ${entry.toFixed(3)}s (isTonic: ${isTonicColumn})`);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (totalColumns > 0) {\r\n      timeMap[totalColumns] = currentTime;\r\n    }\r\n\r\n    log.debug('TimeMapCalculator', `[TIMEMAP] Complete. Total columns: ${totalColumns}, Final time: ${currentTime.toFixed(3)}s`);\r\n  }\r\n\r\n  /**\r\n   * Calculate and cache the modulation-adjusted musical end time.\r\n   */\r\n  function calculateMusicalEndTime(state: TimeMapState): void {\r\n    const baseEndTime = timeMap.length > 0 ? (timeMap[timeMap.length - 1] ?? 0) : 0;\r\n\r\n    if (!Number.isFinite(baseEndTime) || baseEndTime === 0) {\r\n      cachedMusicalEndTime = 0;\r\n      return;\r\n    }\r\n\r\n    const tempoModulationMarkers = state.tempoModulationMarkers?.filter(m => m.active) || [];\r\n\r\n    if (tempoModulationMarkers.length === 0) {\r\n      cachedMusicalEndTime = baseEndTime;\r\n      return;\r\n    }\r\n\r\n    const sortedMarkers = [...tempoModulationMarkers].sort((a, b) => a.measureIndex - b.measureIndex);\r\n    let adjustedEndTime = baseEndTime;\r\n\r\n    for (const marker of sortedMarkers) {\r\n      const macrobeatInfo = getMacrobeatInfo(marker.measureIndex);\r\n\r\n      if (macrobeatInfo) {\r\n        const modulationStartColumn = macrobeatInfo.endColumn - 1;\r\n        const modulationStartTime = timeMap[modulationStartColumn] ?? baseEndTime;\r\n        const remainingBaseTime = baseEndTime - modulationStartTime;\r\n        const stretchedTime = remainingBaseTime * marker.ratio;\r\n        adjustedEndTime = adjustedEndTime - remainingBaseTime + stretchedTime;\r\n      }\r\n    }\r\n\r\n    cachedMusicalEndTime = adjustedEndTime;\r\n  }\r\n\r\n  return {\r\n    getMicrobeatDuration,\r\n\r\n    calculate(state: TimeMapState): void {\r\n      log.debug('TimeMapCalculator', 'calculate', { tempo: `${state.tempo} BPM` });\r\n      timeMap = [];\r\n\r\n      const microbeatDuration = getMicrobeatDuration(state.tempo);\r\n      const { columnWidths } = state;\r\n      const placedTonicSigns = getPlacedTonicSigns();\r\n\r\n      calculateRegularTimeMap(microbeatDuration, columnWidths, placedTonicSigns);\r\n\r\n      log.timing?.('TimeMapCalculator', 'calculate', { totalDuration: `${timeMap[timeMap.length - 1]?.toFixed(2)}s` });\r\n\r\n      calculateMusicalEndTime(state);\r\n      const musicalEnd = cachedMusicalEndTime;\r\n\r\n      updatePlayheadModel?.({\r\n        timeMap,\r\n        musicalEndTime: musicalEnd,\r\n        columnWidths: state.columnWidths,\r\n        cellWidth: state.cellWidth\r\n      });\r\n    },\r\n\r\n    getTimeMap(): number[] {\r\n      return timeMap;\r\n    },\r\n\r\n    getMusicalEndTime(): number {\r\n      return cachedMusicalEndTime;\r\n    },\r\n\r\n    findNonAnacrusisStart(state: TimeMapState): number {\r\n      if (!state.hasAnacrusis) {\r\n        log.debug('TimeMapCalculator', '[ANACRUSIS] No anacrusis, starting from time 0');\r\n        return 0;\r\n      }\r\n\r\n      // Find the first solid boundary which marks the end of anacrusis\r\n      for (let i = 0; i < state.macrobeatBoundaryStyles.length; i++) {\r\n        if (state.macrobeatBoundaryStyles[i] === 'solid') {\r\n          const macrobeatInfo = getMacrobeatInfo(i + 1);\r\n          if (macrobeatInfo) {\r\n            const startTime = timeMap[macrobeatInfo.startColumn] || 0;\r\n            log.debug('TimeMapCalculator', `[ANACRUSIS] Found solid boundary at macrobeat ${i}, non-anacrusis starts at column ${macrobeatInfo.startColumn}, time ${startTime.toFixed(3)}s`);\r\n            return startTime;\r\n          }\r\n        }\r\n      }\r\n\r\n      log.debug('TimeMapCalculator', '[ANACRUSIS] No solid boundary found, starting from time 0');\r\n      return 0;\r\n    },\r\n\r\n    applyModulationToTime(baseTime: number, columnIndex: number, state: TimeMapState): number {\r\n      const tempoModulationMarkers = state.tempoModulationMarkers?.filter(m => m.active) || [];\r\n\r\n      if (tempoModulationMarkers.length === 0) {\r\n        return baseTime;\r\n      }\r\n\r\n      const sortedMarkers = [...tempoModulationMarkers].sort((a, b) => a.measureIndex - b.measureIndex);\r\n      let adjustedTime = baseTime;\r\n\r\n      if (columnIndex < 5) {\r\n        log.debug('TimeMapCalculator', `[MODULATION] Column ${columnIndex}: baseTime ${baseTime.toFixed(3)}s, ${sortedMarkers.length} active markers`);\r\n      }\r\n\r\n      for (const marker of sortedMarkers) {\r\n        const macrobeatInfo = getMacrobeatInfo(marker.measureIndex);\r\n\r\n        if (macrobeatInfo) {\r\n          const modulationStartColumn = macrobeatInfo.endColumn;\r\n\r\n          if (columnIndex > modulationStartColumn) {\r\n            const modulationStartTime = timeMap[modulationStartColumn] !== undefined ? timeMap[modulationStartColumn] : 0;\r\n            const deltaTime = baseTime - modulationStartTime;\r\n            const modulatedDelta = deltaTime * marker.ratio;\r\n            adjustedTime = adjustedTime - deltaTime + modulatedDelta;\r\n\r\n            if (columnIndex < 5) {\r\n              log.debug('TimeMapCalculator', `[MODULATION] Column ${columnIndex}: Applied marker at measure ${marker.measureIndex} (col ${modulationStartColumn}), ratio ${marker.ratio}, adjustedTime ${adjustedTime.toFixed(3)}s`);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return adjustedTime;\r\n    },\r\n\r\n    setLoopBounds(loopStart: number, loopEnd: number, tempo: number): void {\r\n      const microbeatDuration = getMicrobeatDuration(tempo);\r\n      const minDuration = Math.max(microbeatDuration, 0.001);\r\n      const safeStart = Number.isFinite(loopStart) ? loopStart : 0;\r\n      let safeEnd = Number.isFinite(loopEnd) ? loopEnd : safeStart + minDuration;\r\n      if (safeEnd <= safeStart) {\r\n        safeEnd = safeStart + minDuration;\r\n      }\r\n      configuredLoopStart = safeStart;\r\n      configuredLoopEnd = safeEnd;\r\n\r\n      if (Tone?.Transport) {\r\n        Tone.Transport.loopStart = safeStart;\r\n        Tone.Transport.loopEnd = safeEnd;\r\n      }\r\n    },\r\n\r\n    getConfiguredLoopBounds(): LoopBounds {\r\n      return { loopStart: configuredLoopStart, loopEnd: configuredLoopEnd };\r\n    },\r\n\r\n    setConfiguredLoopBounds(loopStart: number, loopEnd: number): void {\r\n      configuredLoopStart = loopStart;\r\n      configuredLoopEnd = loopEnd;\r\n    },\r\n\r\n    clearConfiguredLoopBounds(): void {\r\n      configuredLoopStart = 0;\r\n      configuredLoopEnd = 0;\r\n    },\r\n\r\n    reapplyConfiguredLoopBounds(isLooping: boolean): void {\r\n      if (configuredLoopEnd > configuredLoopStart) {\r\n        const loopStartSeconds = Tone.Time(Tone.Transport.loopStart).toSeconds();\r\n        const loopEndSeconds = Tone.Time(Tone.Transport.loopEnd).toSeconds();\r\n        const loopStartDiff = Math.abs(loopStartSeconds - configuredLoopStart);\r\n        const loopEndDiff = Math.abs(loopEndSeconds - configuredLoopEnd);\r\n        if (loopStartDiff > LOOP_EPSILON || loopEndDiff > LOOP_EPSILON) {\r\n          Tone.Transport.loopStart = configuredLoopStart;\r\n          Tone.Transport.loopEnd = configuredLoopEnd;\r\n        }\r\n        if (Tone.Transport.loop !== isLooping) {\r\n          Tone.Transport.loop = isLooping;\r\n        }\r\n      }\r\n    },\r\n\r\n    updateLoopBoundsFromTimeline(state: TimeMapState): void {\r\n      const loopStart = this.findNonAnacrusisStart(state);\r\n      const loopEnd = cachedMusicalEndTime;\r\n      this.setLoopBounds(loopStart, loopEnd, state.tempo);\r\n    }\r\n  };\r\n}\r\n","/**\n * Drum Manager\n *\n * Handles drum player initialization and safe scheduling.\n * Framework-agnostic - accepts synth engine as dependency for audio routing.\n */\n\nimport * as Tone from 'tone';\nimport type {\n  DrumConfig,\n  DrumManagerInstance,\n  DrumTrackId\n} from './types.js';\n\n/** Default drum sample URLs */\nexport const DEFAULT_DRUM_SAMPLES: Record<DrumTrackId, string> = {\n  H: 'https://tonejs.github.io/audio/drum-samples/CR78/hihat.mp3',\n  M: 'https://tonejs.github.io/audio/drum-samples/CR78/snare.mp3',\n  L: 'https://tonejs.github.io/audio/drum-samples/CR78/kick.mp3'\n};\n\n/** Minimum time between drum triggers */\nconst DRUM_START_EPSILON = 1e-4;\n\n/**\n * Create a drum manager instance.\n */\nexport function createDrumManager(config: DrumConfig = {}): DrumManagerInstance {\n  const {\n    samples = DEFAULT_DRUM_SAMPLES,\n    synthEngine,\n    initialVolume = 0\n  } = config;\n\n  // Internal state\n  let drumPlayers: Tone.Players | null = null;\n  let drumVolumeNode: Tone.Volume | null = null;\n  const lastDrumStartTimes = new Map<string, number>();\n\n  /**\n   * Get a safe drum start time that prevents overlapping triggers.\n   */\n  function getSafeDrumStartTime(trackId: string, requestedTime: number): number {\n    let safeTime = Number.isFinite(requestedTime) ? requestedTime : Tone.now();\n    const lastTime = lastDrumStartTimes.get(trackId) ?? -Infinity;\n\n    if (!(safeTime > lastTime)) {\n      safeTime = lastTime + DRUM_START_EPSILON;\n    }\n\n    lastDrumStartTimes.set(trackId, safeTime);\n    return safeTime;\n  }\n\n  // Initialize drum players\n  drumVolumeNode = new Tone.Volume(initialVolume);\n\n  drumPlayers = new Tone.Players(samples).connect(drumVolumeNode);\n\n  // Connect to synth engine's main volume if available, otherwise to destination\n  if (synthEngine) {\n    const synthEngineDestination = synthEngine.getMainVolumeNode?.();\n    if (synthEngineDestination) {\n      drumVolumeNode.connect(synthEngineDestination);\n    } else {\n      drumVolumeNode.toDestination();\n    }\n  } else {\n    drumVolumeNode.toDestination();\n  }\n\n  return {\n    getPlayers(): Tone.Players | null {\n      return drumPlayers;\n    },\n\n    getVolumeNode(): Tone.Volume | null {\n      return drumVolumeNode;\n    },\n\n    trigger(trackId: DrumTrackId, time: number): void {\n      if (!drumPlayers) return;\n\n      const safeTime = getSafeDrumStartTime(trackId, time);\n      drumPlayers.player(trackId)?.start(safeTime);\n    },\n\n    reset(): void {\n      lastDrumStartTimes.clear();\n    },\n\n    dispose(): void {\n      drumPlayers?.dispose();\n      drumVolumeNode?.dispose();\n      drumPlayers = null;\n      drumVolumeNode = null;\n      lastDrumStartTimes.clear();\n    }\n  };\n}\n","/**\r\n * Transport Service\r\n *\r\n * Framework-agnostic playback controller using Tone.js Transport.\r\n * All DOM operations are delegated to injected callbacks.\r\n *\r\n * Key design decisions:\r\n * - No DOM dependencies (domCache, document.*, etc.)\r\n * - All visual updates via callbacks\r\n * - State access via callbacks (no direct store import)\r\n * - Can run headless for testing or tutorial puppeting\r\n */\r\n\r\nimport * as Tone from 'tone';\r\nimport { createTimeMapCalculator, type TimeMapCalculatorInstance } from '../transport/timeMapCalculator.js';\r\nimport { createDrumManager } from '../transport/drumManager.js';\r\nimport type { DrumManagerInstance } from '../transport/types.js';\r\nimport type {\r\n  TransportServiceInstance,\r\n  TransportConfig,\r\n  TransportState,\r\n  SynthLogger,\r\n  SchedulableNote,\r\n  SchedulableStamp,\r\n  SchedulableTriplet,\r\n  StampScheduleEvent\r\n} from './types.js';\r\n\r\nconst FLAT_SYMBOL = '\\u266d';\r\nconst SHARP_SYMBOL = '\\u266f';\r\n\r\n/**\r\n * Binary search to find the timeMap index containing a given time.\r\n * Returns the index i where timeMap[i] <= time < timeMap[i+1].\r\n * Returns -1 if time is before the first entry or after the last.\r\n */\r\nfunction binarySearchTimeMap(timeMap: number[], time: number): number {\r\n  if (timeMap.length < 2) return -1;\r\n  if (time < timeMap[0]!) return -1;\r\n  if (time >= timeMap[timeMap.length - 1]!) return -1;\r\n\r\n  let low = 0;\r\n  let high = timeMap.length - 2; // Last valid index for a column\r\n\r\n  while (low <= high) {\r\n    const mid = (low + high) >>> 1;\r\n    const colStart = timeMap[mid]!;\r\n    const colEnd = timeMap[mid + 1]!;\r\n\r\n    if (time >= colStart && time < colEnd) {\r\n      return mid;\r\n    } else if (time < colStart) {\r\n      high = mid - 1;\r\n    } else {\r\n      low = mid + 1;\r\n    }\r\n  }\r\n\r\n  return -1;\r\n}\r\n\r\n/**\r\n * Create a new transport service instance\r\n */\r\nexport function createTransportService(config: TransportConfig): TransportServiceInstance {\r\n  const {\r\n    synthEngine,\r\n    stateCallbacks,\r\n    eventCallbacks,\r\n    visualCallbacks,\r\n    logger,\r\n    audioInit,\r\n    playbackMode = 'standard',\r\n    highwayService\r\n  } = config;\r\n\r\n  // Logger helper\r\n  const log: SynthLogger = logger ?? {\r\n    debug: () => {},\r\n    info: () => {},\r\n    warn: () => {}\r\n  };\r\n\r\n  // Internal state\r\n  let playheadAnimationFrame: number | null = null;\r\n  let shouldAnimatePlayhead = false;\r\n  let timeMapCalculator: TimeMapCalculatorInstance | null = null;\r\n  let drumManager: DrumManagerInstance | null = null;\r\n  let lastAppliedTempoMultiplier = 1.0;\r\n\r\n  // Event listener cleanup\r\n  const eventCleanups: Array<() => void> = [];\r\n\r\n  /**\r\n   * Get pitch from a global row index.\r\n   */\r\n  function getPitchFromRow(rowIndex: number, state: TransportState): string {\r\n    const rowData = state.fullRowData[rowIndex];\r\n    if (!rowData) {\r\n      return 'C4';\r\n    }\r\n    return rowData.toneNote\r\n      .replace(FLAT_SYMBOL, 'b')\r\n      .replace(SHARP_SYMBOL, '#');\r\n  }\r\n\r\n  /**\r\n   * Get pitch for a placed note.\r\n   */\r\n  function getPitchForNote(note: SchedulableNote, state: TransportState): string {\r\n    const rowIndex = note.globalRow ?? note.row;\r\n    const rowData = state.fullRowData[rowIndex];\r\n    if (rowData) {\r\n      return rowData.toneNote\r\n        .replace(FLAT_SYMBOL, 'b')\r\n        .replace(SHARP_SYMBOL, '#');\r\n    }\r\n    return 'C4';\r\n  }\r\n\r\n  /**\r\n   * Schedule all notes, stamps, and triplets on Transport.\r\n   */\r\n  function scheduleNotes(): void {\r\n    if (!timeMapCalculator) return;\r\n\r\n    const state = stateCallbacks.getState();\r\n    log.debug('TransportService', 'scheduleNotes', 'Clearing previous transport events and rescheduling all notes');\r\n\r\n    Tone.Transport.cancel();\r\n    drumManager?.reset();\r\n    timeMapCalculator.calculate(state);\r\n    visualCallbacks?.clearAdsrVisuals?.();\r\n\r\n    const timeMap = timeMapCalculator.getTimeMap();\r\n    const { loopEnd: configuredLoopEnd } = timeMapCalculator.getConfiguredLoopBounds();\r\n    const anacrusisOffset = timeMapCalculator.findNonAnacrusisStart(state);\r\n\r\n    log.debug('TransportService', `[ANACRUSIS] hasAnacrusis: ${state.hasAnacrusis}, anacrusisOffset: ${anacrusisOffset.toFixed(3)}s`);\r\n\r\n    // Schedule placed notes\r\n    state.placedNotes.forEach((note, noteIndex) => {\r\n      const canvasStartIndex = note.startColumnIndex;\r\n      const canvasEndIndex = note.endColumnIndex;\r\n      const regularStartTime = timeMap[canvasStartIndex];\r\n\r\n      if (regularStartTime === undefined) {\r\n        log.warn('TransportService', `[NOTE SCHEDULE] Note ${noteIndex}: timeMap[${canvasStartIndex}] undefined, skipping`);\r\n        return;\r\n      }\r\n\r\n      const scheduleTime = timeMapCalculator!.applyModulationToTime(regularStartTime, canvasStartIndex, state);\r\n\r\n      // Calculate duration\r\n      const regularEndTime = timeMap[canvasEndIndex + 1];\r\n      if (regularEndTime === undefined) {\r\n        log.warn('TransportService', `Skipping note with invalid endColumnIndex: ${note.endColumnIndex + 1}`);\r\n        return;\r\n      }\r\n\r\n      const modulatedEndTime = timeMapCalculator!.applyModulationToTime(regularEndTime, canvasEndIndex + 1, state);\r\n      const tailDuration = modulatedEndTime - scheduleTime;\r\n\r\n      if (note.isDrum) {\r\n        scheduleRumNote(note, scheduleTime);\r\n      } else {\r\n        schedulePitchedNote(note, scheduleTime, tailDuration, configuredLoopEnd, state);\r\n      }\r\n    });\r\n\r\n    // Schedule stamps\r\n    const stampPlaybackData = stateCallbacks.getStampPlaybackData?.() ?? [];\r\n    stampPlaybackData.forEach(stampData => {\r\n      scheduleStamp(stampData, timeMap, state);\r\n    });\r\n\r\n    // Schedule triplets\r\n    const tripletPlaybackData = stateCallbacks.getTripletPlaybackData?.() ?? [];\r\n    tripletPlaybackData.forEach(tripletData => {\r\n      scheduleTriplet(tripletData, timeMap, state);\r\n    });\r\n\r\n    log.debug('TransportService', 'scheduleNotes', `Finished scheduling ${state.placedNotes.length} notes, ${stampPlaybackData.length} stamps, and ${tripletPlaybackData.length} triplets`);\r\n  }\r\n\r\n  /**\r\n   * Schedule a drum note.\r\n   */\r\n  function scheduleRumNote(note: SchedulableNote, scheduleTime: number): void {\r\n    const state = stateCallbacks.getState();\r\n\r\n    Tone.Transport.schedule(time => {\r\n      if (state.isPaused) return;\r\n\r\n      const drumTrack = note.drumTrack;\r\n      if (drumTrack == null) return;\r\n\r\n      const trackKey = String(drumTrack) as 'H' | 'M' | 'L';\r\n      drumManager?.trigger(trackKey, time);\r\n\r\n      // Schedule visual update\r\n      Tone.Draw.schedule(() => {\r\n        visualCallbacks?.triggerDrumNotePop?.(note.startColumnIndex, drumTrack);\r\n      }, time);\r\n    }, scheduleTime);\r\n  }\r\n\r\n  /**\r\n   * Schedule a pitched note.\r\n   */\r\n  function schedulePitchedNote(\r\n    note: SchedulableNote,\r\n    scheduleTime: number,\r\n    duration: number,\r\n    configuredLoopEnd: number,\r\n    state: TransportState\r\n  ): void {\r\n    const pitch = getPitchForNote(note, state);\r\n    const toolColor = note.color;\r\n    const rowIndex = note.globalRow ?? note.row;\r\n    const pitchColor = state.fullRowData[rowIndex]?.hex || '#888888';\r\n    const noteId = note.uuid;\r\n    const timbre = state.timbres[toolColor];\r\n\r\n    if (!timbre) {\r\n      log.warn('TransportService', `Timbre not found for color ${toolColor}. Skipping note ${noteId}`);\r\n      return;\r\n    }\r\n\r\n    let releaseTime = scheduleTime + duration;\r\n\r\n    // Ensure release happens BEFORE loop end to prevent feedback loop\r\n    const RELEASE_SAFETY_MARGIN = 0.001;\r\n    const maxReleaseTime = configuredLoopEnd - RELEASE_SAFETY_MARGIN;\r\n    if (releaseTime >= configuredLoopEnd) {\r\n      releaseTime = Math.max(scheduleTime + 0.001, maxReleaseTime);\r\n    }\r\n\r\n    // Schedule attack\r\n    Tone.Transport.schedule(time => {\r\n      if (stateCallbacks.getState().isPaused) return;\r\n      synthEngine.triggerAttack(pitch, toolColor, time);\r\n\r\n      Tone.Draw.schedule(() => {\r\n        visualCallbacks?.triggerAdsrVisual?.(noteId, 'attack', pitchColor, timbre.adsr);\r\n        eventCallbacks.emit('noteAttack', { noteId, color: toolColor });\r\n      }, time);\r\n    }, scheduleTime);\r\n\r\n    // Schedule release\r\n    Tone.Transport.schedule(time => {\r\n      synthEngine.triggerRelease(pitch, toolColor, time);\r\n\r\n      Tone.Draw.schedule(() => {\r\n        visualCallbacks?.triggerAdsrVisual?.(noteId, 'release', pitchColor, timbre.adsr);\r\n        eventCallbacks.emit('noteRelease', { noteId, color: toolColor });\r\n      }, time);\r\n    }, releaseTime);\r\n  }\r\n\r\n  /**\r\n   * Schedule a stamp.\r\n   */\r\n  function scheduleStamp(\r\n    stampData: SchedulableStamp,\r\n    timeMap: number[],\r\n    state: TransportState\r\n  ): void {\r\n    const canvasColumnIndex = stampData.column;\r\n    const cellStartTime = timeMap[canvasColumnIndex];\r\n    if (cellStartTime === undefined) return;\r\n\r\n    const scheduleEvents = stateCallbacks.getStampScheduleEvents?.(stampData.sixteenthStampId, stampData.placement) ?? [];\r\n\r\n    scheduleEvents.forEach(event => {\r\n      scheduleStampEvent(event, cellStartTime, stampData.row, stampData.color, state);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Schedule a triplet.\r\n   */\r\n  function scheduleTriplet(\r\n    tripletData: SchedulableTriplet,\r\n    timeMap: number[],\r\n    state: TransportState\r\n  ): void {\r\n    const canvasColumnIndex = stateCallbacks.timeToCanvas?.(tripletData.startTimeIndex, state) ?? tripletData.startTimeIndex;\r\n    const cellStartTime = timeMap[canvasColumnIndex];\r\n    if (cellStartTime === undefined) return;\r\n\r\n    const scheduleEvents = stateCallbacks.getTripletScheduleEvents?.(tripletData.tripletStampId, tripletData.placement) ?? [];\r\n\r\n    scheduleEvents.forEach(event => {\r\n      scheduleStampEvent(event, cellStartTime, tripletData.row, tripletData.color, state);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Schedule a single stamp/triplet event.\r\n   */\r\n  function scheduleStampEvent(\r\n    event: StampScheduleEvent,\r\n    cellStartTime: number,\r\n    baseRow: number,\r\n    color: string,\r\n    state: TransportState\r\n  ): void {\r\n    const offsetTime = Tone.Time(event.offset).toSeconds();\r\n    const eventDuration = Tone.Time(event.duration).toSeconds();\r\n    const triggerTime = cellStartTime + offsetTime;\r\n    const releaseTime = triggerTime + eventDuration;\r\n\r\n    const shapeRow = baseRow + event.rowOffset;\r\n    const shapePitch = getPitchFromRow(shapeRow, state);\r\n\r\n    // Schedule attack\r\n    Tone.Transport.schedule(time => {\r\n      if (stateCallbacks.getState().isPaused) return;\r\n      synthEngine.triggerAttack(shapePitch, color, time);\r\n    }, triggerTime);\r\n\r\n    // Schedule release\r\n    Tone.Transport.schedule(time => {\r\n      if (stateCallbacks.getState().isPaused) return;\r\n      synthEngine.triggerRelease(shapePitch, color, time);\r\n    }, releaseTime);\r\n  }\r\n\r\n  /**\r\n   * Animate the playhead.\r\n   */\r\n  function animatePlayhead(): void {\r\n    const state = stateCallbacks.getState();\r\n    const baseTempo = state.tempo;\r\n    const TEMPO_MULTIPLIER_EPSILON = 0.0001;\r\n    const MARKER_PASS_EPSILON = 0.5;\r\n\r\n    const getMarkerX = (marker: { xPosition?: number | null } | null | undefined) => marker?.xPosition ?? 477.5;\r\n    const initialBpm = typeof Tone.Transport?.bpm?.value === 'number'\r\n      ? Tone.Transport.bpm.value\r\n      : baseTempo;\r\n    lastAppliedTempoMultiplier = baseTempo !== 0 ? initialBpm / baseTempo : 1.0;\r\n\r\n    shouldAnimatePlayhead = true;\r\n\r\n    function draw(): void {\r\n      if (!shouldAnimatePlayhead || !timeMapCalculator) {\r\n        return;\r\n      }\r\n\r\n      // If Transport hasn't started yet, continue looping\r\n      if (Tone.Transport.state === 'stopped') {\r\n        playheadAnimationFrame = requestAnimationFrame(draw);\r\n        return;\r\n      }\r\n\r\n      const currentState = stateCallbacks.getState();\r\n      const transportLoopEnd = Tone.Time(Tone.Transport.loopEnd).toSeconds();\r\n      const isLooping = currentState.isLooping;\r\n      const musicalEnd = timeMapCalculator.getMusicalEndTime();\r\n      const playbackEnd = (isLooping && transportLoopEnd > 0) ? transportLoopEnd : musicalEnd;\r\n      const currentTime = Tone.Transport.seconds;\r\n      const currentTimeMs = currentTime * 1000;\r\n\r\n      const reachedEnd = currentTime >= (playbackEnd - 0.001);\r\n\r\n      // Stop only when looping is disabled\r\n      if (!isLooping && reachedEnd) {\r\n        log.info('TransportService', 'Playback reached end. Stopping playhead.');\r\n        instance.stop();\r\n        return;\r\n      }\r\n\r\n      if (currentState.isPaused) {\r\n        playheadAnimationFrame = requestAnimationFrame(draw);\r\n        return;\r\n      }\r\n\r\n      const timeMap = timeMapCalculator.getTimeMap();\r\n\r\n      // Clear canvases\r\n      visualCallbacks?.clearPlayheadCanvas?.();\r\n      visualCallbacks?.clearDrumPlayheadCanvas?.();\r\n\r\n      let loopAwareTime = currentTime;\r\n      if (isLooping) {\r\n        const loopStartSeconds = Tone.Time(Tone.Transport.loopStart).toSeconds();\r\n        const loopEndSeconds = Tone.Time(Tone.Transport.loopEnd).toSeconds();\r\n        const loopDuration = loopEndSeconds - loopStartSeconds;\r\n        if (loopDuration > 0) {\r\n          loopAwareTime = ((currentTime - loopStartSeconds) % loopDuration) + loopStartSeconds;\r\n        }\r\n      }\r\n\r\n      const maxXPos = stateCallbacks.getCanvasWidth?.() ?? 1000;\r\n\r\n      // Get tonic column spans for visual skipping\r\n      const placedTonicSigns = stateCallbacks.getPlacedTonicSigns?.() ?? [];\r\n      const tonicSpanColumns = stateCallbacks.getTonicSpanColumnIndices?.(placedTonicSigns) ?? new Set();\r\n\r\n      let xPos = 0;\r\n      let activeColumnStartX = 0;\r\n      let activeColumnWidth = 0;\r\n      let activeDisplayColumnIndex = -1;\r\n\r\n      // Use binary search O(log n) instead of linear search O(n)\r\n      const foundIndex = binarySearchTimeMap(timeMap, loopAwareTime);\r\n      if (foundIndex >= 0) {\r\n        const colStartTime = timeMap[foundIndex]!;\r\n        const colEndTime = timeMap[foundIndex + 1]!;\r\n\r\n        // Found the column containing current time\r\n        let displayColIndex = foundIndex;\r\n        while (tonicSpanColumns.has(displayColIndex) && displayColIndex < timeMap.length - 1) {\r\n          displayColIndex++;\r\n        }\r\n\r\n        const colStartX = stateCallbacks.getColumnStartX?.(displayColIndex) ?? 0;\r\n        const colWidth = stateCallbacks.getColumnWidth?.(displayColIndex) ?? 10;\r\n        activeColumnStartX = colStartX;\r\n        activeColumnWidth = colWidth;\r\n        activeDisplayColumnIndex = displayColIndex;\r\n\r\n        if (!tonicSpanColumns.has(foundIndex)) {\r\n          const colDuration = colEndTime - colStartTime;\r\n          const timeIntoCol = loopAwareTime - colStartTime;\r\n          const ratio = colDuration > 0 ? timeIntoCol / colDuration : 0;\r\n          xPos = colStartX + ratio * colWidth;\r\n        } else {\r\n          xPos = colStartX;\r\n        }\r\n      }\r\n\r\n      const finalXPos = Math.min(xPos, maxXPos);\r\n\r\n      // Apply dynamic tempo modulation\r\n      applyTempoModulation(currentState, finalXPos, baseTempo, getMarkerX, TEMPO_MULTIPLIER_EPSILON, MARKER_PASS_EPSILON);\r\n\r\n      // Draw playhead\r\n      const canvasHeight = visualCallbacks?.getPlayheadCanvasHeight?.() ?? 500;\r\n      const drumCanvasHeight = visualCallbacks?.getDrumCanvasHeight?.() ?? 100;\r\n      const macroRect = (currentState.playheadMode === 'macrobeat' && activeDisplayColumnIndex >= 0)\r\n        ? stateCallbacks.getMacrobeatHighlightRect?.(activeDisplayColumnIndex)\r\n        : null;\r\n      const highlightX = macroRect?.x ?? activeColumnStartX;\r\n      const highlightWidth = macroRect?.width ?? activeColumnWidth;\r\n\r\n      if (finalXPos >= 0) {\r\n        if (currentState.playheadMode === 'macrobeat' || currentState.playheadMode === 'microbeat') {\r\n          visualCallbacks?.drawPlayheadHighlight?.(highlightX, highlightWidth, canvasHeight, currentTimeMs);\r\n          visualCallbacks?.drawDrumPlayheadHighlight?.(highlightX, highlightWidth, drumCanvasHeight, currentTimeMs);\r\n        } else {\r\n          visualCallbacks?.drawPlayheadLine?.(finalXPos, canvasHeight);\r\n          visualCallbacks?.drawDrumPlayheadLine?.(finalXPos, drumCanvasHeight);\r\n        }\r\n      }\r\n\r\n      // Update beat line highlights\r\n      const shouldShowBeatLineHighlight = currentState.playheadMode === 'macrobeat' || currentState.playheadMode === 'microbeat';\r\n      visualCallbacks?.updateBeatLineHighlight?.(highlightX, highlightWidth, shouldShowBeatLineHighlight);\r\n\r\n      playheadAnimationFrame = requestAnimationFrame(draw);\r\n    }\r\n\r\n    draw();\r\n  }\r\n\r\n  /**\r\n   * Apply tempo modulation based on marker positions.\r\n   */\r\n  function applyTempoModulation(\r\n    state: TransportState,\r\n    finalXPos: number,\r\n    baseTempo: number,\r\n    getMarkerX: (marker: any) => number,\r\n    TEMPO_MULTIPLIER_EPSILON: number,\r\n    MARKER_PASS_EPSILON: number\r\n  ): void {\r\n    if (!timeMapCalculator) return;\r\n\r\n    const tempoModulationMarkers = Array.isArray(state.tempoModulationMarkers)\r\n      ? state.tempoModulationMarkers\r\n      : [];\r\n\r\n    const activeMarkers = tempoModulationMarkers\r\n      .filter(marker => marker?.active && typeof marker.ratio === 'number' && marker.ratio !== 0)\r\n      .sort((a, b) => getMarkerX(a) - getMarkerX(b));\r\n\r\n    if (activeMarkers.length > 0) {\r\n      let targetMultiplier = 1.0;\r\n\r\n      for (const marker of activeMarkers) {\r\n        const markerX = getMarkerX(marker);\r\n        if (finalXPos + MARKER_PASS_EPSILON >= markerX) {\r\n          targetMultiplier *= 1 / marker.ratio;\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!Number.isFinite(targetMultiplier) || targetMultiplier <= 0) {\r\n        targetMultiplier = 1.0;\r\n      }\r\n\r\n      if (Math.abs(targetMultiplier - lastAppliedTempoMultiplier) > TEMPO_MULTIPLIER_EPSILON) {\r\n        const newTempo = baseTempo * targetMultiplier;\r\n        Tone.Transport.bpm.value = newTempo;\r\n        timeMapCalculator.reapplyConfiguredLoopBounds(state.isLooping);\r\n        lastAppliedTempoMultiplier = targetMultiplier;\r\n        log.debug('TransportService', `Tempo multiplier updated to ${targetMultiplier.toFixed(3)} (${newTempo.toFixed(2)} BPM)`);\r\n      }\r\n    } else if (Math.abs(lastAppliedTempoMultiplier - 1.0) > TEMPO_MULTIPLIER_EPSILON) {\r\n      Tone.Transport.bpm.value = baseTempo;\r\n      timeMapCalculator.reapplyConfiguredLoopBounds(state.isLooping);\r\n      lastAppliedTempoMultiplier = 1.0;\r\n      log.debug('TransportService', `Tempo reset to base ${baseTempo} BPM`);\r\n    }\r\n  }\r\n\r\n  const instance: TransportServiceInstance = {\r\n    init(): void {\r\n      const state = stateCallbacks.getState();\r\n\r\n      // Create time map calculator\r\n      timeMapCalculator = createTimeMapCalculator({\r\n        getMacrobeatInfo: stateCallbacks.getMacrobeatInfo ?? (() => null),\r\n        getPlacedTonicSigns: stateCallbacks.getPlacedTonicSigns ?? (() => []),\r\n        getTonicSpanColumnIndices: stateCallbacks.getTonicSpanColumnIndices ?? (() => new Set()),\r\n        logger: log\r\n      });\r\n\r\n      // Create drum manager\r\n      drumManager = createDrumManager({\r\n        samples: {\r\n          H: '/audio/drums/hi.mp3',\r\n          M: '/audio/drums/mid.mp3',\r\n          L: '/audio/drums/lo.mp3'\r\n        },\r\n        synthEngine: {\r\n          getMainVolumeNode: () => synthEngine.getMainVolumeNode()\r\n        }\r\n      });\r\n\r\n      Tone.Transport.bpm.value = state.tempo;\r\n\r\n      // Subscribe to events\r\n      const rhythmHandler = () => this.handleStateChange();\r\n      const notesHandler = () => this.handleStateChange();\r\n      const stampsHandler = () => this.handleStateChange();\r\n      const modulationHandler = () => {\r\n        if (timeMapCalculator && timeMapCalculator.getTimeMap().length > 0) {\r\n          const currentState = stateCallbacks.getState();\r\n          timeMapCalculator.calculate(currentState);\r\n        }\r\n        this.handleStateChange();\r\n      };\r\n      const layoutHandler = (data: any) => {\r\n        const oldWidths = data?.oldConfig?.columnWidths || [];\r\n        const newWidths = data?.newConfig?.columnWidths || [];\r\n        if (oldWidths.length !== newWidths.length && timeMapCalculator) {\r\n          timeMapCalculator.calculate(stateCallbacks.getState());\r\n        }\r\n      };\r\n      const tempoHandler = (newTempo: number) => {\r\n        log.info('TransportService', `tempoChanged triggered with new value: ${newTempo} BPM`);\r\n\r\n        if (Tone.Transport.state === 'started') {\r\n          const currentPosition = Tone.Transport.position;\r\n          Tone.Transport.pause();\r\n\r\n          if (playheadAnimationFrame) {\r\n            cancelAnimationFrame(playheadAnimationFrame);\r\n            playheadAnimationFrame = null;\r\n          }\r\n\r\n          Tone.Transport.bpm.value = newTempo;\r\n          timeMapCalculator?.reapplyConfiguredLoopBounds(stateCallbacks.getState().isLooping);\r\n          scheduleNotes();\r\n          Tone.Transport.start(undefined, currentPosition);\r\n\r\n          // In standard mode, animate playhead here. In highway mode, the highway service handles visuals\r\n          if (playbackMode === 'standard') {\r\n            animatePlayhead();\r\n          }\r\n        } else {\r\n          Tone.Transport.bpm.value = newTempo;\r\n          timeMapCalculator?.reapplyConfiguredLoopBounds(stateCallbacks.getState().isLooping);\r\n          timeMapCalculator?.calculate(stateCallbacks.getState());\r\n        }\r\n      };\r\n      const loopingHandler = (isLooping: boolean) => {\r\n        Tone.Transport.loop = isLooping;\r\n        const loopStartSeconds = Tone.Time(Tone.Transport.loopStart).toSeconds();\r\n        const loopEndSeconds = Tone.Time(Tone.Transport.loopEnd).toSeconds();\r\n\r\n        if (isLooping && loopEndSeconds <= loopStartSeconds && timeMapCalculator) {\r\n          Tone.Transport.loopEnd = loopStartSeconds + Math.max(timeMapCalculator.getMicrobeatDuration(stateCallbacks.getState().tempo), 0.001);\r\n        }\r\n\r\n        if (isLooping && timeMapCalculator) {\r\n          timeMapCalculator.setConfiguredLoopBounds(\r\n            Tone.Time(Tone.Transport.loopStart).toSeconds(),\r\n            Tone.Time(Tone.Transport.loopEnd).toSeconds()\r\n          );\r\n        } else {\r\n          timeMapCalculator?.clearConfiguredLoopBounds();\r\n        }\r\n      };\r\n\r\n      eventCallbacks.on('rhythmStructureChanged', rhythmHandler);\r\n      eventCallbacks.on('notesChanged', notesHandler);\r\n      eventCallbacks.on('sixteenthStampPlacementsChanged', stampsHandler);\r\n      eventCallbacks.on('tempoModulationMarkersChanged', modulationHandler);\r\n      eventCallbacks.on('layoutConfigChanged', layoutHandler);\r\n      eventCallbacks.on('tempoChanged', tempoHandler);\r\n      eventCallbacks.on('loopingChanged', loopingHandler);\r\n\r\n      // Store cleanup functions\r\n      eventCleanups.push(\r\n        () => {}, // These would be off() calls if the event system supports them\r\n      );\r\n\r\n      // Handle Transport stop event\r\n      Tone.Transport.on('stop', () => {\r\n        log.info('TransportService', \"Tone.Transport 'stop' fired. Resetting playback state\");\r\n        eventCallbacks.setPlaybackState?.(false, false);\r\n        visualCallbacks?.clearAdsrVisuals?.();\r\n        if (playheadAnimationFrame) {\r\n          cancelAnimationFrame(playheadAnimationFrame);\r\n          playheadAnimationFrame = null;\r\n        }\r\n      });\r\n\r\n      log.info('TransportService', 'Initialized');\r\n    },\r\n\r\n    handleStateChange(): void {\r\n      const transportState = Tone.Transport.state;\r\n\r\n      if (transportState === 'started') {\r\n        log.debug('TransportService', 'handleStateChange: Notes or rhythm changed during playback. Rescheduling');\r\n        const currentPosition = Tone.Transport.position;\r\n        Tone.Transport.pause();\r\n        scheduleNotes();\r\n        Tone.Transport.start(undefined, currentPosition);\r\n      } else {\r\n        timeMapCalculator?.calculate(stateCallbacks.getState());\r\n      }\r\n    },\r\n\r\n    start(): void {\r\n      log.info('TransportService', 'Starting playback');\r\n\r\n      const init = audioInit || (() => Tone.start());\r\n      void init().then(() => {\r\n        scheduleNotes();\r\n\r\n        const state = stateCallbacks.getState();\r\n        const currentTimeMap = timeMapCalculator?.getTimeMap() ?? [];\r\n        const musicalDuration = timeMapCalculator?.getMusicalEndTime() ?? 0;\r\n        const loopStart = timeMapCalculator?.findNonAnacrusisStart(state) ?? 0;\r\n\r\n        timeMapCalculator?.setLoopBounds(loopStart, musicalDuration, state.tempo);\r\n        Tone.Transport.bpm.value = state.tempo;\r\n\r\n        const startTime = Tone.now() + 0.1;\r\n        Tone.Transport.start(startTime, 0);\r\n\r\n        // In standard mode, animate playhead here. In highway mode, the highway service handles visuals\r\n        if (playbackMode === 'standard') {\r\n          animatePlayhead();\r\n        }\r\n\r\n        eventCallbacks.emit('playbackStarted');\r\n      });\r\n    },\r\n\r\n    resume(): void {\r\n      log.info('TransportService', 'Resuming playback');\r\n\r\n      const init = audioInit || (() => Tone.start());\r\n      void init().then(() => {\r\n        Tone.Transport.start();\r\n\r\n        // In standard mode, animate playhead here. In highway mode, the highway service handles visuals\r\n        if (playbackMode === 'standard') {\r\n          animatePlayhead();\r\n        }\r\n\r\n        eventCallbacks.emit('playbackResumed');\r\n      });\r\n    },\r\n\r\n    pause(): void {\r\n      log.info('TransportService', 'Pausing playback');\r\n      Tone.Transport.pause();\r\n\r\n      if (playheadAnimationFrame) {\r\n        cancelAnimationFrame(playheadAnimationFrame);\r\n        playheadAnimationFrame = null;\r\n      }\r\n\r\n      eventCallbacks.emit('playbackPaused');\r\n    },\r\n\r\n    stop(): void {\r\n      log.info('TransportService', 'Stopping playback and clearing visuals');\r\n\r\n      shouldAnimatePlayhead = false;\r\n      if (playheadAnimationFrame) {\r\n        cancelAnimationFrame(playheadAnimationFrame);\r\n        playheadAnimationFrame = null;\r\n      }\r\n\r\n      Tone.Transport.stop();\r\n      Tone.Transport.cancel();\r\n      drumManager?.reset();\r\n\r\n      const state = stateCallbacks.getState();\r\n      Tone.Transport.bpm.value = state.tempo;\r\n      timeMapCalculator?.reapplyConfiguredLoopBounds(state.isLooping);\r\n\r\n      synthEngine.releaseAll();\r\n\r\n      // Clear visuals\r\n      visualCallbacks?.clearPlayheadCanvas?.();\r\n      visualCallbacks?.clearDrumPlayheadCanvas?.();\r\n      visualCallbacks?.updateBeatLineHighlight?.(0, 0, false);\r\n\r\n      eventCallbacks.emit('playbackStopped');\r\n    },\r\n\r\n    dispose(): void {\r\n      this.stop();\r\n      drumManager?.dispose();\r\n      eventCleanups.forEach(cleanup => cleanup());\r\n      log.debug('TransportService', 'Disposed');\r\n    }\r\n  };\r\n\r\n  return instance;\r\n}\r\n","/**\n * Audio Context Configuration\n *\n * Utilities for configuring Tone.js AudioContext with optimal performance settings.\n *\n * Key settings:\n * - latencyHint: Controls the trade-off between latency and stability\n *   - \"interactive\": Lowest latency (default), best for real-time instruments\n *   - \"playback\": Prioritizes sustained playback stability\n *   - \"balanced\": Balance between latency and performance\n *   - number: Custom latency in seconds\n *\n * - lookAhead: How far in advance events are scheduled (default 0.1s)\n *   - Higher values = better stability, worse latency\n *   - Lower values = better latency, may cause glitches\n */\n\nimport * as Tone from 'tone';\n\n/**\n * Standard Web Audio API latency hints\n */\nexport type LatencyHint = 'interactive' | 'playback' | 'balanced';\n\n/**\n * Options for configuring the audio context\n */\nexport interface ContextOptions {\n  /**\n   * Latency hint for the audio context.\n   * - \"interactive\": Low latency, may have glitches under load\n   * - \"playback\": Stable playback, higher latency\n   * - \"balanced\": Balance between latency and stability\n   * @default \"playback\"\n   */\n  latencyHint?: LatencyHint;\n\n  /**\n   * How far in advance to schedule events (in seconds).\n   * Higher values improve stability but increase latency.\n   * @default 0.1\n   */\n  lookAhead?: number;\n}\n\n/**\n * Default context options optimized for playback applications\n */\nexport const DEFAULT_CONTEXT_OPTIONS: ContextOptions = {\n  latencyHint: 'playback',\n  lookAhead: 0.1\n};\n\n/**\n * Configure the Tone.js audio context with performance-optimized settings.\n *\n * IMPORTANT: This should be called early in app initialization, before any\n * audio nodes are created. If the context has already started, only lookAhead\n * can be adjusted.\n *\n * @param options - Configuration options\n * @returns true if a new context was created, false if existing context was configured\n *\n * @example\n * ```ts\n * // Call early in app startup\n * configureAudioContext({ latencyHint: 'playback' });\n *\n * // Later, after user gesture\n * await Tone.start();\n * ```\n */\nexport function configureAudioContext(options: ContextOptions = {}): boolean {\n  const { latencyHint, lookAhead } = { ...DEFAULT_CONTEXT_OPTIONS, ...options };\n\n  let createdNewContext = false;\n\n  // Only create new context if the current one hasn't started yet\n  // Once started, we can't replace the context without breaking existing audio nodes\n  if (Tone.context.state === 'suspended') {\n    try {\n      // Cast latencyHint to satisfy Tone.js type expectations\n      // The Web Audio API accepts these string values\n      Tone.setContext(new Tone.Context({\n        latencyHint: latencyHint as AudioContextLatencyCategory\n      }));\n      createdNewContext = true;\n    } catch (error) {\n      // Context creation can fail in some environments\n      // Fall back to configuring the existing context\n      console.warn('Failed to create new AudioContext, using default:', error);\n    }\n  }\n\n  // lookAhead can be adjusted on any context\n  if (lookAhead !== undefined) {\n    Tone.context.lookAhead = lookAhead;\n  }\n\n  return createdNewContext;\n}\n\n/**\n * Get the current audio context state and configuration.\n * Useful for debugging and diagnostics.\n */\nexport function getContextInfo(): {\n  state: AudioContextState;\n  sampleRate: number;\n  baseLatency: number | undefined;\n  lookAhead: number;\n} {\n  // baseLatency is available on the raw AudioContext but not on Tone.Context wrapper\n  const rawContext = Tone.context.rawContext;\n  const baseLatency = rawContext && 'baseLatency' in rawContext\n    ? (rawContext as AudioContext).baseLatency\n    : undefined;\n\n  return {\n    state: Tone.context.state,\n    sampleRate: Tone.context.sampleRate,\n    baseLatency,\n    lookAhead: Tone.context.lookAhead\n  };\n}\n","/**\r\n * Canvas Coordinate Utilities\r\n *\r\n * Framework-agnostic coordinate transformation functions for the pitch grid.\r\n * All dependencies are injected via callbacks - no store or service imports.\r\n *\r\n * COORDINATE SYSTEM NOTE:\r\n * All functions work with CANVAS-SPACE coordinates (0 = first musical beat).\r\n * - getColumnX(): Converts canvas-space index → pixel position\r\n * - getColumnFromX(): Converts pixel position → canvas-space index\r\n * - columnWidths represents canvas-space columns only (no legends)\r\n */\r\n\r\nimport type { ModulationMarker } from '@mlt/types';\r\n\r\n/**\r\n * Viewport information for visible row range\r\n */\r\nexport interface ViewportInfo {\r\n  /** First visible global row index */\r\n  startRank: number;\r\n  /** Last visible global row index (exclusive) */\r\n  endRank: number;\r\n}\r\n\r\n/**\r\n * Options for coordinate calculations\r\n */\r\nexport interface CoordinateOptions {\r\n  /** Canvas-space column widths (musical columns only, no legends) */\r\n  columnWidths: number[];\r\n  /** Base cell width in pixels */\r\n  cellWidth: number;\r\n  /** Base cell height in pixels */\r\n  cellHeight: number;\r\n  /** Modulation markers for tempo changes */\r\n  tempoModulationMarkers?: ModulationMarker[];\r\n  /** Base microbeat pixel width */\r\n  baseMicrobeatPx?: number;\r\n}\r\n\r\n/**\r\n * Callbacks for coordinate calculations\r\n */\r\nexport interface CoordinateCallbacks {\r\n  /** Get viewport info (visible row range) */\r\n  getViewportInfo: () => ViewportInfo;\r\n  /** Convert column index to X pixel (handles modulation) */\r\n  columnToPixelX?: (columnIndex: number, options: CoordinateOptions) => number;\r\n  /** Convert X pixel to column index (handles modulation) */\r\n  pixelXToColumn?: (pixelX: number, options: CoordinateOptions) => number;\r\n}\r\n\r\n/**\r\n * Create coordinate utility functions with injected callbacks\r\n */\r\nexport function createCoordinateUtils(callbacks: CoordinateCallbacks) {\r\n  // Cache for viewport info to avoid recalculating on every row\r\n  let cachedViewportInfo: ViewportInfo | null = null;\r\n  let lastViewportFrame: number | null = null;\r\n\r\n  /**\r\n   * Gets cached viewport info to avoid recalculating on every row\r\n   */\r\n  function getCachedViewportInfo(): ViewportInfo {\r\n    const currentFrame = typeof performance !== 'undefined' ? performance.now() : Date.now();\r\n\r\n    // Invalidate cache if it's from a different frame (1ms threshold)\r\n    if (!cachedViewportInfo || !lastViewportFrame || (currentFrame - lastViewportFrame) > 1) {\r\n      cachedViewportInfo = callbacks.getViewportInfo();\r\n      lastViewportFrame = currentFrame;\r\n    }\r\n\r\n    return cachedViewportInfo;\r\n  }\r\n\r\n  /**\r\n   * Invalidate the viewport cache (call when viewport changes)\r\n   */\r\n  function invalidateViewportCache(): void {\r\n    cachedViewportInfo = null;\r\n    lastViewportFrame = null;\r\n  }\r\n\r\n  /**\r\n   * Gets X position for a canvas-space column index\r\n   * @param index Canvas-space column (0 = first musical beat)\r\n   * @param options Render options with columnWidths\r\n   * @returns X position on musical canvas in pixels\r\n   */\r\n  function getColumnX(index: number, options: CoordinateOptions): number {\r\n    // Use injected callback if available (handles modulation)\r\n    if (callbacks.columnToPixelX) {\r\n      return callbacks.columnToPixelX(index, options);\r\n    }\r\n\r\n    // Fallback: simple cumulative width calculation\r\n    const { columnWidths, cellWidth } = options;\r\n    let x = 0;\r\n    for (let i = 0; i < index && i < columnWidths.length; i++) {\r\n      x += (columnWidths[i] ?? 1) * cellWidth;\r\n    }\r\n    return x;\r\n  }\r\n\r\n  /**\r\n   * Gets Y position for a global row index\r\n   *\r\n   * COORDINATE SYSTEM:\r\n   *   - Canvas Y=0 is at the TOP of the pitch viewport\r\n   *   - The first visible row's TOP EDGE (not center) is at Y=0\r\n   *   - Each row has height = cellHeight (vertical spacing between row centers = halfUnit)\r\n   *\r\n   * @param rowIndex Global row index (index into fullRowData)\r\n   * @param options Render options containing cellHeight\r\n   * @returns Y position of row CENTER on canvas in pixels\r\n   */\r\n  function getRowY(rowIndex: number, options: CoordinateOptions): number {\r\n    const viewportInfo = getCachedViewportInfo();\r\n    const relativeRowIndex = rowIndex - viewportInfo.startRank;\r\n    const halfUnit = options.cellHeight / 2;\r\n    // Row centers are positioned at halfUnit intervals starting from Y=halfUnit\r\n    const yPosition = (relativeRowIndex + 1) * halfUnit;\r\n    return yPosition;\r\n  }\r\n\r\n  /**\r\n   * Converts canvas X to canvas-space column index\r\n   * @param canvasX X position on musical canvas\r\n   * @param options Render options\r\n   * @returns Canvas-space column index (0 = first musical beat)\r\n   */\r\n  function getColumnFromX(canvasX: number, options: CoordinateOptions): number {\r\n    // Use injected callback if available (handles modulation)\r\n    if (callbacks.pixelXToColumn) {\r\n      return callbacks.pixelXToColumn(canvasX, options);\r\n    }\r\n\r\n    // Fallback: binary search through cumulative widths\r\n    const { columnWidths, cellWidth } = options;\r\n    let x = 0;\r\n    for (let i = 0; i < columnWidths.length; i++) {\r\n      const colWidth = (columnWidths[i] ?? 1) * cellWidth;\r\n      if (canvasX < x + colWidth) {\r\n        return i;\r\n      }\r\n      x += colWidth;\r\n    }\r\n    return columnWidths.length - 1;\r\n  }\r\n\r\n  /**\r\n   * Converts canvas Y position to global row index\r\n   * @param canvasY Y position on canvas in pixels\r\n   * @param options Render options containing cellHeight\r\n   * @returns Global row index (fractional for sub-row precision)\r\n   */\r\n  function getRowFromY(canvasY: number, options: CoordinateOptions): number {\r\n    const viewportInfo = getCachedViewportInfo();\r\n    const halfUnit = options.cellHeight / 2;\r\n    // Inverse of getRowY():\r\n    // y = (relative + 1) * halfUnit  =>  relative = (y / halfUnit) - 1\r\n    const relativeRowIndex = (canvasY / halfUnit) - 1;\r\n    return relativeRowIndex + viewportInfo.startRank;\r\n  }\r\n\r\n  /**\r\n   * Get the visible row range\r\n   */\r\n  function getVisibleRowRange(): { startRow: number; endRow: number } {\r\n    const viewportInfo = getCachedViewportInfo();\r\n    const { startRank, endRank } = viewportInfo;\r\n    // Convert to inclusive index\r\n    const endRow = Math.max(startRank, endRank - 1);\r\n    return { startRow: startRank, endRow };\r\n  }\r\n\r\n  /**\r\n   * Get pitch class from pitch string (e.g., \"C4\" -> \"C\")\r\n   */\r\n  function getPitchClass(pitchWithOctave: string): string {\r\n    let pc = (pitchWithOctave || '').replace(/\\d/g, '').trim();\r\n    pc = pc.replace(/b/g, 'b-').replace(/#/g, 'b_');\r\n    return pc;\r\n  }\r\n\r\n  /**\r\n   * Get line style based on pitch class\r\n   */\r\n  function getLineStyleFromPitchClass(pc: string): { lineWidth: number; dash: number[]; color: string } {\r\n    switch (pc) {\r\n      case 'C': return { lineWidth: 3.33, dash: [], color: '#adb5bd' };\r\n      case 'E': return { lineWidth: 1, dash: [5, 5], color: '#adb5bd' };\r\n      case 'G': return { lineWidth: 1, dash: [], color: '#dee2e6' };\r\n      case 'B':\r\n      case 'A':\r\n      case 'F':\r\n      case 'Eb/Db':\r\n      case 'Db/C#':\r\n        return { lineWidth: 1, dash: [], color: '#ced4da' };\r\n      default: return { lineWidth: 1, dash: [], color: '#ced4da' };\r\n    }\r\n  }\r\n\r\n  return {\r\n    getColumnX,\r\n    getRowY,\r\n    getColumnFromX,\r\n    getRowFromY,\r\n    getVisibleRowRange,\r\n    getPitchClass,\r\n    getLineStyleFromPitchClass,\r\n    invalidateViewportCache,\r\n    getCachedViewportInfo\r\n  };\r\n}\r\n\r\nexport type CoordinateUtils = ReturnType<typeof createCoordinateUtils>;\r\n","/**\r\n * Note Renderer\r\n *\r\n * Framework-agnostic note rendering functions for the pitch grid.\r\n * All dependencies are injected via callbacks - no store or service imports.\r\n */\r\n\r\nimport type { PlacedNote, ModulationMarker, DegreeDisplayMode, LongNoteStyle, AccidentalMode } from '@mlt/types';\r\nimport type { CoordinateUtils, CoordinateOptions } from './coordinateUtils.js';\r\n\r\n// Constants\r\nconst SHARP_SYMBOL = '\\u266F';\r\nconst FLAT_SYMBOL = '\\u266D';\r\nconst DEGREE_SEPARATOR = '/';\r\n\r\nconst OVAL_NOTE_FONT_RATIO = 0.35;\r\nconst FILLED_NOTE_FONT_RATIO = 0.5;\r\nconst MIN_FONT_SIZE = 6;\r\nconst MIN_STROKE_WIDTH_THICK = 1;\r\nconst STROKE_WIDTH_RATIO = 0.08;\r\nconst TAIL_LINE_WIDTH_RATIO = 0.04;\r\nconst MIN_TAIL_LINE_WIDTH = 1;\r\nconst SHADOW_BLUR_RADIUS = 4;\r\n\r\n/**\r\n * Animation effects manager interface\r\n */\r\nexport interface AnimationEffectsManager {\r\n  shouldAnimateNote(note: PlacedNote): boolean;\r\n  getVibratoYOffset(color?: string): number;\r\n  shouldFillNote(note: PlacedNote): boolean;\r\n  getFillLevel(note: PlacedNote): number;\r\n  hasReverbEffect?: (color: string) => boolean;\r\n  getReverbEffect?: (color: string) => { opacity: number; blur: number; spread: number };\r\n  hasDelayEffect(color: string): boolean;\r\n  getDelayEffects(color: string): Array<{ delay: number; opacity: number; scale: number; active: boolean }>;\r\n}\r\n\r\n/**\r\n * Scale degree result\r\n */\r\ninterface ScaleDegreeResult {\r\n  label: string | null;\r\n  isAccidental: boolean;\r\n}\r\n\r\n/**\r\n * Degree font result\r\n */\r\ninterface DegreeFontResult {\r\n  multiplier: number;\r\n  category: 'natural' | 'single-accidental' | 'both-accidentals';\r\n}\r\n\r\n/**\r\n * Options for note rendering\r\n */\r\nexport interface NoteRenderOptions extends CoordinateOptions {\r\n  /** All placed notes (for stacking calculations) */\r\n  placedNotes: PlacedNote[];\r\n  /** Degree display mode */\r\n  degreeDisplayMode: DegreeDisplayMode;\r\n  /** Long note rendering style */\r\n  longNoteStyle: LongNoteStyle;\r\n  /** Accidental display mode */\r\n  accidentalMode: AccidentalMode;\r\n}\r\n\r\n/**\r\n * Callbacks for note rendering\r\n */\r\nexport interface NoteRenderCallbacks {\r\n  /** Coordinate utilities */\r\n  coords: CoordinateUtils;\r\n  /** Get scale degree for a note */\r\n  getDegreeForNote?: (note: PlacedNote) => string | null;\r\n  /** Check if degree has accidental */\r\n  hasAccidental?: (degree: string) => boolean;\r\n  /** Get enharmonic degree */\r\n  getEnharmonicDegree?: (degree: string) => string | null;\r\n  /** Get animation effects manager */\r\n  getAnimationEffectsManager?: () => AnimationEffectsManager | undefined;\r\n}\r\n\r\n/**\r\n * Create note renderer with injected callbacks\r\n */\r\nexport function createNoteRenderer(callbacks: NoteRenderCallbacks) {\r\n  const { coords } = callbacks;\r\n\r\n  // Get UUID timestamp for sorting\r\n  function getUuidTimestamp(value?: string): number {\r\n    const timestampSegment = value?.split('-')[1];\r\n    return Number.parseInt(timestampSegment ?? '0', 10);\r\n  }\r\n\r\n  /**\r\n   * Check if note has visible tail (duration extends beyond base shape)\r\n   */\r\n  function hasVisibleTail(note: PlacedNote): boolean {\r\n    if (!note || typeof note.startColumnIndex !== 'number' || typeof note.endColumnIndex !== 'number') {\r\n      return false;\r\n    }\r\n    const baselineEnd = note.shape === 'circle'\r\n      ? note.startColumnIndex + 1\r\n      : note.startColumnIndex;\r\n    return note.endColumnIndex > baselineEnd;\r\n  }\r\n\r\n  /**\r\n   * Check if dimensions are renderable\r\n   */\r\n  function hasRenderableDimensions(width: number, height: number): boolean {\r\n    return Number.isFinite(width) && width > 0 && Number.isFinite(height) && height > 0;\r\n  }\r\n\r\n  /**\r\n   * Calculate horizontal offset for stacked notes at same position\r\n   */\r\n  function calculateColorOffset(note: PlacedNote, allNotes: PlacedNote[], options: NoteRenderOptions): number {\r\n    const { cellWidth } = options;\r\n    const offsetAmount = cellWidth * 0.25;\r\n\r\n    const noteUuid = note.uuid;\r\n    if (!noteUuid) return 0;\r\n\r\n    const notesAtSamePosition = allNotes.filter(otherNote =>\r\n      !otherNote.isDrum &&\r\n      otherNote.row === note.row &&\r\n      otherNote.startColumnIndex === note.startColumnIndex &&\r\n      otherNote.uuid &&\r\n      otherNote.uuid !== noteUuid\r\n    );\r\n\r\n    if (notesAtSamePosition.length === 0) return 0;\r\n\r\n    const allNotesAtPosition = [note, ...notesAtSamePosition];\r\n    allNotesAtPosition.sort((a, b) => getUuidTimestamp(a.uuid) - getUuidTimestamp(b.uuid));\r\n\r\n    const currentNoteIndex = allNotesAtPosition.findIndex(n => n.uuid === noteUuid);\r\n    return currentNoteIndex * offsetAmount;\r\n  }\r\n\r\n  /**\r\n   * Calculate vibrato Y offset\r\n   */\r\n  function calculateVibratoYOffset(note: PlacedNote, options: NoteRenderOptions): number {\r\n    const { cellHeight } = options;\r\n    const animationManager = callbacks.getAnimationEffectsManager?.();\r\n\r\n    if (!animationManager?.shouldAnimateNote?.(note)) return 0;\r\n\r\n    const vibratoOffset = animationManager.getVibratoYOffset?.(note.color) ?? 0;\r\n    return vibratoOffset * cellHeight;\r\n  }\r\n\r\n  /**\r\n   * Calculate tail Y offset for stacked long notes\r\n   */\r\n  function calculateTailYOffset(note: PlacedNote, allNotes: PlacedNote[], options: NoteRenderOptions): number {\r\n    const { cellHeight } = options;\r\n    const tailOffsetAmount = (cellHeight / 2) * 0.12;\r\n\r\n    const noteUuid = note.uuid;\r\n    if (!noteUuid) return 0;\r\n\r\n    const notesWithTailsAtSamePosition = allNotes.filter(otherNote =>\r\n      !otherNote.isDrum &&\r\n      otherNote.row === note.row &&\r\n      otherNote.startColumnIndex === note.startColumnIndex &&\r\n      otherNote.uuid &&\r\n      otherNote.uuid !== noteUuid &&\r\n      hasVisibleTail(otherNote)\r\n    );\r\n\r\n    if (notesWithTailsAtSamePosition.length === 0) return 0;\r\n\r\n    const allNotesWithTailsAtPosition = [note, ...notesWithTailsAtSamePosition];\r\n    allNotesWithTailsAtPosition.sort((a, b) => getUuidTimestamp(a.uuid) - getUuidTimestamp(b.uuid));\r\n\r\n    const currentNoteIndex = allNotesWithTailsAtPosition.findIndex(n => n.uuid === noteUuid);\r\n    return currentNoteIndex * tailOffsetAmount;\r\n  }\r\n\r\n  /**\r\n   * Get scale degree label for a note\r\n   */\r\n  function getScaleDegreeLabel(note: PlacedNote, options: NoteRenderOptions): ScaleDegreeResult {\r\n    const degreeStr = callbacks.getDegreeForNote?.(note);\r\n    if (!degreeStr) return { label: null, isAccidental: false };\r\n\r\n    const isAccidental = callbacks.hasAccidental?.(degreeStr) ?? false;\r\n    if (!isAccidental) return { label: degreeStr, isAccidental: false };\r\n\r\n    const accidentalMode = options.accidentalMode || {};\r\n    const sharpEnabled = accidentalMode.sharp ?? true;\r\n    const flatEnabled = accidentalMode.flat ?? true;\r\n\r\n    if (!sharpEnabled && !flatEnabled) return { label: null, isAccidental: true };\r\n\r\n    let sharpLabel = degreeStr.includes(SHARP_SYMBOL) ? degreeStr : null;\r\n    let flatLabel = degreeStr.includes(FLAT_SYMBOL) ? degreeStr : null;\r\n    const enharmonic = callbacks.getEnharmonicDegree?.(degreeStr);\r\n\r\n    if (enharmonic) {\r\n      if (enharmonic.includes(SHARP_SYMBOL) && !sharpLabel) sharpLabel = enharmonic;\r\n      if (enharmonic.includes(FLAT_SYMBOL) && !flatLabel) flatLabel = enharmonic;\r\n    }\r\n\r\n    let label: string | null = null;\r\n    if (sharpEnabled && flatEnabled) {\r\n      const parts: string[] = [];\r\n      if (sharpLabel) parts.push(sharpLabel);\r\n      if (flatLabel && (!sharpLabel || flatLabel !== sharpLabel)) parts.push(flatLabel);\r\n      label = parts.join(DEGREE_SEPARATOR);\r\n      if (!label) label = degreeStr;\r\n    } else if (sharpEnabled) {\r\n      label = sharpLabel || degreeStr;\r\n    } else if (flatEnabled) {\r\n      label = flatLabel || degreeStr;\r\n    }\r\n\r\n    return { label, isAccidental: true };\r\n  }\r\n\r\n  /**\r\n   * Get font multiplier based on degree label content\r\n   */\r\n  function getDegreeFontMultiplier(label: string | null): DegreeFontResult {\r\n    if (!label) return { multiplier: 1.0, category: 'natural' };\r\n\r\n    const hasFlat = label.includes(FLAT_SYMBOL);\r\n    const hasSharp = label.includes(SHARP_SYMBOL);\r\n    const hasBothAccidentals = label.includes(DEGREE_SEPARATOR);\r\n\r\n    if (!hasFlat && !hasSharp) return { multiplier: 1.0, category: 'natural' };\r\n    if (hasBothAccidentals) return { multiplier: 0.75, category: 'both-accidentals' };\r\n    return { multiplier: 0.88, category: 'single-accidental' };\r\n  }\r\n\r\n  /**\r\n   * Draw scale degree text inside a note\r\n   */\r\n  function drawScaleDegreeText(\r\n    ctx: CanvasRenderingContext2D,\r\n    note: PlacedNote,\r\n    options: NoteRenderOptions,\r\n    centerX: number,\r\n    centerY: number,\r\n    noteWidth: number\r\n  ): void {\r\n    const { label: noteLabel } = getScaleDegreeLabel(note, options);\r\n    if (!noteLabel) return;\r\n\r\n    const { multiplier: contentMultiplier, category } = getDegreeFontMultiplier(noteLabel);\r\n    let baseFontSize: number;\r\n\r\n    if (note.shape === 'circle') {\r\n      const circleBaseSize = noteWidth * 2 * FILLED_NOTE_FONT_RATIO;\r\n      switch (category) {\r\n        case 'natural': baseFontSize = circleBaseSize; break;\r\n        case 'single-accidental': baseFontSize = circleBaseSize * 0.8; break;\r\n        case 'both-accidentals': baseFontSize = circleBaseSize * 0.4; break;\r\n        default: baseFontSize = circleBaseSize * contentMultiplier;\r\n      }\r\n    } else {\r\n      const ovalBaseSize = noteWidth * 2 * OVAL_NOTE_FONT_RATIO;\r\n      switch (category) {\r\n        case 'natural': baseFontSize = ovalBaseSize * 1.5; break;\r\n        case 'single-accidental': baseFontSize = ovalBaseSize * 1.2; break;\r\n        case 'both-accidentals': baseFontSize = ovalBaseSize; break;\r\n        default: baseFontSize = ovalBaseSize * contentMultiplier;\r\n      }\r\n    }\r\n\r\n    if (baseFontSize < MIN_FONT_SIZE) return;\r\n\r\n    ctx.fillStyle = '#212529';\r\n    ctx.font = `bold ${baseFontSize}px 'Atkinson Hyperlegible', sans-serif`;\r\n    ctx.textAlign = 'center';\r\n    ctx.textBaseline = 'middle';\r\n\r\n    if (note.shape === 'oval' && category === 'both-accidentals' && noteLabel.includes(DEGREE_SEPARATOR)) {\r\n      const parts = noteLabel.split(DEGREE_SEPARATOR);\r\n      const lineHeight = baseFontSize * 1.1;\r\n      const totalHeight = lineHeight * (parts.length - 1);\r\n      const startY = centerY - (totalHeight / 2);\r\n\r\n      parts.forEach((part, index) => {\r\n        const y = startY + (index * lineHeight);\r\n        const opticalOffset = baseFontSize * 0.08;\r\n        ctx.fillText(part.trim(), centerX, y + opticalOffset);\r\n      });\r\n    } else {\r\n      const opticalOffset = baseFontSize * 0.08;\r\n      ctx.fillText(noteLabel, centerX, centerY + opticalOffset);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply reverb glow effect\r\n   */\r\n  function applyReverbGlow(\r\n    ctx: CanvasRenderingContext2D,\r\n    note: PlacedNote,\r\n    options: NoteRenderOptions\r\n  ): { shouldApply: boolean; blur: number; spread: number } {\r\n    const animationManager = callbacks.getAnimationEffectsManager?.();\r\n    const hasReverbEffect = animationManager?.hasReverbEffect;\r\n    const shouldCheckReverb = typeof hasReverbEffect === 'function'\r\n      ? hasReverbEffect(note.color)\r\n      : Boolean(hasReverbEffect);\r\n\r\n    if (!shouldCheckReverb) return { shouldApply: false, blur: 0, spread: 0 };\r\n\r\n    const { cellWidth } = options;\r\n    const reverbEffect = animationManager?.getReverbEffect?.(note.color);\r\n    if (!reverbEffect) return { shouldApply: false, blur: 0, spread: 0 };\r\n\r\n    const blur = reverbEffect.blur * (cellWidth / 2);\r\n    const spread = reverbEffect.spread * (cellWidth / 3);\r\n\r\n    return { shouldApply: blur > 0 || spread > 0, blur, spread };\r\n  }\r\n\r\n  /**\r\n   * Draw delay ghost notes\r\n   */\r\n  function drawDelayGhostNotes(\r\n    ctx: CanvasRenderingContext2D,\r\n    note: PlacedNote,\r\n    options: NoteRenderOptions,\r\n    centerX: number,\r\n    centerY: number,\r\n    rx: number,\r\n    ry: number\r\n  ): void {\r\n    const animationManager = callbacks.getAnimationEffectsManager?.();\r\n    if (!animationManager?.hasDelayEffect?.(note.color)) return;\r\n\r\n    const { cellWidth } = options;\r\n    const delayEffects = animationManager.getDelayEffects?.(note.color);\r\n    if (!delayEffects || delayEffects.length === 0) return;\r\n\r\n    delayEffects.forEach((echo) => {\r\n      const offsetX = (echo.delay / 500) * cellWidth * 2;\r\n      const echoX = centerX + offsetX;\r\n      const echoRx = rx * echo.scale;\r\n      const echoRy = ry * echo.scale;\r\n\r\n      ctx.save();\r\n      ctx.globalAlpha = echo.opacity * 0.6;\r\n\r\n      ctx.beginPath();\r\n      ctx.ellipse(echoX, centerY, echoRx, echoRy, 0, 0, 2 * Math.PI);\r\n      ctx.strokeStyle = note.color;\r\n      ctx.lineWidth = Math.max(0.5, echoRx * 0.1);\r\n      ctx.setLineDash([2, 2]);\r\n      ctx.stroke();\r\n\r\n      ctx.restore();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Draw envelope fill effect\r\n   */\r\n  function drawEnvelopeFill(\r\n    ctx: CanvasRenderingContext2D,\r\n    note: PlacedNote,\r\n    centerX: number,\r\n    centerY: number,\r\n    rx: number,\r\n    ry: number\r\n  ): void {\r\n    const animationManager = callbacks.getAnimationEffectsManager?.();\r\n    if (!animationManager?.shouldFillNote?.(note)) return;\r\n\r\n    const fillLevel = animationManager.getFillLevel?.(note) ?? 0;\r\n    if (fillLevel <= 0) return;\r\n\r\n    ctx.save();\r\n\r\n    const innerRatio = 1 - fillLevel;\r\n    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(rx, ry));\r\n    gradient.addColorStop(0, 'transparent');\r\n    gradient.addColorStop(Math.max(0, innerRatio - 0.05), 'transparent');\r\n    gradient.addColorStop(innerRatio, `${note.color}1F`);\r\n    gradient.addColorStop(1, `${note.color}BF`);\r\n\r\n    ctx.beginPath();\r\n    ctx.ellipse(centerX, centerY, rx, ry, 0, 0, 2 * Math.PI);\r\n    ctx.clip();\r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(centerX - rx - 10, centerY - ry - 10, (rx + 10) * 2, (ry + 10) * 2);\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Draw envelope fill for stadium shape\r\n   */\r\n  function drawEnvelopeFillStadium(\r\n    ctx: CanvasRenderingContext2D,\r\n    note: PlacedNote,\r\n    leftCenterX: number,\r\n    rightCenterX: number,\r\n    centerY: number,\r\n    ry: number\r\n  ): void {\r\n    const animationManager = callbacks.getAnimationEffectsManager?.();\r\n    if (!animationManager?.shouldFillNote?.(note)) return;\r\n\r\n    const fillLevel = animationManager.getFillLevel?.(note) ?? 0;\r\n    if (fillLevel <= 0) return;\r\n\r\n    ctx.save();\r\n\r\n    // Create the stadium clip path\r\n    ctx.beginPath();\r\n    ctx.arc(leftCenterX, centerY, ry, Math.PI / 2, -Math.PI / 2, false);\r\n    ctx.lineTo(rightCenterX, centerY - ry);\r\n    ctx.arc(rightCenterX, centerY, ry, -Math.PI / 2, Math.PI / 2, false);\r\n    ctx.lineTo(leftCenterX, centerY + ry);\r\n    ctx.closePath();\r\n    ctx.clip();\r\n\r\n    const stadiumCenterX = (leftCenterX + rightCenterX) / 2;\r\n    const stadiumWidth = rightCenterX - leftCenterX;\r\n    const gradientRadius = Math.max(stadiumWidth / 2 + ry, ry);\r\n\r\n    const innerRatio = 1 - fillLevel;\r\n    const gradient = ctx.createRadialGradient(stadiumCenterX, centerY, 0, stadiumCenterX, centerY, gradientRadius);\r\n    gradient.addColorStop(0, 'transparent');\r\n    gradient.addColorStop(Math.max(0, innerRatio - 0.05), 'transparent');\r\n    gradient.addColorStop(innerRatio, `${note.color}1F`);\r\n    gradient.addColorStop(1, `${note.color}BF`);\r\n\r\n    ctx.fillStyle = gradient;\r\n    ctx.fillRect(leftCenterX - ry - 10, centerY - ry - 10, stadiumWidth + (ry + 10) * 2, (ry + 10) * 2);\r\n\r\n    ctx.restore();\r\n  }\r\n\r\n  /**\r\n   * Draw stadium shape for long notes (style 2)\r\n   */\r\n  function drawStadiumShape(\r\n    ctx: CanvasRenderingContext2D,\r\n    note: PlacedNote,\r\n    options: NoteRenderOptions,\r\n    leftCenterX: number,\r\n    rightCenterX: number,\r\n    centerY: number,\r\n    ry: number,\r\n    strokeWidth: number\r\n  ): void {\r\n    drawEnvelopeFillStadium(ctx, note, leftCenterX, rightCenterX, centerY, ry);\r\n\r\n    ctx.save();\r\n    ctx.beginPath();\r\n    ctx.arc(leftCenterX, centerY, ry, Math.PI / 2, -Math.PI / 2, false);\r\n    ctx.lineTo(rightCenterX, centerY - ry);\r\n    ctx.arc(rightCenterX, centerY, ry, -Math.PI / 2, Math.PI / 2, false);\r\n    ctx.lineTo(leftCenterX, centerY + ry);\r\n    ctx.closePath();\r\n\r\n    ctx.strokeStyle = note.color;\r\n    ctx.lineWidth = strokeWidth;\r\n    ctx.shadowColor = note.color;\r\n    ctx.shadowBlur = SHADOW_BLUR_RADIUS;\r\n    ctx.stroke();\r\n    ctx.shadowBlur = 0;\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.restore();\r\n\r\n    if (options.degreeDisplayMode !== 'off') {\r\n      const stadiumCenterX = (leftCenterX + rightCenterX) / 2;\r\n      drawScaleDegreeText(ctx, note, options, stadiumCenterX, centerY, ry);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw a two-column oval note (circle notes)\r\n   */\r\n  function drawTwoColumnOvalNote(\r\n    ctx: CanvasRenderingContext2D,\r\n    options: NoteRenderOptions,\r\n    note: PlacedNote,\r\n    rowIndex: number\r\n  ): void {\r\n    const { cellWidth, cellHeight, tempoModulationMarkers, placedNotes } = options;\r\n    const baseY = coords.getRowY(rowIndex, options);\r\n    const vibratoYOffset = calculateVibratoYOffset(note, options);\r\n    const y = baseY + vibratoYOffset;\r\n    const xStart = coords.getColumnX(note.startColumnIndex, options);\r\n\r\n    let actualCellWidth: number;\r\n    if (tempoModulationMarkers && tempoModulationMarkers.length > 0) {\r\n      const nextX = coords.getColumnX(note.startColumnIndex + 1, options);\r\n      actualCellWidth = nextX - xStart;\r\n    } else {\r\n      actualCellWidth = cellWidth;\r\n    }\r\n\r\n    if (!hasRenderableDimensions(actualCellWidth, cellHeight)) return;\r\n\r\n    const xOffset = calculateColorOffset(note, placedNotes, options);\r\n    const centerX = xStart + actualCellWidth + xOffset;\r\n    const dynamicStrokeWidth = Math.max(MIN_STROKE_WIDTH_THICK, actualCellWidth * STROKE_WIDTH_RATIO);\r\n    const ry = (cellHeight / 2) - (dynamicStrokeWidth / 2);\r\n\r\n    const hasTail = hasVisibleTail(note);\r\n    const longNoteStyle = options.longNoteStyle || 'style1';\r\n\r\n    if (hasTail && longNoteStyle === 'style2') {\r\n      const leftCenterX = centerX;\r\n      const rightCenterX = coords.getColumnX(note.endColumnIndex, options);\r\n\r\n      if (!hasRenderableDimensions(rightCenterX - leftCenterX, ry)) return;\r\n\r\n      drawStadiumShape(ctx, note, options, leftCenterX, rightCenterX, y, ry, dynamicStrokeWidth);\r\n      return;\r\n    }\r\n\r\n    // Style 1: Tail line + circle\r\n    if (hasTail) {\r\n      const originalEndX = coords.getColumnX(note.endColumnIndex + 1, options);\r\n      const tailYOffset = calculateTailYOffset(note, placedNotes, options);\r\n      const tailY = y + tailYOffset;\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(centerX, tailY);\r\n      ctx.lineTo(originalEndX, tailY);\r\n      ctx.strokeStyle = note.color;\r\n      ctx.lineWidth = Math.max(MIN_TAIL_LINE_WIDTH, actualCellWidth * TAIL_LINE_WIDTH_RATIO);\r\n      ctx.stroke();\r\n    }\r\n\r\n    const rx = actualCellWidth - (dynamicStrokeWidth / 2);\r\n\r\n    if (!hasRenderableDimensions(rx, ry)) return;\r\n\r\n    drawDelayGhostNotes(ctx, note, options, centerX, y, rx, ry);\r\n\r\n    ctx.save();\r\n    drawEnvelopeFill(ctx, note, centerX, y, rx, ry);\r\n\r\n    const reverbGlow = applyReverbGlow(ctx, note, options);\r\n    if (reverbGlow.shouldApply) {\r\n      ctx.shadowColor = note.color;\r\n      ctx.shadowBlur = SHADOW_BLUR_RADIUS + reverbGlow.blur;\r\n      ctx.shadowOffsetX = reverbGlow.spread;\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.ellipse(centerX, y, rx, ry, 0, 0, 2 * Math.PI);\r\n    ctx.strokeStyle = note.color;\r\n    ctx.lineWidth = dynamicStrokeWidth;\r\n    if (!reverbGlow.shouldApply) {\r\n      ctx.shadowColor = note.color;\r\n      ctx.shadowBlur = SHADOW_BLUR_RADIUS;\r\n    }\r\n    ctx.stroke();\r\n    ctx.shadowBlur = 0;\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowOffsetX = 0;\r\n    ctx.restore();\r\n\r\n    if (options.degreeDisplayMode !== 'off') {\r\n      drawScaleDegreeText(ctx, note, options, centerX, y, rx);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw a single-column oval note\r\n   */\r\n  function drawSingleColumnOvalNote(\r\n    ctx: CanvasRenderingContext2D,\r\n    options: NoteRenderOptions,\r\n    note: PlacedNote,\r\n    rowIndex: number\r\n  ): void {\r\n    const { columnWidths, cellWidth, cellHeight, tempoModulationMarkers, placedNotes } = options;\r\n    const baseY = coords.getRowY(rowIndex, options);\r\n    const vibratoYOffset = calculateVibratoYOffset(note, options);\r\n    const y = baseY + vibratoYOffset;\r\n    const x = coords.getColumnX(note.startColumnIndex, options);\r\n\r\n    let currentCellWidth: number;\r\n    if (tempoModulationMarkers && tempoModulationMarkers.length > 0) {\r\n      const nextX = coords.getColumnX(note.startColumnIndex + 1, options);\r\n      currentCellWidth = nextX - x;\r\n    } else {\r\n      currentCellWidth = (columnWidths[note.startColumnIndex] ?? 1) * cellWidth;\r\n    }\r\n\r\n    if (!hasRenderableDimensions(currentCellWidth, cellHeight)) return;\r\n\r\n    const xOffset = calculateColorOffset(note, placedNotes, options);\r\n    const dynamicStrokeWidth = Math.max(0.5, currentCellWidth * 0.15);\r\n    const cx = x + currentCellWidth / 2 + xOffset;\r\n    const rx = (currentCellWidth / 2) - (dynamicStrokeWidth / 2);\r\n    const ry = (cellHeight / 2) - (dynamicStrokeWidth / 2);\r\n\r\n    if (!hasRenderableDimensions(rx, ry)) return;\r\n\r\n    drawDelayGhostNotes(ctx, note, options, cx, y, rx, ry);\r\n\r\n    ctx.save();\r\n    drawEnvelopeFill(ctx, note, cx, y, rx, ry);\r\n\r\n    const reverbGlow = applyReverbGlow(ctx, note, options);\r\n    if (reverbGlow.shouldApply) {\r\n      ctx.shadowColor = note.color;\r\n      ctx.shadowBlur = SHADOW_BLUR_RADIUS + reverbGlow.blur;\r\n      ctx.shadowOffsetX = reverbGlow.spread;\r\n    }\r\n\r\n    ctx.beginPath();\r\n    ctx.ellipse(cx, y, rx, ry, 0, 0, 2 * Math.PI);\r\n    ctx.strokeStyle = note.color;\r\n    ctx.lineWidth = dynamicStrokeWidth;\r\n    if (!reverbGlow.shouldApply) {\r\n      ctx.shadowColor = note.color;\r\n      ctx.shadowBlur = SHADOW_BLUR_RADIUS;\r\n    }\r\n    ctx.stroke();\r\n    ctx.shadowBlur = 0;\r\n    ctx.shadowColor = 'transparent';\r\n    ctx.shadowOffsetX = 0;\r\n    ctx.restore();\r\n\r\n    if (options.degreeDisplayMode !== 'off') {\r\n      drawScaleDegreeText(ctx, note, options, cx, y, rx);\r\n    }\r\n  }\r\n\r\n  return {\r\n    drawTwoColumnOvalNote,\r\n    drawSingleColumnOvalNote,\r\n    hasVisibleTail\r\n  };\r\n}\r\n\r\nexport type NoteRenderer = ReturnType<typeof createNoteRenderer>;\r\n","/**\r\n * Grid Lines Renderer\r\n *\r\n * Framework-agnostic grid line rendering for the pitch grid.\r\n * All dependencies are injected via callbacks - no store or service imports.\r\n */\r\n\r\nimport type { MacrobeatGrouping, PitchRowData, TonicSign } from '@mlt/types';\r\nimport type { CoordinateUtils, CoordinateOptions } from './coordinateUtils.js';\r\n\r\n/**\r\n * Macrobeat info for a specific beat\r\n */\r\nexport interface MacrobeatInfo {\r\n  startColumn: number;\r\n  endColumn: number;\r\n  grouping: 2 | 3;\r\n}\r\n\r\n/**\r\n * Options for grid line rendering\r\n */\r\nexport interface GridLineRenderOptions extends CoordinateOptions {\r\n  /** Full row data for pitch classes */\r\n  fullRowData: PitchRowData[];\r\n  /** Macrobeat groupings */\r\n  macrobeatGroupings: MacrobeatGrouping[];\r\n  /** Macrobeat boundary styles */\r\n  macrobeatBoundaryStyles: string[];\r\n  /** Whether piece has anacrusis (pickup measure) */\r\n  hasAnacrusis: boolean;\r\n  /** Canvas width in pixels */\r\n  canvasWidth: number;\r\n  /** Canvas height in pixels */\r\n  canvasHeight: number;\r\n}\r\n\r\n/**\r\n * Callbacks for grid line rendering\r\n */\r\nexport interface GridLineRenderCallbacks {\r\n  /** Coordinate utilities */\r\n  coords: CoordinateUtils;\r\n  /** Get macrobeat info by index */\r\n  getMacrobeatInfo?: (index: number) => MacrobeatInfo | null;\r\n  /** Get placed tonic signs */\r\n  getPlacedTonicSigns?: () => TonicSign[];\r\n  /** Get tonic span column indices */\r\n  getTonicSpanColumnIndices?: (tonicSigns: TonicSign[]) => Set<number>;\r\n  /** Get anacrusis background colors from CSS */\r\n  getAnacrusisColors?: () => { background: string; border: string };\r\n}\r\n\r\n/**\r\n * Create grid line renderer with injected callbacks\r\n */\r\nexport function createGridLineRenderer(callbacks: GridLineRenderCallbacks) {\r\n  const { coords } = callbacks;\r\n\r\n  /**\r\n   * Draw horizontal grid lines\r\n   */\r\n  function drawHorizontalLines(\r\n    ctx: CanvasRenderingContext2D,\r\n    options: GridLineRenderOptions\r\n  ): void {\r\n    const { fullRowData, canvasWidth, cellHeight } = options;\r\n    const { startRow, endRow } = coords.getVisibleRowRange();\r\n\r\n    for (let i = startRow; i <= endRow; i++) {\r\n      const row = fullRowData[i];\r\n      if (!row) continue;\r\n\r\n      const y = coords.getRowY(i, options);\r\n      const pc = coords.getPitchClass(row.toneNote);\r\n      const style = coords.getLineStyleFromPitchClass(pc);\r\n\r\n      ctx.beginPath();\r\n      ctx.moveTo(0, y);\r\n      ctx.lineTo(canvasWidth, y);\r\n      ctx.strokeStyle = style.color;\r\n      ctx.lineWidth = style.lineWidth;\r\n      ctx.setLineDash(style.dash);\r\n      ctx.stroke();\r\n      ctx.setLineDash([]);\r\n\r\n      // Draw filled rectangle for G lines\r\n      if (pc === 'G') {\r\n        const halfUnit = cellHeight / 2;\r\n        ctx.fillStyle = '#f8f9fa';\r\n        ctx.fillRect(0, y - halfUnit, canvasWidth, halfUnit);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw vertical grid lines (beat lines)\r\n   */\r\n  function drawVerticalLines(\r\n    ctx: CanvasRenderingContext2D,\r\n    options: GridLineRenderOptions\r\n  ): void {\r\n    const {\r\n      columnWidths,\r\n      macrobeatBoundaryStyles,\r\n      hasAnacrusis,\r\n      canvasHeight\r\n    } = options;\r\n\r\n    const placedTonicSigns = callbacks.getPlacedTonicSigns?.() ?? [];\r\n    const tonicSpanColumns = callbacks.getTonicSpanColumnIndices?.(placedTonicSigns) ?? new Set();\r\n    const anacrusisColors = callbacks.getAnacrusisColors?.() ?? {\r\n      background: 'rgba(173, 181, 189, 0.15)',\r\n      border: 'rgba(173, 181, 189, 0.3)'\r\n    };\r\n\r\n    // Track anacrusis region\r\n    let inAnacrusis = hasAnacrusis;\r\n    let anacrusisStartX = 0;\r\n    let macrobeatIndex = 0;\r\n\r\n    // Draw beat lines\r\n    let x = 0;\r\n    for (let i = 0; i <= columnWidths.length; i++) {\r\n      const lineX = coords.getColumnX(i, options);\r\n\r\n      // Check if this is a macrobeat boundary\r\n      const macrobeatInfo = callbacks.getMacrobeatInfo?.(macrobeatIndex);\r\n      const isMacrobeatBoundary = macrobeatInfo && macrobeatInfo.startColumn === i;\r\n\r\n      if (isMacrobeatBoundary) {\r\n        const boundaryStyle = macrobeatBoundaryStyles[macrobeatIndex] ?? 'solid';\r\n\r\n        // Draw anacrusis background\r\n        if (inAnacrusis && boundaryStyle === 'solid') {\r\n          ctx.fillStyle = anacrusisColors.background;\r\n          ctx.fillRect(anacrusisStartX, 0, lineX - anacrusisStartX, canvasHeight);\r\n          inAnacrusis = false;\r\n        }\r\n\r\n        // Draw boundary line\r\n        ctx.beginPath();\r\n        ctx.moveTo(lineX, 0);\r\n        ctx.lineTo(lineX, canvasHeight);\r\n\r\n        if (boundaryStyle === 'anacrusis') {\r\n          ctx.strokeStyle = anacrusisColors.border;\r\n          ctx.setLineDash([5, 5]);\r\n          ctx.lineWidth = 1;\r\n        } else if (boundaryStyle === 'dashed') {\r\n          ctx.strokeStyle = '#adb5bd';\r\n          ctx.setLineDash([5, 5]);\r\n          ctx.lineWidth = 1;\r\n        } else {\r\n          ctx.strokeStyle = '#adb5bd';\r\n          ctx.setLineDash([]);\r\n          ctx.lineWidth = 2;\r\n        }\r\n\r\n        ctx.stroke();\r\n        ctx.setLineDash([]);\r\n\r\n        macrobeatIndex++;\r\n      } else if (i > 0 && !tonicSpanColumns.has(i - 1)) {\r\n        // Regular beat line (not at macrobeat boundary, not in tonic column)\r\n        ctx.beginPath();\r\n        ctx.moveTo(lineX, 0);\r\n        ctx.lineTo(lineX, canvasHeight);\r\n        ctx.strokeStyle = '#dee2e6';\r\n        ctx.lineWidth = 1;\r\n        ctx.stroke();\r\n      }\r\n\r\n      // Draw tonic column highlighting\r\n      if (tonicSpanColumns.has(i)) {\r\n        const colWidth = (columnWidths[i] ?? 1) * options.cellWidth;\r\n        ctx.fillStyle = 'rgba(255, 193, 7, 0.1)';\r\n        ctx.fillRect(lineX, 0, colWidth, canvasHeight);\r\n      }\r\n\r\n      x = lineX;\r\n    }\r\n  }\r\n\r\n  return {\r\n    drawHorizontalLines,\r\n    drawVerticalLines\r\n  };\r\n}\r\n\r\nexport type GridLineRenderer = ReturnType<typeof createGridLineRenderer>;\r\n","/**\r\n * Pitch Grid Renderer\r\n *\r\n * Main orchestrator for pitch grid canvas rendering.\r\n * Uses modular sub-renderers with dependency injection.\r\n */\r\n\r\nimport type {\r\n  PlacedNote,\r\n  TonicSign,\r\n  PitchRowData,\r\n  MacrobeatGrouping,\r\n  ModulationMarker,\r\n  DegreeDisplayMode,\r\n  LongNoteStyle,\r\n  AccidentalMode,\r\n} from '@mlt/types';\r\n\r\nimport { createCoordinateUtils, type ViewportInfo } from './coordinateUtils.js';\r\nimport { createNoteRenderer, type AnimationEffectsManager } from './notes.js';\r\nimport { createGridLineRenderer, type MacrobeatInfo } from './gridLines.js';\r\n\r\n/**\r\n * Options for rendering the pitch grid\r\n */\r\nexport interface PitchGridRenderOptions {\r\n  /** Placed notes to render */\r\n  placedNotes: PlacedNote[];\r\n  /** Placed tonic signs */\r\n  placedTonicSigns: TonicSign[];\r\n  /** Full row data for all pitches */\r\n  fullRowData: PitchRowData[];\r\n  /** Column widths (multipliers) */\r\n  columnWidths: number[];\r\n  /** Base cell width in pixels */\r\n  cellWidth: number;\r\n  /** Base cell height in pixels */\r\n  cellHeight: number;\r\n  /** Row height (usually same as cellHeight) */\r\n  rowHeight: number;\r\n  /** Macrobeat groupings (2 or 3) */\r\n  macrobeatGroupings: MacrobeatGrouping[];\r\n  /** Macrobeat boundary styles */\r\n  macrobeatBoundaryStyles: string[];\r\n  /** Accidental display mode */\r\n  accidentalMode: AccidentalMode;\r\n  /** Whether to show frequency labels */\r\n  showFrequencyLabels: boolean;\r\n  /** Whether to show octave labels */\r\n  showOctaveLabels: boolean;\r\n  /** Color mode (color or black/white) */\r\n  colorMode: 'color' | 'bw';\r\n  /** Degree display mode */\r\n  degreeDisplayMode: DegreeDisplayMode;\r\n  /** Long note rendering style */\r\n  longNoteStyle: LongNoteStyle;\r\n  /** Zoom level */\r\n  zoomLevel: number;\r\n  /** Viewport height */\r\n  viewportHeight: number;\r\n  /** Modulation markers */\r\n  tempoModulationMarkers: ModulationMarker[];\r\n  /** Whether piece has anacrusis */\r\n  hasAnacrusis: boolean;\r\n}\r\n\r\n/**\r\n * Callbacks for pitch grid rendering\r\n */\r\nexport interface PitchGridRenderCallbacks {\r\n  /** Get viewport info (visible row range) */\r\n  getViewportInfo: () => ViewportInfo;\r\n  /** Convert column index to X pixel (handles modulation) */\r\n  columnToPixelX?: (columnIndex: number, options: PitchGridRenderOptions) => number;\r\n  /** Convert X pixel to column index (handles modulation) */\r\n  pixelXToColumn?: (pixelX: number, options: PitchGridRenderOptions) => number;\r\n  /** Get macrobeat info by index */\r\n  getMacrobeatInfo?: (index: number) => MacrobeatInfo | null;\r\n  /** Get tonic span column indices */\r\n  getTonicSpanColumnIndices?: (tonicSigns: TonicSign[]) => Set<number>;\r\n  /** Get anacrusis background colors from CSS */\r\n  getAnacrusisColors?: () => { background: string; border: string };\r\n  /** Get scale degree for a note */\r\n  getDegreeForNote?: (note: PlacedNote) => string | null;\r\n  /** Check if degree has accidental */\r\n  hasAccidental?: (degree: string) => boolean;\r\n  /** Get enharmonic degree */\r\n  getEnharmonicDegree?: (degree: string) => string | null;\r\n  /** Get animation effects manager */\r\n  getAnimationEffectsManager?: () => AnimationEffectsManager | undefined;\r\n}\r\n\r\n/**\r\n * Render the pitch grid to a canvas context\r\n *\r\n * This is the main entry point for pitch grid rendering.\r\n * It orchestrates the sub-renderers (grid lines, notes) with proper layering.\r\n */\r\nexport function renderPitchGrid(\r\n  ctx: CanvasRenderingContext2D,\r\n  options: PitchGridRenderOptions,\r\n  callbacks: PitchGridRenderCallbacks\r\n): void {\r\n  const canvasWidth = ctx.canvas.width;\r\n  const canvasHeight = ctx.canvas.height;\r\n\r\n  // Clear canvas\r\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n  // Create coordinate utilities\r\n  const coords = createCoordinateUtils({\r\n    getViewportInfo: callbacks.getViewportInfo,\r\n    columnToPixelX: callbacks.columnToPixelX\r\n      ? (index, opts) => callbacks.columnToPixelX!(index, options)\r\n      : undefined,\r\n    pixelXToColumn: callbacks.pixelXToColumn\r\n      ? (x, opts) => callbacks.pixelXToColumn!(x, options)\r\n      : undefined\r\n  });\r\n\r\n  // Create grid line renderer\r\n  const gridLines = createGridLineRenderer({\r\n    coords,\r\n    getMacrobeatInfo: callbacks.getMacrobeatInfo,\r\n    getPlacedTonicSigns: () => options.placedTonicSigns,\r\n    getTonicSpanColumnIndices: callbacks.getTonicSpanColumnIndices,\r\n    getAnacrusisColors: callbacks.getAnacrusisColors\r\n  });\r\n\r\n  // Create note renderer\r\n  const noteRenderer = createNoteRenderer({\r\n    coords,\r\n    getDegreeForNote: callbacks.getDegreeForNote,\r\n    hasAccidental: callbacks.hasAccidental,\r\n    getEnharmonicDegree: callbacks.getEnharmonicDegree,\r\n    getAnimationEffectsManager: callbacks.getAnimationEffectsManager\r\n  });\r\n\r\n  // Build render options for sub-renderers\r\n  const gridLineOptions = {\r\n    ...options,\r\n    canvasWidth,\r\n    canvasHeight\r\n  };\r\n\r\n  const noteOptions = {\r\n    ...options,\r\n    placedNotes: options.placedNotes\r\n  };\r\n\r\n  // === RENDER LAYERS ===\r\n\r\n  // Layer 1: Horizontal grid lines (pitch lines)\r\n  gridLines.drawHorizontalLines(ctx, gridLineOptions);\r\n\r\n  // Layer 2: Vertical grid lines (beat lines)\r\n  gridLines.drawVerticalLines(ctx, gridLineOptions);\r\n\r\n  // Layer 3: Notes\r\n  const { startRow, endRow } = coords.getVisibleRowRange();\r\n\r\n  // Filter notes to only visible rows for performance\r\n  const visibleNotes = options.placedNotes.filter(note => {\r\n    if (note.isDrum) return false;\r\n    const rowIndex = note.globalRow ?? note.row;\r\n    return rowIndex >= startRow && rowIndex <= endRow;\r\n  });\r\n\r\n  // Render notes\r\n  for (const note of visibleNotes) {\r\n    const rowIndex = note.globalRow ?? note.row;\r\n\r\n    if (note.shape === 'circle') {\r\n      noteRenderer.drawTwoColumnOvalNote(ctx, noteOptions, note, rowIndex);\r\n    } else {\r\n      noteRenderer.drawSingleColumnOvalNote(ctx, noteOptions, note, rowIndex);\r\n    }\r\n  }\r\n\r\n  // Layer 4: Tonic signs\r\n  for (const tonicSign of options.placedTonicSigns) {\r\n    const rowIndex = tonicSign.globalRow ?? tonicSign.row;\r\n    if (rowIndex >= startRow && rowIndex <= endRow) {\r\n      drawTonicSign(ctx, options, tonicSign, coords);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Draw a tonic sign\r\n */\r\nfunction drawTonicSign(\r\n  ctx: CanvasRenderingContext2D,\r\n  options: PitchGridRenderOptions,\r\n  tonicSign: TonicSign,\r\n  coords: ReturnType<typeof createCoordinateUtils>\r\n): void {\r\n  const { cellWidth, cellHeight } = options;\r\n  const y = coords.getRowY(tonicSign.globalRow ?? tonicSign.row, options);\r\n  const x = coords.getColumnX(tonicSign.columnIndex, options);\r\n\r\n  const width = cellWidth * 2;\r\n  const centerX = x + width / 2;\r\n  const radius = (Math.min(width, cellHeight) / 2) * 0.9;\r\n\r\n  if (radius < 2) return;\r\n\r\n  ctx.beginPath();\r\n  ctx.arc(centerX, y, radius, 0, 2 * Math.PI);\r\n  ctx.strokeStyle = '#212529';\r\n  ctx.lineWidth = Math.max(0.5, cellWidth * 0.05);\r\n  ctx.stroke();\r\n\r\n  if (tonicSign.tonicNumber == null) return;\r\n\r\n  const numberText = tonicSign.tonicNumber.toString();\r\n  const fontSize = radius * 1.5;\r\n  if (fontSize < 6) return;\r\n\r\n  ctx.fillStyle = '#212529';\r\n  ctx.font = `bold ${fontSize}px 'Atkinson Hyperlegible', sans-serif`;\r\n  ctx.textAlign = 'center';\r\n  ctx.textBaseline = 'middle';\r\n  ctx.fillText(numberText, centerX, y);\r\n}\r\n","/**\r\n * Drum Grid Renderer\r\n *\r\n * Framework-agnostic drum grid canvas rendering.\r\n * All dependencies are injected via callbacks - no store or service imports.\r\n */\r\n\r\nimport type {\r\n  PlacedNote,\r\n  TonicSign,\r\n  MacrobeatGrouping,\r\n  MacrobeatBoundaryStyle,\r\n  ModulationMarker,\r\n} from '@mlt/types';\r\n\r\nimport type { CoordinateUtils, CoordinateOptions } from './coordinateUtils.js';\r\nimport type { MacrobeatInfo } from './gridLines.js';\r\n\r\n/**\r\n * Drum track definitions\r\n */\r\nexport const DRUM_TRACKS = ['H', 'M', 'L'] as const;\r\nexport type DrumTrack = typeof DRUM_TRACKS[number];\r\n\r\n/**\r\n * Drum note with drum-specific fields\r\n */\r\nexport interface DrumNote extends PlacedNote {\r\n  isDrum?: boolean;\r\n  drumTrack?: string | number | null;\r\n}\r\n\r\n/**\r\n * Options for rendering the drum grid\r\n */\r\nexport interface DrumGridRenderOptions extends CoordinateOptions {\r\n  /** Placed drum notes */\r\n  placedNotes: DrumNote[];\r\n  /** Placed tonic signs */\r\n  placedTonicSigns: TonicSign[];\r\n  /** Musical column widths (canvas-space) */\r\n  musicalColumnWidths?: number[];\r\n  /** Macrobeat groupings */\r\n  macrobeatGroupings: MacrobeatGrouping[];\r\n  /** Macrobeat boundary styles */\r\n  macrobeatBoundaryStyles: MacrobeatBoundaryStyle[];\r\n  /** Modulation markers */\r\n  tempoModulationMarkers?: ModulationMarker[];\r\n  /** Base microbeat pixel width */\r\n  baseMicrobeatPx: number;\r\n  /** Whether piece has anacrusis */\r\n  hasAnacrusis?: boolean;\r\n  /** Base drum row height */\r\n  baseDrumRowHeight?: number;\r\n  /** Drum height scale factor */\r\n  drumHeightScaleFactor?: number;\r\n}\r\n\r\n/**\r\n * Callbacks for drum grid rendering\r\n */\r\nexport interface DrumGridRenderCallbacks {\r\n  /** Coordinate utilities */\r\n  coords: CoordinateUtils;\r\n  /** Get macrobeat info by index */\r\n  getMacrobeatInfo?: (index: number) => MacrobeatInfo | null;\r\n  /** Get anacrusis colors from CSS */\r\n  getAnacrusisColors?: () => { stroke: string; background: string };\r\n  /** Get animation scale for drum hit */\r\n  getAnimationScale?: (columnIndex: number, drumTrack: string) => number;\r\n  /** Render modulation markers (optional) */\r\n  renderModulationMarkers?: (\r\n    ctx: CanvasRenderingContext2D,\r\n    options: DrumGridRenderOptions\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * Range for light/dark segments\r\n */\r\ninterface Range {\r\n  start: number;\r\n  end: number;\r\n}\r\n\r\n/**\r\n * Segment with light/dark styling\r\n */\r\ninterface Segment {\r\n  from: number;\r\n  to: number;\r\n  light: boolean;\r\n}\r\n\r\n/**\r\n * Merge overlapping ranges\r\n */\r\nfunction mergeRanges(ranges: Range[]): Range[] {\r\n  if (ranges.length === 0) return [];\r\n  const sorted = [...ranges].sort((a, b) => a.start - b.start);\r\n  const merged: Range[] = [];\r\n  for (const r of sorted) {\r\n    if (merged.length === 0) {\r\n      merged.push({ ...r });\r\n      continue;\r\n    }\r\n    const last = merged[merged.length - 1]!;\r\n    if (r.start <= last.end) {\r\n      last.end = Math.max(last.end, r.end);\r\n    } else {\r\n      merged.push({ ...r });\r\n    }\r\n  }\r\n  return merged;\r\n}\r\n\r\n/**\r\n * Build segments from light ranges\r\n */\r\nfunction buildSegments(startX: number, endX: number, lightRanges: Range[]): Segment[] {\r\n  const points = new Set<number>([startX, endX]);\r\n  lightRanges.forEach(r => {\r\n    const clampedStart = Math.max(startX, Math.min(endX, r.start));\r\n    const clampedEnd = Math.max(startX, Math.min(endX, r.end));\r\n    if (clampedEnd > clampedStart) {\r\n      points.add(clampedStart);\r\n      points.add(clampedEnd);\r\n    }\r\n  });\r\n\r\n  const sortedPoints = Array.from(points).sort((a, b) => a - b);\r\n  const segments: Segment[] = [];\r\n\r\n  for (let i = 0; i < sortedPoints.length - 1; i++) {\r\n    const from = sortedPoints[i]!;\r\n    const to = sortedPoints[i + 1]!;\r\n    const mid = (from + to) / 2;\r\n    const light = lightRanges.some(r => mid >= r.start && mid < r.end);\r\n    if (to > from) {\r\n      segments.push({ from, to, light });\r\n    }\r\n  }\r\n\r\n  return segments;\r\n}\r\n\r\n/**\r\n * Check if column is within a tonic sign span\r\n */\r\nfunction isTonicColumn(columnIndex: number, tonicSigns: TonicSign[]): boolean {\r\n  return tonicSigns.some(ts =>\r\n    columnIndex === ts.columnIndex || columnIndex === ts.columnIndex + 1\r\n  );\r\n}\r\n\r\n/**\r\n * Check if vertical line should be drawn at column\r\n */\r\nfunction shouldDrawVerticalLine(columnIndex: number, tonicSigns: TonicSign[]): boolean {\r\n  // Don't draw inside tonic sign (column+1)\r\n  return !tonicSigns.some(ts => columnIndex === ts.columnIndex + 1);\r\n}\r\n\r\n/**\r\n * Draw a drum shape (triangle, diamond, or pentagon)\r\n */\r\nexport function drawDrumShape(\r\n  ctx: CanvasRenderingContext2D,\r\n  drumRow: number,\r\n  x: number,\r\n  y: number,\r\n  width: number,\r\n  height: number,\r\n  scale = 1.0\r\n): void {\r\n  const cx = x + width / 2;\r\n  const cy = y + height / 2;\r\n  const size = Math.min(width, height) * 0.4 * scale;\r\n  ctx.beginPath();\r\n\r\n  if (drumRow === 0) {\r\n    // Triangle for H (high)\r\n    ctx.moveTo(cx, cy - size);\r\n    ctx.lineTo(cx - size, cy + size);\r\n    ctx.lineTo(cx + size, cy + size);\r\n    ctx.closePath();\r\n  } else if (drumRow === 1) {\r\n    // Diamond for M (mid)\r\n    ctx.moveTo(cx, cy - size);\r\n    ctx.lineTo(cx + size, cy);\r\n    ctx.lineTo(cx, cy + size);\r\n    ctx.lineTo(cx - size, cy);\r\n    ctx.closePath();\r\n  } else {\r\n    // Pentagon for L (low)\r\n    const sides = 5;\r\n    for (let i = 0; i < sides; i++) {\r\n      const angle = (2 * Math.PI / sides) * i - Math.PI / 2;\r\n      const sx = cx + size * Math.cos(angle);\r\n      const sy = cy + size * Math.sin(angle);\r\n      if (i === 0) {\r\n        ctx.moveTo(sx, sy);\r\n      } else {\r\n        ctx.lineTo(sx, sy);\r\n      }\r\n    }\r\n    ctx.closePath();\r\n  }\r\n  ctx.fill();\r\n}\r\n\r\n/**\r\n * Create drum grid renderer with injected callbacks\r\n */\r\nexport function createDrumGridRenderer(callbacks: DrumGridRenderCallbacks) {\r\n  const { coords } = callbacks;\r\n\r\n  const DEFAULT_ANACRUSIS_COLORS = {\r\n    stroke: '#c7cfd8',\r\n    background: 'rgba(207, 214, 222, 0.32)'\r\n  };\r\n\r\n  /**\r\n   * Build light ranges for anacrusis and tonic columns\r\n   */\r\n  function buildLightRanges(\r\n    options: DrumGridRenderOptions,\r\n    anacrusisEndColumn: number | null\r\n  ): Range[] {\r\n    const ranges: Range[] = [];\r\n\r\n    // Anacrusis range\r\n    if (anacrusisEndColumn !== null && anacrusisEndColumn > 0) {\r\n      ranges.push({\r\n        start: coords.getColumnX(0, options),\r\n        end: coords.getColumnX(anacrusisEndColumn, options)\r\n      });\r\n    }\r\n\r\n    // Tonic sign ranges\r\n    options.placedTonicSigns.forEach(ts => {\r\n      const start = coords.getColumnX(ts.columnIndex, options);\r\n      const end = coords.getColumnX(ts.columnIndex + 2, options);\r\n      ranges.push({ start, end });\r\n    });\r\n\r\n    return mergeRanges(ranges);\r\n  }\r\n\r\n  /**\r\n   * Get anacrusis end column from macrobeat info\r\n   */\r\n  function getAnacrusisEndColumn(options: DrumGridRenderOptions): number | null {\r\n    if (!options.hasAnacrusis || !callbacks.getMacrobeatInfo) return null;\r\n\r\n    const solidBoundaryIndex = options.macrobeatBoundaryStyles.findIndex(\r\n      style => style === 'solid'\r\n    );\r\n    if (solidBoundaryIndex < 0) return null;\r\n\r\n    const mbInfo = callbacks.getMacrobeatInfo(solidBoundaryIndex);\r\n    if (!mbInfo) return null;\r\n\r\n    return mbInfo.endColumn + 1;\r\n  }\r\n\r\n  /**\r\n   * Draw vertical grid lines\r\n   */\r\n  function drawVerticalLines(\r\n    ctx: CanvasRenderingContext2D,\r\n    options: DrumGridRenderOptions,\r\n    canvasHeight: number\r\n  ): void {\r\n    const {\r\n      columnWidths,\r\n      musicalColumnWidths,\r\n      macrobeatGroupings,\r\n      macrobeatBoundaryStyles,\r\n      placedTonicSigns\r\n    } = options;\r\n\r\n    const musicalColumns = (musicalColumnWidths && musicalColumnWidths.length > 0)\r\n      ? musicalColumnWidths\r\n      : columnWidths;\r\n    const totalColumns = musicalColumns.length;\r\n\r\n    // Build macrobeat boundary positions\r\n    const macrobeatBoundaries: number[] = [];\r\n    for (let i = 0; i < macrobeatGroupings.length; i++) {\r\n      const mbInfo = callbacks.getMacrobeatInfo?.(i);\r\n      if (mbInfo) {\r\n        macrobeatBoundaries.push(mbInfo.endColumn + 1);\r\n      }\r\n    }\r\n\r\n    const anacrusisColors = callbacks.getAnacrusisColors?.() ?? DEFAULT_ANACRUSIS_COLORS;\r\n\r\n    for (let canvasCol = 0; canvasCol <= totalColumns; canvasCol++) {\r\n      const isGridStartOrEnd = canvasCol === 0 || canvasCol === totalColumns;\r\n      const isTonicColumnStart = isTonicColumn(canvasCol, placedTonicSigns);\r\n      const isTonicColumnEnd = placedTonicSigns.some(ts => canvasCol === ts.columnIndex + 2);\r\n      const isMacrobeatEnd = macrobeatBoundaries.includes(canvasCol);\r\n      const shouldDraw = shouldDrawVerticalLine(canvasCol, placedTonicSigns);\r\n\r\n      if (!shouldDraw) continue;\r\n\r\n      let style: { lineWidth: number; strokeStyle: string; dash: number[] } | null = null;\r\n      if (isGridStartOrEnd || isTonicColumnStart || isTonicColumnEnd) {\r\n        style = { lineWidth: 2, strokeStyle: '#adb5bd', dash: [] };\r\n      } else if (isMacrobeatEnd) {\r\n        const mbIndex = macrobeatBoundaries.indexOf(canvasCol);\r\n        const boundaryStyle = macrobeatBoundaryStyles[mbIndex];\r\n        if (boundaryStyle === 'anacrusis') {\r\n          style = { lineWidth: 1, strokeStyle: anacrusisColors.stroke, dash: [4, 4] };\r\n        } else {\r\n          style = {\r\n            lineWidth: 1,\r\n            strokeStyle: '#adb5bd',\r\n            dash: boundaryStyle === 'solid' ? [] : [5, 5]\r\n          };\r\n        }\r\n      }\r\n\r\n      if (!style) continue;\r\n\r\n      const x = coords.getColumnX(canvasCol, options);\r\n      ctx.beginPath();\r\n      ctx.moveTo(x, 0);\r\n      ctx.lineTo(x, canvasHeight);\r\n      ctx.lineWidth = style.lineWidth;\r\n      ctx.strokeStyle = style.strokeStyle;\r\n      ctx.setLineDash(style.dash);\r\n      ctx.stroke();\r\n    }\r\n    ctx.setLineDash([]);\r\n  }\r\n\r\n  /**\r\n   * Draw horizontal grid lines\r\n   */\r\n  function drawHorizontalLines(\r\n    ctx: CanvasRenderingContext2D,\r\n    options: DrumGridRenderOptions,\r\n    drumRowHeight: number,\r\n    canvasWidth: number\r\n  ): void {\r\n    const anacrusisEndColumn = getAnacrusisEndColumn(options);\r\n    const lightRanges = buildLightRanges(options, anacrusisEndColumn);\r\n    const segments = buildSegments(0, canvasWidth, lightRanges);\r\n    const anacrusisColors = callbacks.getAnacrusisColors?.() ?? DEFAULT_ANACRUSIS_COLORS;\r\n\r\n    // Draw 4 horizontal lines (top/bottom of 3 rows)\r\n    for (let i = 0; i < 4; i++) {\r\n      const y = i * drumRowHeight;\r\n      segments.forEach(seg => {\r\n        if (seg.to <= seg.from) return;\r\n        ctx.beginPath();\r\n        ctx.moveTo(seg.from, y);\r\n        ctx.lineTo(seg.to, y);\r\n        ctx.strokeStyle = seg.light ? anacrusisColors.stroke : '#ced4da';\r\n        ctx.lineWidth = 1;\r\n        ctx.globalAlpha = seg.light ? 0.6 : 1;\r\n        ctx.stroke();\r\n        ctx.globalAlpha = 1;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Draw drum notes\r\n   */\r\n  function drawDrumNotes(\r\n    ctx: CanvasRenderingContext2D,\r\n    options: DrumGridRenderOptions,\r\n    drumRowHeight: number\r\n  ): void {\r\n    const { placedNotes, columnWidths, cellWidth, placedTonicSigns, tempoModulationMarkers } = options;\r\n    const totalColumns = columnWidths.length + 4; // +4 for legend columns\r\n\r\n    for (let canvasCol = 0; canvasCol < totalColumns; canvasCol++) {\r\n      // Skip tonic span columns\r\n      if (isTonicColumn(canvasCol, placedTonicSigns)) continue;\r\n\r\n      const x = coords.getColumnX(canvasCol, options);\r\n      let currentCellWidth: number;\r\n\r\n      if (tempoModulationMarkers && tempoModulationMarkers.length > 0) {\r\n        const nextX = coords.getColumnX(canvasCol + 1, options);\r\n        currentCellWidth = nextX - x;\r\n      } else {\r\n        const widthMultiplier = columnWidths[canvasCol] ?? 0;\r\n        currentCellWidth = widthMultiplier * cellWidth;\r\n      }\r\n\r\n      for (let row = 0; row < 3; row++) {\r\n        const y = row * drumRowHeight;\r\n        const drumTrack = DRUM_TRACKS[row]!;\r\n\r\n        // Find drum hit at this position\r\n        const drumHit = placedNotes.find(note =>\r\n          note.isDrum &&\r\n          (typeof note.drumTrack === 'number' ? String(note.drumTrack) : note.drumTrack) === drumTrack &&\r\n          note.startColumnIndex === canvasCol\r\n        );\r\n\r\n        if (drumHit) {\r\n          ctx.fillStyle = drumHit.color;\r\n          const animationScale = callbacks.getAnimationScale?.(canvasCol, drumTrack) ?? 1.0;\r\n          drawDrumShape(ctx, row, x, y, currentCellWidth, drumRowHeight, animationScale);\r\n        } else {\r\n          // Draw empty cell dot\r\n          ctx.fillStyle = '#ced4da';\r\n          ctx.beginPath();\r\n          ctx.arc(x + currentCellWidth / 2, y + drumRowHeight / 2, 2, 0, Math.PI * 2);\r\n          ctx.fill();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return {\r\n    drawVerticalLines,\r\n    drawHorizontalLines,\r\n    drawDrumNotes,\r\n    drawDrumShape,\r\n    buildLightRanges,\r\n    getAnacrusisEndColumn\r\n  };\r\n}\r\n\r\nexport type DrumGridRenderer = ReturnType<typeof createDrumGridRenderer>;\r\n\r\n/**\r\n * Render the drum grid to a canvas context\r\n *\r\n * Main entry point for drum grid rendering.\r\n */\r\nexport function renderDrumGrid(\r\n  ctx: CanvasRenderingContext2D,\r\n  options: DrumGridRenderOptions,\r\n  callbacks: DrumGridRenderCallbacks\r\n): void {\r\n  const canvasWidth = ctx.canvas.width;\r\n  const canvasHeight = ctx.canvas.height;\r\n\r\n  // Clear canvas\r\n  ctx.clearRect(0, 0, canvasWidth, canvasHeight);\r\n\r\n  // Calculate drum row height\r\n  const baseDrumRowHeight = options.baseDrumRowHeight ?? 30;\r\n  const drumHeightScaleFactor = options.drumHeightScaleFactor ?? 1.5;\r\n  const drumRowHeight = Math.max(baseDrumRowHeight, drumHeightScaleFactor * options.cellHeight);\r\n\r\n  // Create renderer\r\n  const renderer = createDrumGridRenderer(callbacks);\r\n\r\n  // Draw layers\r\n  renderer.drawHorizontalLines(ctx, options, drumRowHeight, canvasWidth);\r\n  renderer.drawVerticalLines(ctx, options, canvasHeight);\r\n  renderer.drawDrumNotes(ctx, options, drumRowHeight);\r\n\r\n  // Render modulation markers if callback provided\r\n  if (callbacks.renderModulationMarkers && options.tempoModulationMarkers?.length) {\r\n    callbacks.renderModulationMarkers(ctx, options);\r\n  }\r\n}\r\n","/**\r\n * Feedback Collector\r\n *\r\n * Collects and analyzes user performance data for Note Highway playback.\r\n * Tracks pitch input samples and calculates accuracy metrics.\r\n */\r\n\r\nimport type {\r\n  FeedbackCollectorConfig,\r\n  FeedbackCollectorInstance,\r\n  HighwayTargetNote,\r\n  NotePerformance,\r\n  PitchSample,\r\n} from './types.js';\r\n\r\n// ============================================================================\r\n// Default Configuration\r\n// ============================================================================\r\n\r\nconst DEFAULT_CONFIG: FeedbackCollectorConfig = {\r\n  onsetToleranceMs: 100,\r\n  releaseToleranceMs: 150,\r\n  pitchToleranceCents: 50,\r\n  hitThreshold: 70, // 70% of note duration with correct pitch\r\n  accuracyTiers: {\r\n    perfect: { onsetMs: 30, pitchCents: 10, coverage: 95 },\r\n    good: { onsetMs: 75, pitchCents: 25, coverage: 85 },\r\n    okay: { onsetMs: 150, pitchCents: 50, coverage: 70 },\r\n  },\r\n};\r\n\r\n// ============================================================================\r\n// Active Note Tracking\r\n// ============================================================================\r\n\r\ninterface ActiveNoteData {\r\n  note: HighwayTargetNote;\r\n  samples: PitchSample[];\r\n  onsetSample: PitchSample | null;\r\n  releaseSample: PitchSample | null;\r\n  startedAt: number;\r\n}\r\n\r\n// ============================================================================\r\n// Factory Function\r\n// ============================================================================\r\n\r\n/**\r\n * Create a feedback collector instance.\r\n */\r\nexport function createFeedbackCollector(\r\n  config: Partial<FeedbackCollectorConfig> = {}\r\n): FeedbackCollectorInstance {\r\n  const finalConfig: FeedbackCollectorConfig = {\r\n    ...DEFAULT_CONFIG,\r\n    ...config,\r\n    accuracyTiers: config.accuracyTiers\r\n      ? {\r\n          ...DEFAULT_CONFIG.accuracyTiers,\r\n          ...config.accuracyTiers,\r\n        }\r\n      : DEFAULT_CONFIG.accuracyTiers,\r\n  };\r\n\r\n  // Active notes being tracked\r\n  const activeNotes = new Map<string, ActiveNoteData>();\r\n\r\n  // Completed performances\r\n  const performances = new Map<string, NotePerformance>();\r\n\r\n  // ============================================================================\r\n  // Helper Functions\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate pitch deviation in cents between two MIDI values.\r\n   */\r\n  function calculateCentDeviation(actualMidi: number, targetMidi: number): number {\r\n    return (actualMidi - targetMidi) * 100;\r\n  }\r\n\r\n  /**\r\n   * Check if a pitch sample matches the target note within tolerance.\r\n   */\r\n  function isPitchCorrect(sample: PitchSample, targetMidi: number): boolean {\r\n    const deviation = Math.abs(calculateCentDeviation(sample.midi, targetMidi));\r\n    return deviation <= finalConfig.pitchToleranceCents;\r\n  }\r\n\r\n  /**\r\n   * Calculate average pitch deviation from all samples.\r\n   */\r\n  function calculateAveragePitchDeviation(\r\n    samples: PitchSample[],\r\n    targetMidi: number\r\n  ): number {\r\n    if (samples.length === 0) return 0;\r\n\r\n    const totalDeviation = samples.reduce((sum, sample) => {\r\n      return sum + Math.abs(calculateCentDeviation(sample.midi, targetMidi));\r\n    }, 0);\r\n\r\n    return totalDeviation / samples.length;\r\n  }\r\n\r\n  /**\r\n   * Calculate percentage of note duration with correct pitch.\r\n   */\r\n  function calculatePitchCoverage(\r\n    samples: PitchSample[],\r\n    targetMidi: number,\r\n    noteStartMs: number,\r\n    noteDurationMs: number\r\n  ): number {\r\n    if (samples.length === 0) return 0;\r\n\r\n    const correctSamples = samples.filter(s => isPitchCorrect(s, targetMidi));\r\n    if (correctSamples.length === 0) return 0;\r\n\r\n    // Calculate time coverage based on sample timestamps\n    let coveredMs = 0;\n    for (let i = 0; i < correctSamples.length; i++) {\n      const sample = correctSamples[i];\n      if (!sample) {\n        continue;\n      }\n      const nextSample = correctSamples[i + 1];\n\r\n      if (nextSample) {\r\n        coveredMs += nextSample.timeMs - sample.timeMs;\r\n      } else {\r\n        // Assume last sample covers until note end or next sample time\r\n        const endTime = noteStartMs + noteDurationMs;\r\n        const sampleDuration = Math.min(50, endTime - sample.timeMs); // Max 50ms per sample\r\n        coveredMs += sampleDuration;\r\n      }\r\n    }\r\n\r\n    return (coveredMs / noteDurationMs) * 100;\r\n  }\r\n\r\n  /**\r\n   * Determine accuracy tier based on performance metrics.\r\n   */\r\n  function determineAccuracyTier(\r\n    onsetAccuracyMs: number,\r\n    pitchAccuracyCents: number,\r\n    pitchCoverage: number\r\n  ): string {\r\n    const tiers = finalConfig.accuracyTiers;\r\n    if (!tiers) return 'okay';\r\n\r\n    const absOnset = Math.abs(onsetAccuracyMs);\r\n\r\n    if (\r\n      absOnset <= tiers.perfect.onsetMs &&\r\n      pitchAccuracyCents <= tiers.perfect.pitchCents &&\r\n      pitchCoverage >= tiers.perfect.coverage\r\n    ) {\r\n      return 'perfect';\r\n    }\r\n\r\n    if (\r\n      absOnset <= tiers.good.onsetMs &&\r\n      pitchAccuracyCents <= tiers.good.pitchCents &&\r\n      pitchCoverage >= tiers.good.coverage\r\n    ) {\r\n      return 'good';\r\n    }\r\n\r\n    if (\r\n      absOnset <= tiers.okay.onsetMs &&\r\n      pitchAccuracyCents <= tiers.okay.pitchCents &&\r\n      pitchCoverage >= tiers.okay.coverage\r\n    ) {\r\n      return 'okay';\r\n    }\r\n\r\n    return 'miss';\r\n  }\r\n\r\n  /**\r\n   * Analyze performance for a completed note.\r\n   */\r\n  function analyzePerformance(noteData: ActiveNoteData): NotePerformance {\r\n    const { note, samples, onsetSample, releaseSample } = noteData;\r\n\r\n    // Calculate onset accuracy\r\n    let onsetAccuracyMs = 0;\r\n    if (onsetSample) {\r\n      onsetAccuracyMs = onsetSample.timeMs - note.startTimeMs;\r\n    } else {\r\n      // No onset detected - use tolerance as penalty\r\n      onsetAccuracyMs = finalConfig.onsetToleranceMs * 2;\r\n    }\r\n\r\n    // Calculate release accuracy\r\n    let releaseAccuracyMs = 0;\r\n    const noteEndMs = note.startTimeMs + note.durationMs;\r\n    if (releaseSample) {\r\n      releaseAccuracyMs = releaseSample.timeMs - noteEndMs;\r\n    } else {\r\n      // No release detected\r\n      releaseAccuracyMs = finalConfig.releaseToleranceMs * 2;\r\n    }\r\n\r\n    // Calculate pitch accuracy\r\n    const pitchAccuracyCents = calculateAveragePitchDeviation(samples, note.midi);\r\n\r\n    // Calculate pitch coverage\r\n    const pitchCoverage = calculatePitchCoverage(\r\n      samples,\r\n      note.midi,\r\n      note.startTimeMs,\r\n      note.durationMs\r\n    );\r\n\r\n    // Determine hit status\r\n    const onsetOk = Math.abs(onsetAccuracyMs) <= finalConfig.onsetToleranceMs;\r\n    const releaseOk = Math.abs(releaseAccuracyMs) <= finalConfig.releaseToleranceMs;\r\n    const pitchOk = pitchCoverage >= finalConfig.hitThreshold;\r\n    const hitStatus = onsetOk && releaseOk && pitchOk ? 'hit' : 'miss';\r\n\r\n    // Determine accuracy tier\r\n    const accuracyTier = determineAccuracyTier(\r\n      onsetAccuracyMs,\r\n      pitchAccuracyCents,\r\n      pitchCoverage\r\n    );\r\n\r\n    return {\r\n      hitStatus,\r\n      onsetAccuracyMs,\r\n      releaseAccuracyMs,\r\n      pitchAccuracyCents,\r\n      pitchCoverage,\r\n      pitchSamples: [...samples],\r\n      accuracyTier,\r\n    };\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API\r\n  // ============================================================================\r\n\r\n  const instance: FeedbackCollectorInstance = {\r\n    startNote(noteId: string, note: HighwayTargetNote): void {\r\n      activeNotes.set(noteId, {\r\n        note,\r\n        samples: [],\r\n        onsetSample: null,\r\n        releaseSample: null,\r\n        startedAt: performance.now(),\r\n      });\r\n    },\r\n\r\n    recordPitchSample(sample: PitchSample): void {\r\n      // Add sample to all active notes that it might belong to\r\n      for (const [noteId, noteData] of activeNotes) {\r\n        const { note } = noteData;\r\n        const noteEndMs = note.startTimeMs + note.durationMs;\r\n        const onsetWindow = finalConfig.onsetToleranceMs;\r\n        const releaseWindow = finalConfig.releaseToleranceMs;\r\n\r\n        // Check if sample is within note window (with tolerance)\r\n        if (\r\n          sample.timeMs >= note.startTimeMs - onsetWindow &&\r\n          sample.timeMs <= noteEndMs + releaseWindow\r\n        ) {\r\n          noteData.samples.push(sample);\r\n\r\n          // Track onset sample (first correct pitch near note start)\r\n          if (\r\n            !noteData.onsetSample &&\r\n            sample.timeMs >= note.startTimeMs - onsetWindow &&\r\n            sample.timeMs <= note.startTimeMs + onsetWindow &&\r\n            isPitchCorrect(sample, note.midi)\r\n          ) {\r\n            noteData.onsetSample = sample;\r\n          }\r\n\r\n          // Track release sample (last sample near note end)\r\n          if (\r\n            sample.timeMs >= noteEndMs - releaseWindow &&\r\n            sample.timeMs <= noteEndMs + releaseWindow\r\n          ) {\r\n            noteData.releaseSample = sample;\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    endNote(noteId: string): NotePerformance | null {\r\n      const noteData = activeNotes.get(noteId);\r\n      if (!noteData) return null;\r\n\r\n      const performance = analyzePerformance(noteData);\r\n      performances.set(noteId, performance);\r\n      activeNotes.delete(noteId);\r\n\r\n      return performance;\r\n    },\r\n\r\n    getCurrentPerformance(noteId: string): Partial<NotePerformance> | null {\r\n      const noteData = activeNotes.get(noteId);\r\n      if (!noteData) return null;\r\n\r\n      // Provide partial performance data before note ends\r\n      const { note, samples, onsetSample } = noteData;\r\n\r\n      let onsetAccuracyMs = 0;\r\n      if (onsetSample) {\r\n        onsetAccuracyMs = onsetSample.timeMs - note.startTimeMs;\r\n      }\r\n\r\n      const pitchAccuracyCents = calculateAveragePitchDeviation(samples, note.midi);\r\n      const pitchCoverage = calculatePitchCoverage(\r\n        samples,\r\n        note.midi,\r\n        note.startTimeMs,\r\n        note.durationMs\r\n      );\r\n\r\n      return {\r\n        onsetAccuracyMs,\r\n        pitchAccuracyCents,\r\n        pitchCoverage,\r\n        pitchSamples: [...samples],\r\n      };\r\n    },\r\n\r\n    getAllPerformances(): Map<string, NotePerformance> {\r\n      return new Map(performances);\r\n    },\r\n\r\n    reset(): void {\r\n      activeNotes.clear();\r\n      performances.clear();\r\n    },\r\n\r\n    dispose(): void {\r\n      activeNotes.clear();\r\n      performances.clear();\r\n    },\r\n  };\r\n\r\n  return instance;\r\n}\r\n","/**\r\n * Note Highway Service\r\n *\r\n * Framework-agnostic service for Note Highway playback mode where grids scroll\r\n * westward (right-to-left) while a static judgment line remains fixed.\r\n */\r\n\r\nimport { createFeedbackCollector } from './feedbackCollector.js';\r\nimport type {\r\n  NoteHighwayConfig,\r\n  NoteHighwayServiceInstance,\r\n  NoteHighwayState,\r\n  HighwayTargetNote,\r\n  InputSource,\r\n  PitchSample,\r\n  NotePerformance,\r\n  FeedbackCollectorInstance,\r\n} from './types.js';\r\n\r\n// ============================================================================\r\n// Default Configuration\r\n// ============================================================================\r\n\r\nconst DEFAULT_CONFIG: Partial<NoteHighwayConfig> = {\r\n  judgmentLinePosition: 0.12,\r\n  pixelsPerSecond: 200,\r\n  lookAheadMs: 3000,\r\n  scrollMode: 'constant-speed',\r\n  leadInBeats: 4,\r\n  playMetronomeDuringOnramp: true,\r\n  playTargetNotes: true,\r\n  playMetronome: false,\r\n  inputSources: ['microphone'],\r\n  feedbackConfig: {\r\n    onsetToleranceMs: 100,\r\n    releaseToleranceMs: 150,\r\n    pitchToleranceCents: 50,\r\n    hitThreshold: 70,\r\n  },\r\n};\r\n\r\n// ============================================================================\r\n// Factory Function\r\n// ============================================================================\r\n\r\n/**\r\n * Create a Note Highway service instance.\r\n */\r\nexport function createNoteHighwayService(\r\n  config: NoteHighwayConfig\r\n): NoteHighwayServiceInstance {\r\n  const finalConfig: NoteHighwayConfig = {\r\n    ...DEFAULT_CONFIG,\r\n    ...config,\r\n    feedbackConfig: {\r\n      ...DEFAULT_CONFIG.feedbackConfig!,\r\n      ...config.feedbackConfig,\r\n    },\r\n  };\r\n\r\n  const { stateCallbacks, eventCallbacks, visualCallbacks, logger } = finalConfig;\r\n\r\n  // Internal state\r\n  const state: NoteHighwayState = {\r\n    isPlaying: false,\r\n    isPaused: false,\r\n    currentTimeMs: 0,\r\n    scrollOffset: 0,\r\n    onrampComplete: false,\r\n    targetNotes: [],\r\n    activeNotes: new Set(),\r\n    startTime: null,\r\n  };\r\n\r\n  // Feedback collector\r\n  const feedbackCollector = createFeedbackCollector(finalConfig.feedbackConfig);\r\n\r\n  // Animation frame ID\r\n  let animationFrameId: number | null = null;\r\n\r\n  // Track which notes have entered/exited judgment window\r\n  const notesInWindow = new Set<string>();\r\n\r\n  // ============================================================================\r\n  // Helper Functions\r\n  // ============================================================================\r\n\r\n  /**\r\n   * Calculate the onramp duration in milliseconds.\r\n   */\r\n  function getOnrampDurationMs(): number {\r\n    const tempo = stateCallbacks.getTempo();\r\n    const beatDurationMs = (60 / tempo) * 1000;\r\n    return finalConfig.leadInBeats * beatDurationMs;\r\n  }\r\n\r\n  /**\r\n   * Calculate judgment line X position in pixels.\r\n   */\r\n  function getJudgmentLineX(): number {\r\n    const viewportWidth = stateCallbacks.getViewportWidth();\r\n    return viewportWidth * finalConfig.judgmentLinePosition;\r\n  }\r\n\r\n  /**\r\n   * Calculate scroll offset from current time.\r\n   */\r\n  function calculateScrollOffset(timeMs: number): number {\r\n    const pixelsPerMs = finalConfig.pixelsPerSecond / 1000;\r\n    const judgmentLineX = getJudgmentLineX();\r\n\r\n    // In constant-speed mode, scroll offset moves linearly with time\r\n    // Offset starts negative during onramp\r\n    const onrampDurationMs = getOnrampDurationMs();\r\n    const adjustedTimeMs = timeMs + onrampDurationMs;\r\n\r\n    return (adjustedTimeMs * pixelsPerMs) - judgmentLineX;\r\n  }\r\n\r\n  /**\r\n   * Check if a note is within the judgment window.\r\n   */\r\n  function isNoteInJudgmentWindow(note: HighwayTargetNote): boolean {\r\n    const judgmentLineX = getJudgmentLineX();\r\n    const cellWidth = stateCallbacks.getCellWidth();\r\n\r\n    // Calculate note X positions\r\n    const noteStartX = (note.startColumn * cellWidth) - state.scrollOffset;\r\n    const noteEndX = (note.endColumn * cellWidth) - state.scrollOffset;\r\n\r\n    // Judgment window: within tolerance of judgment line\r\n    const windowToleranceMs = finalConfig.feedbackConfig.onsetToleranceMs;\r\n    const windowTolerancePx = (windowToleranceMs / 1000) * finalConfig.pixelsPerSecond;\r\n\r\n    return (\r\n      noteStartX <= judgmentLineX + windowTolerancePx &&\r\n      noteEndX >= judgmentLineX - windowTolerancePx\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Update active notes based on current time.\r\n   */\r\n  function updateActiveNotes(): void {\r\n    const currentActiveNotes = new Set<string>();\r\n\r\n    for (const note of state.targetNotes) {\r\n      const noteEndMs = note.startTimeMs + note.durationMs;\r\n\r\n      // Note is active if current time is within its duration (with tolerance)\r\n      const tolerance = finalConfig.feedbackConfig.onsetToleranceMs;\r\n      if (\r\n        state.currentTimeMs >= note.startTimeMs - tolerance &&\r\n        state.currentTimeMs <= noteEndMs + tolerance\r\n      ) {\r\n        currentActiveNotes.add(note.id);\r\n\r\n        // Start tracking if just became active\r\n        if (!state.activeNotes.has(note.id)) {\r\n          feedbackCollector.startNote(note.id, note);\r\n          logger?.debug('NoteHighway', `Note ${note.id} became active`, { note });\r\n        }\r\n      } else if (state.activeNotes.has(note.id)) {\r\n        // Note just became inactive - end tracking\r\n        const performance = feedbackCollector.endNote(note.id);\r\n        if (performance) {\r\n          // Update note with performance data\r\n          note.performance = performance;\r\n\r\n          // Emit event\r\n          const eventData = { noteId: note.id, note, performance };\r\n          if (performance.hitStatus === 'hit') {\r\n            eventCallbacks.emit('noteHit', eventData);\r\n            visualCallbacks?.onNoteHit?.(note.id, performance.accuracyTier || 'okay');\r\n            logger?.info('NoteHighway', `Note hit: ${note.id}`, performance);\r\n          } else {\r\n            eventCallbacks.emit('noteMissed', eventData);\r\n            visualCallbacks?.onNoteMiss?.(note.id);\r\n            logger?.info('NoteHighway', `Note missed: ${note.id}`, performance);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    state.activeNotes = currentActiveNotes;\r\n  }\r\n\r\n  /**\r\n   * Update notes in judgment window for visual feedback.\r\n   */\r\n  function updateJudgmentWindow(): void {\r\n    for (const note of state.targetNotes) {\r\n      const inWindow = isNoteInJudgmentWindow(note);\r\n      const wasInWindow = notesInWindow.has(note.id);\r\n\r\n      if (inWindow && !wasInWindow) {\r\n        notesInWindow.add(note.id);\r\n        eventCallbacks.emit('noteEntered', { noteId: note.id, note });\r\n      } else if (!inWindow && wasInWindow) {\r\n        notesInWindow.delete(note.id);\r\n        eventCallbacks.emit('noteExited', { noteId: note.id, note });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update onramp state and countdown.\r\n   */\r\n  function updateOnramp(): void {\r\n    if (state.onrampComplete) return;\r\n\r\n    if (state.currentTimeMs >= 0) {\r\n      state.onrampComplete = true;\r\n      eventCallbacks.emit('onrampComplete');\r\n      visualCallbacks?.clearOnrampCountdown?.();\r\n      logger?.info('NoteHighway', 'Onramp complete', null);\r\n    } else {\r\n      // Calculate beats remaining in onramp\r\n      const tempo = stateCallbacks.getTempo();\r\n      const beatDurationMs = (60 / tempo) * 1000;\r\n      const msRemaining = Math.abs(state.currentTimeMs);\r\n      const beatsRemaining = Math.ceil(msRemaining / beatDurationMs);\r\n\r\n      visualCallbacks?.updateOnrampCountdown?.(beatsRemaining);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Animation loop for updating state.\r\n   */\r\n  function animate(): void {\r\n    if (!state.isPlaying || state.isPaused || !state.startTime) {\r\n      animationFrameId = null;\r\n      return;\r\n    }\r\n\r\n    const now = performance.now();\r\n    const onrampDurationMs = getOnrampDurationMs();\r\n\r\n    // Calculate current time (can be negative during onramp)\r\n    state.currentTimeMs = (now - state.startTime) - onrampDurationMs;\r\n\r\n    // Update scroll offset\r\n    state.scrollOffset = calculateScrollOffset(state.currentTimeMs);\r\n\r\n    // Update onramp\r\n    updateOnramp();\r\n\r\n    // Update active notes\r\n    updateActiveNotes();\r\n\r\n    // Update judgment window\r\n    updateJudgmentWindow();\r\n\r\n    // Continue animation\r\n    animationFrameId = requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Start the animation loop.\r\n   */\r\n  function startAnimation(): void {\r\n    if (animationFrameId) return;\r\n    animationFrameId = requestAnimationFrame(animate);\r\n  }\r\n\r\n  /**\r\n   * Stop the animation loop.\r\n   */\r\n  function stopAnimation(): void {\r\n    if (animationFrameId) {\r\n      cancelAnimationFrame(animationFrameId);\r\n      animationFrameId = null;\r\n    }\r\n  }\r\n\r\n  // ============================================================================\r\n  // Public API\r\n  // ============================================================================\r\n\r\n  const instance: NoteHighwayServiceInstance = {\r\n    init(notes: HighwayTargetNote[]): void {\r\n      state.targetNotes = notes;\r\n      logger?.info('NoteHighway', `Initialized with ${notes.length} notes`, null);\r\n    },\r\n\r\n    start(): void {\r\n      if (state.isPlaying) return;\r\n\r\n      state.isPlaying = true;\r\n      state.isPaused = false;\r\n      state.currentTimeMs = -getOnrampDurationMs(); // Start in onramp\r\n      state.scrollOffset = calculateScrollOffset(state.currentTimeMs);\r\n      state.onrampComplete = false;\r\n      state.activeNotes.clear();\r\n      state.startTime = performance.now();\r\n\r\n      notesInWindow.clear();\r\n      feedbackCollector.reset();\r\n\r\n      startAnimation();\r\n      eventCallbacks.emit('playbackStarted');\r\n      logger?.info('NoteHighway', 'Playback started', { onrampDurationMs: getOnrampDurationMs() });\r\n    },\r\n\r\n    pause(): void {\r\n      if (!state.isPlaying || state.isPaused) return;\r\n\r\n      state.isPaused = true;\r\n      stopAnimation();\r\n      eventCallbacks.emit('playbackPaused');\r\n      logger?.info('NoteHighway', 'Playback paused', { currentTimeMs: state.currentTimeMs });\r\n    },\r\n\r\n    resume(): void {\r\n      if (!state.isPlaying || !state.isPaused || !state.startTime) return;\r\n\r\n      // Adjust start time to account for paused duration\r\n      const pausedDuration = performance.now() - (state.startTime + state.currentTimeMs + getOnrampDurationMs());\r\n      state.startTime += pausedDuration;\r\n\r\n      state.isPaused = false;\r\n      startAnimation();\r\n      eventCallbacks.emit('playbackResumed');\r\n      logger?.info('NoteHighway', 'Playback resumed', null);\r\n    },\r\n\r\n    stop(): void {\r\n      if (!state.isPlaying) return;\r\n\r\n      state.isPlaying = false;\r\n      state.isPaused = false;\r\n      state.currentTimeMs = 0;\r\n      state.scrollOffset = 0;\r\n      state.onrampComplete = false;\r\n      state.activeNotes.clear();\r\n      state.startTime = null;\r\n\r\n      notesInWindow.clear();\r\n      stopAnimation();\r\n      visualCallbacks?.clearCanvas?.();\r\n      visualCallbacks?.clearOnrampCountdown?.();\r\n      eventCallbacks.emit('playbackStopped');\r\n\r\n      // Check if all notes have been evaluated\r\n      const allEvaluated = state.targetNotes.every(n => n.performance !== undefined);\r\n      if (allEvaluated) {\r\n        eventCallbacks.emit('performanceComplete');\r\n      }\r\n\r\n      logger?.info('NoteHighway', 'Playback stopped', null);\r\n    },\r\n\r\n    setScrollOffset(timeMs: number): void {\r\n      state.currentTimeMs = timeMs;\r\n      state.scrollOffset = calculateScrollOffset(timeMs);\r\n\r\n      if (state.isPlaying) {\r\n        // Adjust start time to sync with new position\r\n        const onrampDurationMs = getOnrampDurationMs();\r\n        state.startTime = performance.now() - (timeMs + onrampDurationMs);\r\n      }\r\n\r\n      logger?.debug('NoteHighway', 'Scroll offset set', { timeMs, scrollOffset: state.scrollOffset });\r\n    },\r\n\r\n    recordPitchInput(midi: number, clarity: number, source: InputSource): void {\r\n      if (!state.isPlaying || state.isPaused) return;\r\n      if (!finalConfig.inputSources.includes(source)) return;\r\n\r\n      const sample: PitchSample = {\r\n        timeMs: state.currentTimeMs,\r\n        midi,\r\n        clarity,\r\n        source,\r\n      };\r\n\r\n      feedbackCollector.recordPitchSample(sample);\r\n    },\r\n\r\n    getState(): Readonly<NoteHighwayState> {\r\n      return state;\r\n    },\r\n\r\n    getVisibleNotes(): HighwayTargetNote[] {\r\n      const judgmentLineX = getJudgmentLineX();\r\n      const viewportWidth = stateCallbacks.getViewportWidth();\r\n      const cellWidth = stateCallbacks.getCellWidth();\r\n\r\n      return state.targetNotes.filter(note => {\r\n        const noteStartX = (note.startColumn * cellWidth) - state.scrollOffset;\r\n        const noteEndX = (note.endColumn * cellWidth) - state.scrollOffset;\r\n\r\n        // Note is visible if any part is on screen\r\n        return noteEndX >= 0 && noteStartX <= viewportWidth;\r\n      });\r\n    },\r\n\r\n    getPerformanceResults(): Map<string, NotePerformance> {\r\n      return feedbackCollector.getAllPerformances();\r\n    },\r\n\r\n    getFeedbackCollector(): FeedbackCollectorInstance {\r\n      return feedbackCollector;\r\n    },\r\n\r\n    dispose(): void {\r\n      stopAnimation();\r\n      feedbackCollector.dispose();\r\n      state.targetNotes = [];\r\n      state.activeNotes.clear();\r\n      notesInWindow.clear();\r\n      logger?.info('NoteHighway', 'Service disposed', null);\r\n    },\r\n  };\r\n\r\n  return instance;\r\n}\r\n","/**\r\n * Highway Data Converter\r\n *\r\n * Converts Student Notation state data to Note Highway format.\r\n */\r\n\r\nimport type { HighwayTargetNote } from './types.js';\r\n\r\n// ============================================================================\r\n// Types for Student Notation Data\r\n// ============================================================================\r\n\r\n/**\r\n * Minimal PlacedNote interface from Student Notation.\r\n */\r\nexport interface PlacedNote {\r\n  uuid?: string;\r\n  row: number;\r\n  globalRow?: number;\r\n  startColumnIndex: number;\r\n  endColumnIndex: number;\r\n  shape: 'circle' | 'oval' | 'diamond';\r\n  color: string;\r\n  isDrum?: boolean;\r\n}\r\n\r\n/**\r\n * Configuration for the converter.\r\n */\r\nexport interface ConverterConfig {\r\n  /** Tempo in BPM */\r\n  tempo: number;\r\n  /** Cell width in pixels */\r\n  cellWidth: number;\r\n  /** Time map: array where index = column, value = time in seconds */\r\n  timeMap?: number[];\r\n  /** Manual microbeat duration in seconds (if timeMap not provided) */\r\n  microbeatDurationSec?: number;\r\n}\r\n\r\n// ============================================================================\r\n// Converter Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate microbeat duration from tempo.\r\n * @param tempo Tempo in BPM\r\n * @returns Duration of one microbeat (eighth note) in seconds\r\n */\r\nexport function calculateMicrobeatDuration(tempo: number): number {\r\n  // Each microbeat is an eighth note at the given tempo\r\n  // Quarter note = 60/tempo seconds\r\n  // Eighth note = (60/tempo) / 2\r\n  const quarterNoteDuration = 60 / tempo;\r\n  return quarterNoteDuration / 2;\r\n}\r\n\r\n/**\r\n * Convert a single PlacedNote to a HighwayTargetNote.\r\n */\r\nexport function convertNoteToHighway(\r\n  note: PlacedNote,\r\n  config: ConverterConfig\r\n): HighwayTargetNote {\r\n  const { timeMap, tempo, cellWidth } = config;\r\n\r\n  let startTimeMs: number;\r\n  let endTimeMs: number;\r\n\r\n  if (timeMap && timeMap.length > 0) {\r\n    // Use time map if available\r\n    const startTimeSec = timeMap[note.startColumnIndex] ?? 0;\r\n    const endTimeSec = timeMap[note.endColumnIndex] ?? startTimeSec;\r\n    startTimeMs = startTimeSec * 1000;\r\n    endTimeMs = endTimeSec * 1000;\r\n  } else {\r\n    // Fallback: calculate from tempo\r\n    const microbeatDuration = config.microbeatDurationSec ?? calculateMicrobeatDuration(tempo);\r\n    startTimeMs = note.startColumnIndex * microbeatDuration * 1000;\r\n    endTimeMs = note.endColumnIndex * microbeatDuration * 1000;\r\n  }\r\n\r\n  const durationMs = endTimeMs - startTimeMs;\r\n\r\n  // Get MIDI pitch from globalRow\r\n  // fullRowData is ordered C8 (MIDI 108, index 0) to A0 (MIDI 21, index 87)\r\n  const midi = note.globalRow !== undefined ? 108 - note.globalRow : 60; // Default to middle C if not available\r\n\r\n  return {\r\n    id: note.uuid ?? `note-${note.startColumnIndex}-${note.row}`,\r\n    midi,\r\n    startTimeMs,\r\n    durationMs,\r\n    startColumn: note.startColumnIndex,\r\n    endColumn: note.endColumnIndex,\r\n    color: note.color,\r\n    shape: note.shape,\r\n    globalRow: note.globalRow ?? note.row,\r\n  };\r\n}\r\n\r\n/**\r\n * Convert an array of PlacedNotes to HighwayTargetNotes.\r\n * Filters out drum notes automatically.\r\n */\r\nexport function convertNotesToHighway(\r\n  notes: PlacedNote[],\r\n  config: ConverterConfig\r\n): HighwayTargetNote[] {\r\n  // Filter out drum notes\r\n  const pitchNotes = notes.filter(note => !note.isDrum);\r\n\r\n  // Convert each note\r\n  return pitchNotes.map(note => convertNoteToHighway(note, config));\r\n}\r\n\r\n/**\r\n * Create a simple time map from column widths.\r\n * Useful when timeMapCalculator is not available.\r\n */\r\nexport function createSimpleTimeMap(\r\n  columnWidths: number[],\r\n  microbeatDurationSec: number\r\n): number[] {\r\n  const timeMap: number[] = [0];\r\n  let currentTime = 0;\r\n\r\n  for (let i = 0; i < columnWidths.length; i++) {\r\n    const width = columnWidths[i] ?? 1;\r\n    currentTime += width * microbeatDurationSec;\r\n    timeMap.push(currentTime);\r\n  }\r\n\r\n  return timeMap;\r\n}\r\n\r\n/**\r\n * Helper to get default highway configuration from Student Notation state.\r\n */\r\nexport interface StudentNotationState {\r\n  placedNotes: PlacedNote[];\r\n  tempo: number;\r\n  cellWidth: number;\r\n  columnWidths?: number[];\r\n  fullRowData?: Array<{ toneNote: string; midi?: number }>;\r\n}\r\n\r\n/**\r\n * Convert Student Notation state to Highway target notes.\r\n * This is a convenience function that handles all the conversion logic.\r\n */\r\nexport function convertStateToHighway(\r\n  state: StudentNotationState,\r\n  timeMap?: number[]\r\n): HighwayTargetNote[] {\r\n  const microbeatDuration = calculateMicrobeatDuration(state.tempo);\r\n\r\n  const config: ConverterConfig = {\r\n    tempo: state.tempo,\r\n    cellWidth: state.cellWidth,\r\n    timeMap,\r\n    microbeatDurationSec: microbeatDuration,\r\n  };\r\n\r\n  return convertNotesToHighway(state.placedNotes, config);\r\n}\r\n","/**\n * @mlt/student-notation-engine\n *\n * Framework-agnostic engine for Student Notation.\n * Provides canvas rendering, audio playback, and state management\n * without any DOM dependencies.\n *\n * Usage:\n *\n * ```typescript\n * import { createEngineController } from '@mlt/student-notation-engine';\n *\n * const engine = createEngineController();\n *\n * engine.init({\n *   pitchGridContext: canvas.getContext('2d'),\n *   drumGridContext: drumCanvas.getContext('2d'),\n * });\n *\n * // Use the public API\n * engine.setTool('note');\n * engine.insertNote(40, 0, 4);\n * engine.play();\n *\n * // Subscribe to events\n * engine.on('noteAdded', (note) => {\n *   console.log('Note added:', note);\n * });\n * ```\n */\n\n// Re-export types from @mlt/types\nexport type {\n  // State\n  AppState,\n  Store,\n  HistoryEntry,\n\n  // Music\n  PlacedNote,\n  NoteShape,\n  PlacedChord,\n  TonicSign,\n  TonicSignGroups,\n  PitchRowData,\n  PitchRange,\n\n  // Stamps\n  SixteenthStampPlacement,\n  TripletStampPlacement,\n  SixteenthStampPlaybackData,\n  TripletStampPlaybackData,\n\n  // Rhythm\n  MacrobeatGrouping,\n  MacrobeatBoundaryStyle,\n  ModulationMarker,\n  ModulationRatio,\n\n  // Timbre\n  TimbreState,\n  TimbresMap,\n  ADSREnvelope,\n  FilterSettings,\n\n  // Selection\n  LassoSelection,\n  LassoSelectedItem,\n  GeometryPoint,\n\n  // View\n  DeviceProfile,\n  AccidentalMode,\n  DegreeDisplayMode,\n  PlayheadMode,\n  LongNoteStyle,\n  PrintOptions,\n\n  // Coordinates\n  CanvasSpaceColumn,\n} from '@mlt/types';\n\n// Controller API\nexport {\n  createEngineController,\n  createLessonMode,\n  type EngineController,\n  type EngineConfig,\n  type LessonModeAPI,\n  type SelectionItem,\n  type HighlightTarget,\n  type ActionEvent,\n  type ActionHandler,\n  type EventCallback,\n} from './controller.js';\n\n// State module\nexport {\n  createStore,\n  getInitialState,\n  fullRowData,\n  getPitchByToneNote,\n  getPitchByIndex,\n  getPitchIndex,\n  resolvePitchRange,\n  type StoreConfig,\n  type StoreInstance,\n  type StorageAdapter,\n  type Unsubscribe\n} from './state/index.js';\n\n// Audio module\nexport {\n  createSynthEngine,\n  createTransportService,\n  // Context configuration\n  configureAudioContext,\n  getContextInfo,\n  DEFAULT_CONTEXT_OPTIONS,\n  // Utilities\n  GainManager,\n  getPerVoiceBaselineGain,\n  ClippingMonitor,\n  FilteredVoice,\n  setVoiceLogger,\n  // Types\n  type ContextOptions,\n  type SynthEngineInstance,\n  type SynthEngineConfig,\n  type TransportServiceInstance,\n  type TransportConfig,\n  type PlaybackMode,\n  type EffectsManager,\n  type HarmonicFilter,\n  type SynthLogger,\n  type GainManagerOptions,\n  type ClippingMonitorOptions,\n  type FilteredVoiceOptions,\n  type FilterParams,\n  type VibratoParams,\n  type TremoloParams,\n  type VoiceLogger,\n} from './audio/index.js';\n\n// Canvas module\nexport {\n  renderPitchGrid,\n  renderDrumGrid,\n  type PitchGridRenderOptions,\n  type DrumGridRenderOptions,\n} from './canvas/index.js';\n\n// Transport module\nexport {\n  createTimeMapCalculator,\n  createDrumManager,\n  DEFAULT_DRUM_SAMPLES,\n  type TimeMapCalculatorConfig,\n  type TimeMapCalculatorInstance,\n  type DrumConfig,\n  type DrumManagerInstance,\n  type DrumTrackId,\n  type LoopBounds,\n  type TimeMapConfig,\n  type TimeMapState,\n  type MacrobeatInfo,\n  type PlacedTonicSign,\n  type TransportLogger,\n  type StampPlaybackData,\n  type TripletPlaybackData,\n  type ScheduleEvent,\n  type ModulationMarkerData,\n} from './transport/index.js';\n\n// Services module\nexport {\n  createColumnMapService,\n  visualToCanvas,\n  visualToTime,\n  canvasToVisual,\n  canvasToTime,\n  timeToCanvas,\n  timeToVisual,\n  getTimeBoundaryAfterMacrobeat,\n  getColumnEntry,\n  getColumnEntryByCanvas,\n  isPlayableColumn,\n  getColumnType,\n  getMacrobeatBoundary,\n  getCanvasColumnWidths,\n  getTotalCanvasWidth,\n  type ColumnMapService,\n  type ColumnMapCallbacks,\n  type ColumnMapState,\n  type ColumnMap,\n  type ColumnEntry,\n  type MacrobeatBoundary,\n} from './services/index.js';\n\n// Rhythm module\nexport {\n  createModulationMarker,\n  createCoordinateMapping,\n  getModulationDisplayText,\n  getModulationColor,\n  columnToRegularTime,\n  canvasXToSeconds,\n  secondsToCanvasX,\n  MODULATION_RATIOS,\n  type ModulationSegment,\n  type CoordinateMapping,\n  type ModulationMappingState,\n  type ModulationMappingCallbacks,\n} from './rhythm/index.js';\n\n// Highway module\nexport {\n  createNoteHighwayService,\n  createFeedbackCollector,\n  convertNoteToHighway,\n  convertNotesToHighway,\n  convertStateToHighway,\n  createSimpleTimeMap,\n  calculateMicrobeatDuration,\n  type NoteHighwayConfig,\n  type FeedbackCollectorConfig,\n  type ScrollMode,\n  type InputSource,\n  type NoteHighwayState,\n  type HighwayTargetNote,\n  type NotePerformance,\n  type PitchSample,\n  type HighwayStateCallbacks,\n  type HighwayEventCallbacks,\n  type HighwayVisualCallbacks,\n  type HighwayLogger,\n  type NoteHighwayServiceInstance,\n  type FeedbackCollectorInstance,\n  type NoteHighwayEvent,\n  type NoteEventData,\n  type ConverterConfig,\n  type StudentNotationState,\n} from './highway/index.js';\n\n// Version\nexport const VERSION = '0.1.0';\n"],"names":["fullRowData","toneNoteToIndex","midiToIndex","row","index","getPitchByToneNote","toneNote","getPitchByIndex","getPitchIndex","resolvePitchRange","topToneNote","bottomToneNote","topIndex","bottomIndex","DEFAULT_ADSR","DEFAULT_FILTER","DEFAULT_VIBRATO","DEFAULT_TREMOLO","createDefaultTimbres","colors","timbres","color","coeffs","phases","getDefaultRhythm","macrobeatGroupings","macrobeatBoundaryStyles","_","getDefaultPitchRange","range","getInitialState","ensureCircleNoteSpan","note","minimumEnd","updateGlobalRow","maxRowIndex","candidate","globalRow","generateUUID","createNoteActions","callbacks","getMacrobeatInfo","getDegreeForNote","hasAccidental","log","existingNote","currentDegree","noteWithId","newEndColumn","nextEnd","notes","newRow","rowOffsets","offset","newStartColumn","noteSet","col","width","record","eraseEndCol","eraseStartRow","eraseEndRow","wasErased","initialNoteCount","minSpanEnd","noteEndCol","horizontalOverlap","verticalOverlap","tonicSignGroup","firstSign","preMacrobeatIndex","group","ts","boundaryColumn","notesToShift","n","oldStart","oldEnd","uuid","groupWithId","sign","s","columnIndex","tonicGroupToDelete","uuidToDelete","groupToDelete","importedNotes","normalizedNotes","normalizedNote","generateSixteenthStampPlacementId","createSixteenthStampActions","getPlacedTonicSigns","isWithinTonicSpan","sixteenthStampId","startColumn","endColumn","placedTonicSigns","existingStamp","placement","placementId","p","removed","eraseStartCol","toRemove","id","column","hadStamps","rowData","data","shapeKey","rowOffset","_a","generateTripletStampPlacementId","createTripletStampActions","canvasToTime","timeToCanvas","getColumnMap","newEndTime","existingTriplet","existing","map","stamp","stampStartTime","finalPlacement","timeSpan","startCanvasCol","timeIndex","hadTriplets","MODULATION_RATIOS","measureIndexToColumnIndex","measureIndex","state","fallbackColumn","macrobeatIndex","measureInfo","canvasColumnAfterMeasure","createModulationMarker","ratio","xPosition","getModulationDisplayText","getModulationColor","DEFAULT_UI_YELLOW","createEmptyMapping","segments","_columnIndex","createCoordinateMapping","markers","baseMicrobeatPx","sortedMarkers","m","a","b","markersWithColumn","marker","cumulativeScale","firstMarker","i","nextMarker","nextMarkerColumn","segment","_microbeatIndex","_canvasX","_segment","_options","columnToRegularTime","regularTimeMap","regularTime","canvasXToSeconds","_coordinateMapping","_baseMicrobeatDuration","secondsToCanvasX","_seconds","ANACRUSIS_ON_GROUPINGS","ANACRUSIS_ON_STYLES","ANACRUSIS_OFF_GROUPINGS","ANACRUSIS_OFF_STYLES","recomputeTonicColumns","tonicStartByUuid","entry","start","EMPTY_COLUMN_MAP","createRhythmActions","visualToTimeIndex","timeIndexToVisualColumn","getTimeBoundaryAfterMacrobeat","enabled","oldGroupings","oldBoundaryStyles","oldTotalBeats","sum","val","newGroupings","newBoundaryStyles","cache","anacrusisLength","defaultGroupings","defaultStyles","groupingsToInsert","stylesToInsert","_b","_c","firstSolidIndex","style","removalCount","removedGroupings","removedStyles","timeShift","notesToRemove","startTime","endTime","newStartTime","noteToRemove","stampsToRemove","stampToRemove","tripletsToRemove","triplet","tripletToRemove","markersToRemove","anacrusisShift","newMeasureIndex","markerToRemove","currentValue","newValue","delta","boundaryTime","newStartCol","newEndCol","idx","isInAnacrusis","styles","currentStyle","currentIndex","nextIndex","nextStyle","boundaryIndex","lastMacrobeatIndex","measureStartIndex","measureEndIndex","currentMeasure","isLastBeat","oldLength","newLength","oldTimeSpan","nextMacrobeatGroupings","tmp","newGroupingsCopy","newStylesArray","originalFinalStyle","existingMarkerIndex","existingMarker","markerId","removedCount","restoreTimbres","timbresSnapshot","newTimbres","timbre","VALID_BOUNDARY_STYLES","isValidMacrobeatGroupings","value","isValidMacrobeatBoundaryStyles","groupingsLength","loadStateFromStorage","storage","storageKey","serializedState","parsedState","groupings","totalRows","maxIndex","mode","saveStateToStorage","stateToPersist","createStore","config","configInitialState","onClearState","noteActionCallbacks","sixteenthStampActionCallbacks","tripletStampActionCallbacks","rhythmActionCallbacks","subscribers","persistedState","isColdStart","store","eventName","callback","error","key","timbresForHistory","newSnapshot","snapshot","isPlaying","isPaused","isLooping","tempo","tool","tonicNumber","oldTool","numericTonic","shape","oldNote","type","profile","isActive","options","scale","intervals","isInverted","position","adsr","settings","preset","createColumnMapService","sideColumnWidth","beatColumnWidth","cachedMap","cacheKey","buildCacheKey","tonicSignsHash","isCacheValid","newKey","buildColumnMap","sortedTonics","entries","macrobeatBoundaries","visualIndex","canvasIndex","xOffset","tonicCursor","addTonicColumns","tonic","currentUuid","grouping","mbIndex","beatIdx","boundaryStyle","visualToCanvas","visualToTime","canvasToVisual","timeToVisual","currentKey","invalidate","result","time","getColumnEntry","getColumnEntryByCanvas","isPlayableColumn","getColumnType","getMacrobeatBoundary","getCanvasColumnWidths","widths","getTotalCanvasWidth","total","createEngineController","initialized","columnMapService","pitchGridContext","drumGridContext","debugMode","level","context","message","category","prefix","callbackLog","signs","currentColor","currentShape","noteId","selection","notesToDelete","item","toRow","toColumn","items","selectedItems","bpm","header","rows","csv","lines","line","json","event","createLessonMode","_engine","voiceLogger","setVoiceLogger","logger","FilteredVoice","Tone","__publicField","params","speedHz","isAudioRunning","centsAmplitude","centRatio","hzDeviation","spanAmount","minGain","maxGain","freq","q","blend","DEFAULT_GAIN_MANAGER_OPTIONS","getPerVoiceBaselineGain","polyphonyReference","GainManager","masterGain","voiceCount","maxVoiceCount","smoothingTauMs","masterGainRampMs","gainUpdateIntervalMs","now","alpha","deltaT","currentVoices","scaleFactor","targetGain","DEFAULT_CLIPPING_MONITOR_OPTIONS","ClippingMonitor","meter","levelValue","createSynthEngine","masterVolume","effectsManager","harmonicFilter","audioInit","getDrumVolume","synths","volumeControl","compressor","limiter","clippingMeter","waveformAnalyzers","gainManager","clippingMonitor","internalTimbres","getCoefficients","normalizeCoefficients","totalAmplitude","coeff","instance","levelDb","filteredCoeffs","normalizedCoeffs","presetGain","synth","originalTriggerAttack","args","effectApplicationTime","activeVoices","voice","dB","pitch","duration","firstColor","isDrum","drumVolume","originalVolume","drumVolumeDB","pitches","originalRelease","currentConfig","release","err","activeAnalyzers","LOOP_EPSILON","createTimeMapCalculator","getTonicSpanColumnIndices","updatePlayheadModel","timeMap","cachedMusicalEndTime","configuredLoopStart","configuredLoopEnd","getMicrobeatDuration","calculateRegularTimeMap","microbeatDuration","columnWidths","currentTime","totalColumns","tonicSpanColumns","isTonicColumn","calculateMusicalEndTime","baseEndTime","tempoModulationMarkers","adjustedEndTime","macrobeatInfo","modulationStartColumn","modulationStartTime","remainingBaseTime","stretchedTime","musicalEnd","baseTime","adjustedTime","deltaTime","modulatedDelta","loopStart","loopEnd","minDuration","safeStart","safeEnd","loopStartSeconds","loopEndSeconds","loopStartDiff","loopEndDiff","DEFAULT_DRUM_SAMPLES","DRUM_START_EPSILON","createDrumManager","samples","synthEngine","initialVolume","drumPlayers","drumVolumeNode","lastDrumStartTimes","getSafeDrumStartTime","trackId","requestedTime","safeTime","lastTime","synthEngineDestination","FLAT_SYMBOL","SHARP_SYMBOL","binarySearchTimeMap","low","high","mid","colStart","colEnd","createTransportService","stateCallbacks","eventCallbacks","visualCallbacks","playbackMode","highwayService","playheadAnimationFrame","shouldAnimatePlayhead","timeMapCalculator","drumManager","lastAppliedTempoMultiplier","eventCleanups","getPitchFromRow","rowIndex","getPitchForNote","scheduleNotes","anacrusisOffset","noteIndex","canvasStartIndex","canvasEndIndex","regularStartTime","scheduleTime","regularEndTime","tailDuration","scheduleRumNote","schedulePitchedNote","stampPlaybackData","stampData","scheduleStamp","tripletPlaybackData","tripletData","scheduleTriplet","drumTrack","trackKey","toolColor","pitchColor","releaseTime","maxReleaseTime","canvasColumnIndex","cellStartTime","scheduleStampEvent","baseRow","offsetTime","eventDuration","triggerTime","shapeRow","shapePitch","animatePlayhead","baseTempo","TEMPO_MULTIPLIER_EPSILON","MARKER_PASS_EPSILON","getMarkerX","initialBpm","draw","currentState","transportLoopEnd","playbackEnd","currentTimeMs","reachedEnd","loopAwareTime","loopDuration","maxXPos","_d","_e","xPos","activeColumnStartX","activeColumnWidth","activeDisplayColumnIndex","foundIndex","colStartTime","colEndTime","displayColIndex","colStartX","_f","colWidth","_g","colDuration","timeIntoCol","finalXPos","applyTempoModulation","canvasHeight","_h","drumCanvasHeight","_i","macroRect","_j","highlightX","highlightWidth","_k","_l","_m","_n","shouldShowBeatLineHighlight","_o","activeMarkers","targetMultiplier","markerX","newTempo","rhythmHandler","notesHandler","stampsHandler","modulationHandler","layoutHandler","oldWidths","newWidths","tempoHandler","currentPosition","loopingHandler","musicalDuration","cleanup","DEFAULT_CONTEXT_OPTIONS","configureAudioContext","latencyHint","lookAhead","createdNewContext","getContextInfo","rawContext","baseLatency","createCoordinateUtils","cachedViewportInfo","lastViewportFrame","getCachedViewportInfo","currentFrame","invalidateViewportCache","getColumnX","cellWidth","x","getRowY","viewportInfo","relativeRowIndex","halfUnit","getColumnFromX","canvasX","getRowFromY","canvasY","getVisibleRowRange","startRank","endRank","endRow","getPitchClass","pitchWithOctave","pc","getLineStyleFromPitchClass","DEGREE_SEPARATOR","OVAL_NOTE_FONT_RATIO","FILLED_NOTE_FONT_RATIO","MIN_FONT_SIZE","MIN_STROKE_WIDTH_THICK","STROKE_WIDTH_RATIO","TAIL_LINE_WIDTH_RATIO","MIN_TAIL_LINE_WIDTH","SHADOW_BLUR_RADIUS","createNoteRenderer","coords","getUuidTimestamp","timestampSegment","hasVisibleTail","baselineEnd","hasRenderableDimensions","height","calculateColorOffset","allNotes","offsetAmount","noteUuid","notesAtSamePosition","otherNote","allNotesAtPosition","calculateVibratoYOffset","cellHeight","animationManager","calculateTailYOffset","tailOffsetAmount","notesWithTailsAtSamePosition","allNotesWithTailsAtPosition","getScaleDegreeLabel","degreeStr","accidentalMode","sharpEnabled","flatEnabled","sharpLabel","flatLabel","enharmonic","label","parts","getDegreeFontMultiplier","hasFlat","hasSharp","hasBothAccidentals","drawScaleDegreeText","ctx","centerX","centerY","noteWidth","noteLabel","contentMultiplier","baseFontSize","circleBaseSize","ovalBaseSize","lineHeight","totalHeight","startY","part","y","opticalOffset","applyReverbGlow","hasReverbEffect","reverbEffect","blur","spread","drawDelayGhostNotes","rx","ry","delayEffects","echo","offsetX","echoX","echoRx","echoRy","drawEnvelopeFill","fillLevel","innerRatio","gradient","drawEnvelopeFillStadium","leftCenterX","rightCenterX","stadiumCenterX","stadiumWidth","gradientRadius","drawStadiumShape","strokeWidth","drawTwoColumnOvalNote","placedNotes","baseY","vibratoYOffset","xStart","actualCellWidth","dynamicStrokeWidth","hasTail","longNoteStyle","originalEndX","tailYOffset","tailY","reverbGlow","drawSingleColumnOvalNote","currentCellWidth","cx","createGridLineRenderer","drawHorizontalLines","canvasWidth","startRow","drawVerticalLines","hasAnacrusis","anacrusisColors","inAnacrusis","anacrusisStartX","lineX","renderPitchGrid","opts","gridLines","noteRenderer","gridLineOptions","noteOptions","visibleNotes","tonicSign","drawTonicSign","radius","numberText","fontSize","DRUM_TRACKS","mergeRanges","ranges","sorted","merged","r","last","buildSegments","startX","endX","lightRanges","points","clampedStart","clampedEnd","sortedPoints","from","to","light","tonicSigns","shouldDrawVerticalLine","drawDrumShape","drumRow","cy","size","angle","sx","sy","createDrumGridRenderer","DEFAULT_ANACRUSIS_COLORS","buildLightRanges","anacrusisEndColumn","end","getAnacrusisEndColumn","solidBoundaryIndex","mbInfo","musicalColumnWidths","canvasCol","isGridStartOrEnd","isTonicColumnStart","isTonicColumnEnd","isMacrobeatEnd","drumRowHeight","seg","drawDrumNotes","drumHit","animationScale","renderDrumGrid","baseDrumRowHeight","drumHeightScaleFactor","renderer","DEFAULT_CONFIG","createFeedbackCollector","finalConfig","activeNotes","performances","calculateCentDeviation","actualMidi","targetMidi","isPitchCorrect","sample","calculateAveragePitchDeviation","calculatePitchCoverage","noteStartMs","noteDurationMs","correctSamples","coveredMs","nextSample","sampleDuration","determineAccuracyTier","onsetAccuracyMs","pitchAccuracyCents","pitchCoverage","tiers","absOnset","analyzePerformance","noteData","onsetSample","releaseSample","releaseAccuracyMs","noteEndMs","onsetOk","releaseOk","pitchOk","hitStatus","accuracyTier","onsetWindow","releaseWindow","performance","createNoteHighwayService","feedbackCollector","animationFrameId","notesInWindow","getOnrampDurationMs","beatDurationMs","getJudgmentLineX","calculateScrollOffset","timeMs","pixelsPerMs","judgmentLineX","onrampDurationMs","isNoteInJudgmentWindow","noteStartX","noteEndX","windowTolerancePx","updateActiveNotes","currentActiveNotes","tolerance","eventData","updateJudgmentWindow","inWindow","wasInWindow","updateOnramp","msRemaining","beatsRemaining","animate","startAnimation","stopAnimation","pausedDuration","midi","clarity","source","viewportWidth","calculateMicrobeatDuration","convertNoteToHighway","startTimeMs","endTimeMs","startTimeSec","endTimeSec","durationMs","convertNotesToHighway","createSimpleTimeMap","microbeatDurationSec","convertStateToHighway","VERSION"],"mappings":"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"}